<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>政治识记</title>
      <link href="/2020/06/09/Public/"/>
      <url>/2020/06/09/Public/</url>
      
        <content type="html"><![CDATA[<h3 id="马克思前言"><a href="#马克思前言" class="headerlink" title="马克思前言"></a>马克思前言</h3><h4 id="一、时代课题原因"><a href="#一、时代课题原因" class="headerlink" title="一、时代课题原因"></a>一、时代课题原因</h4><ul><li>马理论发展 内在要求</li><li>解决 中国实际 客观需要<h4 id="二、中国化内涵"><a href="#二、中国化内涵" class="headerlink" title="二、中国化内涵"></a>二、中国化内涵</h4></li><li>马原理 同 中国实际 时代特征 结合 运 立观方 研究解决 革建改 实际问题</li><li>总 炼 革建改 经验 认识掌握 规律 为 理论 添 内容</li><li>喜闻乐见 民族语言 阐述 理论 成为 中国特色 风格 气派的马主义<h4 id="科学内涵"><a href="#科学内涵" class="headerlink" title="科学内涵"></a>科学内涵</h4></li><li>自然 人类社会 人思维发展 规律 理论</li><li>揭示 事物本质 内在联系 发展规律 观察世界 分析问题 思想武器</li><li>实践品格 解释 改变世界</li><li>只有中国化 真理 救 发展 中国 社会主义<h3 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h3><h4 id="一、形成发展过程"><a href="#一、形成发展过程" class="headerlink" title="一、形成发展过程"></a>一、形成发展过程</h4></li><li>萌芽：一次国内革命</li><li>形成：土地革命 农包武夺道路</li><li>成熟：遵义-抗日结束 阐述新民理论、路线、纲领</li><li>发展：解放后 马列 革命 建设 二次结合<h4 id="二、实事求是"><a href="#二、实事求是" class="headerlink" title="二、实事求是"></a>二、实事求是</h4></li><li>马主义 根本观点</li><li>按 规律 办事</li><li>认识把握 国情</li><li>实践基础 理论创新<h4 id="三、群众路线"><a href="#三、群众路线" class="headerlink" title="三、群众路线"></a>三、群众路线</h4></li><li>为了 依靠 从中来 从中去 党主张 变 自觉行动 是生命线 根本工作路线</li><li>本质 人民 历史创造者 基本原理</li><li>坚持 人民 推动 历史 根本力量 尊重 首创精神 表达意愿 经验 权利 行使 人民 给予 接受 监督</li><li>全心全意 服务 根本宗旨 放在首位</li><li>保持 血肉联系 植根 全党 思想 落实 每个党员 行动<h4 id="四、评价"><a href="#四、评价" class="headerlink" title="四、评价"></a>四、评价</h4></li><li>十一届六中 作科学 实事求是 评价</li><li>是马克思主义者 无产阶级革命 战略 理论家 为党国人民 巨大贡献</li><li>晚年错误 功绩主 错误次 是革命家 马克思主义者犯的错</li><li>错误 思想 区分 才能正确理解<h3 id="新民主主义革命理论⭐"><a href="#新民主主义革命理论⭐" class="headerlink" title="新民主主义革命理论⭐"></a>新民主主义革命理论⭐</h3><h4 id="一、国情"><a href="#一、国情" class="headerlink" title="一、国情"></a>一、国情</h4></li><li>鸦片战争后 两半 基本国情</li><li>帝国与民族 主要矛盾 封建与人民                           </li><li>根本任务 推翻帝官(僚)封<h4 id="二、特征"><a href="#二、特征" class="headerlink" title="二、特征"></a>二、特征</h4></li><li>特征 资产阶级民主革命</li><li>十月革命 旧转新</li><li>五四 新民革命 开端<h4 id="三、实践基础"><a href="#三、实践基础" class="headerlink" title="三、实践基础"></a>三、实践基础</h4></li><li>旧革命失败 呼唤 新</li><li>新民探索 奠定 理论基础</li><li>无实践 概括 总结 就无法形成<h4 id="四、对象路线"><a href="#四、对象路线" class="headerlink" title="四、对象路线"></a>四、对象路线</h4></li><li>帝国 首要对象 最大障碍 总根源</li><li>封建地主 旧社会 统治基础</li><li>官僚 依帝 勾封 国家垄断资本主义</li><li>总路线 无产领导 人民大众 反帝官封<h4 id="五、动力"><a href="#五、动力" class="headerlink" title="五、动力"></a>五、动力</h4></li><li>无产阶级 基本动力 最早 最进步 领导阶级</li><li>农民 主力军 可靠同盟军 基本问题</li><li>城市小资产 可靠同盟 知识 小商人 手工业 自由职业</li><li>民族资产 两面性<h4 id="六、领导"><a href="#六、领导" class="headerlink" title="六、领导"></a>六、领导</h4></li><li>无产阶级 领导权 中国革命中心问题 新民理论核心问题</li><li>区别新旧 关键 领导权</li><li>无产阶级 三重压迫 分布集中 出身农民<h4 id="七、新旧区别"><a href="#七、新旧区别" class="headerlink" title="七、新旧区别"></a>七、新旧区别</h4></li><li>时代不同</li><li>领导不同</li><li>思想不同</li><li>前途不同<h4 id="八、纲领"><a href="#八、纲领" class="headerlink" title="八、纲领"></a>八、纲领</h4></li><li>政治 推翻 帝封 无产领导 工农基础 各阶级专政 新民共和国</li><li>经济 封建地主 农民 主要内容 官僚资本 国家 应有之义 保护 民族工商 特色</li><li>文化 民族 科学 大众<h4 id="九、意义"><a href="#九、意义" class="headerlink" title="九、意义"></a>九、意义</h4></li><li>指导 革命 胜利</li><li>马克思 中国 结合典范</li><li>丰富 马克思 理论<h4 id="十、道路内容"><a href="#十、道路内容" class="headerlink" title="十、道路内容"></a>十、道路内容</h4></li><li>农包 武夺</li><li>内容 土地革命 基本内容 武装斗争 主要形式 有力保证 农村革命根据地 战略阵地 革命依托</li><li>实现三者 密切结合 有机统一 不照抄十月<h3 id="社会主义改造"><a href="#社会主义改造" class="headerlink" title="社会主义改造"></a>社会主义改造</h3><h4 id="一、转变"><a href="#一、转变" class="headerlink" title="一、转变"></a>一、转变</h4></li><li>过渡性 成立 改造完成</li><li>性质 新民社会 非独立 过渡形态</li><li>经济上 国营 个体 合作社 私资 国资</li><li>阶级 工人 农民 其他小资产 民族资产</li><li>社会因素 主导 非社会 比重大<h4 id="二、路线-依据"><a href="#二、路线-依据" class="headerlink" title="二、路线 依据"></a>二、路线 依据</h4></li><li>总路线 一化三改</li><li>建设 改造 并举 体现紧密 解放 发展 变革 统一<h4 id="三、改造道路"><a href="#三、改造道路" class="headerlink" title="三、改造道路"></a>三、改造道路</h4></li><li>农业 手工业 积极组织 互助合作 自愿互利 典型示范 国家帮助 阶级政策 循序渐进</li><li>工商业 和平赎买 低到高过渡 改造 自食其力<h4 id="四、经验"><a href="#四、经验" class="headerlink" title="四、经验"></a>四、经验</h4></li><li>坚持 建设 改造 并举</li><li>积极引导 逐步过渡</li><li>和平 改造<h4 id="五、意义"><a href="#五、意义" class="headerlink" title="五、意义"></a>五、意义</h4></li><li>促进 生产力</li><li>劳动人民 国家主人</li><li>维护 和平 影响</li><li>独创 理论原则 经验总结 丰富 科社理论<h3 id="初步探索理论成果"><a href="#初步探索理论成果" class="headerlink" title="初步探索理论成果"></a>初步探索理论成果</h3><h4 id="一、重要思想成果"><a href="#一、重要思想成果" class="headerlink" title="一、重要思想成果"></a>一、重要思想成果</h4></li><li>论十大关系 自主探索 适合国情 道路</li><li>基本方针 调动 积极因素 为社会主义服务</li><li>三方针 坚持党领导 发展社民政 认识社发展阶段 建设规律 发达 不发达</li><li>十大标志 探索 良好开端<h4 id="二、矛盾思想"><a href="#二、矛盾思想" class="headerlink" title="二、矛盾思想"></a>二、矛盾思想</h4></li><li>改造后 人民内部矛盾 主导</li><li>基本矛盾 生产关系 生产力 上层建筑 经济基础 </li><li>基本矛盾 非对抗性 相适应 相矛盾</li><li>主要矛盾 工业 农业 经文发展需要 不能满足需要</li><li>敌我 内部 不同 专政 民主<h4 id="四、意义"><a href="#四、意义" class="headerlink" title="四、意义"></a>四、意义</h4></li><li>巩固 发展 社会主义制度</li><li>开创 中特 提供 宝贵经验 理论准备 物质基础</li><li>丰富 科学社会主义理论 实践<h3 id="邓小平理论⭐"><a href="#邓小平理论⭐" class="headerlink" title="邓小平理论⭐"></a>邓小平理论⭐</h3><h4 id="一、形成"><a href="#一、形成" class="headerlink" title="一、形成"></a>一、形成</h4></li><li>和平发展 时代背景 建设经验教训 历史依据 改开现代化建设 现实依据</li><li>十一届三中 确立 解放思想 实事求是 转移 经济建设 改革开放</li><li>十二大 提 建设 中特</li><li>十三大 首次 论述 初级阶段 理论 基本路线</li><li>南方谈话 社会主义本质 市场经济关系</li><li>十五大 入党章<h4 id="二、回答问题"><a href="#二、回答问题" class="headerlink" title="二、回答问题"></a>二、回答问题</h4></li><li>什么是社会主义 如何建设</li><li>本质 解放 发展 生产力 消灭 剥削 两级分化 共同富裕<h4 id="三、主要内容"><a href="#三、主要内容" class="headerlink" title="三、主要内容"></a>三、主要内容</h4></li><li>解放思想 实事求是 思想路线</li><li>初级阶段论</li><li>党 基本路线</li><li>根本任务论</li><li>三步走</li><li>改革开放</li><li>市场经济论</li><li>两手抓</li><li>一国两制</li><li>关键 在于党<h4 id="四、市场经济理论内容"><a href="#四、市场经济理论内容" class="headerlink" title="四、市场经济理论内容"></a>四、市场经济理论内容</h4></li><li>计划 市场 非划分标志 计划不等社 市场不等资</li><li>都是经济手段 各有长处优势 要两者结合</li><li>市场 不具有 制度属性 不同结合 不同性质<h3 id="新中特思想-地位"><a href="#新中特思想-地位" class="headerlink" title="新中特思想 地位"></a>新中特思想 地位</h3><h4 id="一、成就"><a href="#一、成就" class="headerlink" title="一、成就"></a>一、成就</h4></li><li>经建 取 成就</li><li>深改 取 突破</li><li>民法 迈 步伐</li><li>思文 取 进展</li><li>人民 生活 改善</li><li>生态 成效 显著</li><li>强军 开 新局</li><li>港澳台 取 进展</li><li>外交 深入 展开</li><li>治党 成效 卓著<h4 id="二、变革"><a href="#二、变革" class="headerlink" title="二、变革"></a>二、变革</h4></li><li>党领导 全面加强</li><li>坚定 贯彻 新发展理念</li><li>全面 深改</li><li>推进 依法</li><li>加强 意识 领导</li><li>推进 生态 建设</li><li>推进 国军 现代化</li><li>推进 特色 外交</li><li>推进 治党<h4 id="三、矛盾变化"><a href="#三、矛盾变化" class="headerlink" title="三、矛盾变化"></a>三、矛盾变化</h4></li><li>改造后 工业 农业 经文 发展 不能满足 矛盾</li><li>十一届六中 改述 人民 增长 物质文化 落后 社会生产</li><li>十九大人民 增长 美好生活 不平衡重复</li><li>没有变 历史阶段 初级阶段 基本国情 最大 发展中 国际地位<h4 id="四、要义-内涵"><a href="#四、要义-内涵" class="headerlink" title="四、要义 内涵"></a>四、要义 内涵</h4></li><li>坚持发展 中特 改革开放后 理论 实践 主题 中特思想 核心要义<h4 id="七、关系"><a href="#七、关系" class="headerlink" title="七、关系"></a>七、关系</h4></li><li>明确 思想层面 怎么看 坚持发展什么样中特</li><li>坚持 行动层面 怎么做 怎么样坚持发展中特<h4 id="八、成果"><a href="#八、成果" class="headerlink" title="八、成果"></a>八、成果</h4></li><li>新中特与 马列 毛 邓 三 科 一脉相承 与时俱进 中国化飞跃 21世纪马克思</li><li>开辟 马 中特 新境界 人类文明进步 重要意义<h3 id="总任务中国梦"><a href="#总任务中国梦" class="headerlink" title="总任务中国梦"></a>总任务中国梦</h3><h4 id="一、本质"><a href="#一、本质" class="headerlink" title="一、本质"></a>一、本质</h4></li><li>国家富强 民族振兴 人民幸福</li><li>国家 追求 民族 向往 人民 期盼 融合</li><li>国家 民族 人民 情怀 统一</li><li>归根 人民的梦</li><li>国家 民族 每一国人 梦</li><li>与世界人民 梦相通<h4 id="二、关系"><a href="#二、关系" class="headerlink" title="二、关系"></a>二、关系</h4></li><li>基础 保障 国富 民振</li><li>题中之义 必然要求 根本出发点 落脚点 人民幸福<h4 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h4></li><li>走中特道路 弘扬爱国核民族/改革核时代精神 凝聚各族人民大团结力量</li><li>复兴 海内外 共同 梦想</li><li>实干 梦想成真</li><li>任重道远 锲而不舍 艰苦努力</li><li>需 和平<h3 id="五位一体⭐"><a href="#五位一体⭐" class="headerlink" title="五位一体⭐"></a>五位一体⭐</h3><h4 id="一、经济"><a href="#一、经济" class="headerlink" title="一、经济"></a>一、经济</h4></li><li>十八届五中 提 新发展</li><li>创新 动力 发展动力</li><li>协调 内要求 发展不平衡</li><li>绿色 条件 人自然和谐</li><li>开放 必由路 内外联动</li><li>共享 本质要求 公平正义<h4 id="二、关系-1"><a href="#二、关系-1" class="headerlink" title="二、关系"></a>二、关系</h4></li><li>相互 贯通 促进 内在联系 集合体</li><li>分别 解决 问题</li><li>整体把握 提高 统筹 贯彻水平 推动 现经体系<h4 id="三、结构性改革"><a href="#三、结构性改革" class="headerlink" title="三、结构性改革"></a>三、结构性改革</h4></li><li>推进 动能转换 制造业 重点 提升 实体</li><li>市场化 配置改革 价转质</li><li>加大 人力 培育 调动 保护 积极性</li><li>三去一降一补 优化 供求 结构      <h4 id="四、政治"><a href="#四、政治" class="headerlink" title="四、政治"></a>四、政治</h4></li><li>党领导 人民当家 依法 有机统一</li><li>根本保证 党领导</li><li>本质特征 人民当家</li><li>基本方式 依法</li><li>三者 统一 社会民政 实践</li><li>正确 政治 方向<h4 id="五、制度体系"><a href="#五、制度体系" class="headerlink" title="五、制度体系"></a>五、制度体系</h4></li><li>根本制度 最高 最好 形式 人大</li><li>特有形式 独特优势 协商民主 丰富形式 内涵 拓展渠道</li><li>基本制度 多党 政治协商</li><li>重要渠道 专门机构 人民政协 主题 团结民主 职能 政治协商 民主监督 参政议政</li><li>基本制度 民族区域 基层群众 自治<h4 id="六、一国两制"><a href="#六、一国两制" class="headerlink" title="六、一国两制"></a>六、一国两制</h4></li><li>一国 两制 关系</li><li>依照 宪 基本法</li><li>聚焦 发展 要务</li><li>维护 稳定 社会<h4 id="七、价值观"><a href="#七、价值观" class="headerlink" title="七、价值观"></a>七、价值观</h4></li><li>24字真言 建设国家 建设社会 培育公民 精神集中体现 凝结价值追求 基本内容</li><li>融入 生活 方面</li><li>全民 干部 家庭 娃娃</li><li>立足 传统 革命 文化</li><li>伟大民族 创造 奋斗 团结 梦想 精神<h4 id="八、意识形态"><a href="#八、意识形态" class="headerlink" title="八、意识形态"></a>八、意识形态</h4></li><li>坚持 马克思 指导</li><li>构建 中特 哲社科</li><li>正确 舆论</li><li>网络 空间</li><li>意识形态 工作责任制<h4 id="九、文化自信"><a href="#九、文化自信" class="headerlink" title="九、文化自信"></a>九、文化自信</h4></li><li>文化强国 具有 强大文化力量 既表高素质国民 也表文化产业 软实力</li><li>培 高度 文化自信 国家民族 基本 深沉 持久 力量</li><li>大力发展 文化事业 产业 体现 社特色</li><li>提 软实力 集中体现 凝聚 生命力 由此产生 吸引 影响力<h4 id="十、安全观"><a href="#十、安全观" class="headerlink" title="十、安全观"></a>十、安全观</h4></li><li>宗旨 人民安全 根本 政治 基础 经济 保障 军文社 依托 国际 维护国家安全 构建体系 走中特</li><li>完善 国家 安全体系</li><li>健全 公共 安体</li><li>平安中国</li><li>安全能力 建设</li><li>安全 教育<h4 id="十一、自然"><a href="#十一、自然" class="headerlink" title="十一、自然"></a>十一、自然</h4></li><li>核心 人自然共生</li><li>首要态度 尊重</li><li>基本原则 顺应</li><li>重要责任 保护</li><li>中华民族 生命之根 发展之源<h3 id="四个全面⭐"><a href="#四个全面⭐" class="headerlink" title="四个全面⭐"></a>四个全面⭐</h3><h4 id="一、全面小康"><a href="#一、全面小康" class="headerlink" title="一、全面小康"></a>一、全面小康</h4></li><li>十八大 提 小康</li><li>小康 发展水平 全面 发展平衡 协调 可持续性</li><li>内涵 经发 民全 科进 文荣 社谐 生殷</li><li>领域全面 五位一体的全面</li><li>人口全面 惠全 区域全面 城乡共同</li><li>实事求是 因地制宜<h4 id="目标要求"><a href="#目标要求" class="headerlink" title="目标要求"></a>目标要求</h4></li><li>经济 中高速</li><li>创新驱动 卓著</li><li>发展协调 明显 增强</li><li>人生活水平 质量 提高</li><li>国民素质 社文程度 提高</li><li>环境 总体 改善</li><li>各制度 成熟 定型<h4 id="决胜"><a href="#决胜" class="headerlink" title="决胜"></a>决胜</h4></li><li>重大风险</li><li>精准扶贫</li><li>污染防治</li><li>经济社会 持续健康 发展<h4 id="二、改革"><a href="#二、改革" class="headerlink" title="二、改革"></a>二、改革</h4></li><li>顺应世界 必然趋势</li><li>解决中问 根本途径</li><li>党民事业 前途命运</li><li>党执政 基础地位</li><li>党 集中统一 领导</li><li>必沿 中特方向 前进</li><li>必坚 维护公平正义 增进福祉</li><li>必坚 市场经济 改革方向<h4 id="目标-关系"><a href="#目标-关系" class="headerlink" title="目标 关系"></a>目标 关系</h4></li><li>完善中特制度 推进治理体系能力 现代化</li><li>处理 解放思想 实事求是 关系</li><li>顶层设计 摸石过河</li><li>整体推进 重点突破</li><li>胆子要大 步子要稳</li><li>改革 发展 稳定<h4 id="考验-危险"><a href="#考验-危险" class="headerlink" title="考验 危险"></a>考验 危险</h4></li><li>执政 改开 市经 外部 考验</li><li>精神 能力 脱离 消极腐败 危险<h4 id="三、法制"><a href="#三、法制" class="headerlink" title="三、法制"></a>三、法制</h4></li><li>法制道路 坚党领导</li><li>坚民主体</li><li>坚法前平等</li><li>坚法德结合</li><li>坚实际出发<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4></li><li>体系建设</li><li>完善宪核心 中特法制体系</li><li>建立 法监督体系</li><li>健全 法保障体系</li><li>加强 党内法建设</li><li>深化依法治国实践<h4 id="四、治党"><a href="#四、治党" class="headerlink" title="四、治党"></a>四、治党</h4></li><li>方针 党要管党 从严治党</li><li>全面 基础 严 关键 治 要害</li><li>政治建设 首位 一旗帜讲政治 根本要求 二党政建 根本性建设 三党政建 是十八大来全治党 成果</li><li>治党路上 一加强思想建设 二组织 三持之以恒正风肃纪 四制度贯穿各项中 五标本兼治反腐败<h3 id="党领导"><a href="#党领导" class="headerlink" title="党领导"></a>党领导</h3><h4 id="复兴关键"><a href="#复兴关键" class="headerlink" title="复兴关键"></a>复兴关键</h4></li><li>在于党 是历史 人民 选择<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4></li><li>党领导 中特本质特征 决定由 科社 理论逻辑 中特发展历史逻辑 实践逻辑</li><li>最大优势 中特制度党领民建 发中特优势根本保障 党优势是中特优势的来源<h4 id="使命"><a href="#使命" class="headerlink" title="使命"></a>使命</h4></li><li>伟大斗争 工程 事业 梦想</li><li>梦想目标指方向 斗争手段激动力 工程保障提保证 事业主体开道路<h4 id="一切工作领导"><a href="#一切工作领导" class="headerlink" title="一切工作领导"></a>一切工作领导</h4></li><li>党最高政治力量</li><li>马政党 基本要求</li><li>党领革建改经验总结</li><li>推伟事业保证<h4 id="执政本领"><a href="#执政本领" class="headerlink" title="执政本领"></a>执政本领</h4></li><li>增学习 政治领导 改革创新 科学发展 依法执政 群众工作 狠抓落实 驾驭风险本领</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言知识点</title>
      <link href="/2020/06/02/C/"/>
      <url>/2020/06/02/C/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-C语言概述"><a href="#第一章-C语言概述" class="headerlink" title="第一章 C语言概述"></a>第一章 C语言概述</h3><p>C语言程序设计总体上必须清楚:</p><ol><li>程序结构是三种:顺序结构,循环结构(三个循环结构),选择结构(if 和 switch)</li><li>计算机的数据在电脑中保存是以二进制的形式。数据存放的位置就是 它的地址.</li><li>bit位 是指为0 或者1。byte字节,1byte = 8bit.</li><li>一定要记住 二进制 如何划成 十进制。<blockquote><p>二进制转十进制采用权相加法，2的几次方由在它的前面还有几位，那么它的次数就是为几；<br>比如1011010转成十进制，1*26+0*25+1*24+1*23+0*22+1*21+0*20 = 64+0+16+8+0+2+0 = 90<br>概念常考到：</p></blockquote></li><li>编译预处理不是C语言的一部分,不占用运行时间。C语言编译的程序称为源程序，它以ASCII数值存放在文本文件中。<h3 id="第二章-数据类型、运算符和表达式、位运算"><a href="#第二章-数据类型、运算符和表达式、位运算" class="headerlink" title="第二章 数据类型、运算符和表达式、位运算"></a>第二章 数据类型、运算符和表达式、位运算</h3></li><li>合法的用户标识符考查：C语言是区分大小写<br> 合法的用户标识符要求是由字母，数字，下划线组成。并且第一个必须为字母或则是下划线。<br> 关键字不可以作为用户标识符号。<strong>迷惑你的地方If是可以做为用户标识符。因为If中的第一个字母大写了，所以不是关键字。</strong></li><li>实型数据的合法形式：<br> 333e-1 就是合法的，且数据是2.333×<br> 考试口诀：e前e后必有数，e后必为整数。</li><li>字符数据的合法形式：<br> ‘1’ 是字符占一个字节，”1”是字符串占两个字节(含有一个结束符号’\0’)。<br> ‘0’ 的ASCII数值表示为48，’A’的ASCII数值是65，’a’的ASCII数值是97。</li><li>整型一般是4个字节, 字符型是一个字节，双精度一般是8个字节。</li><li>转义字符的考查：<br>在程序中 int a = 0x6d，是把一个十六进制的数给变量a，注意这里的0x必须存在。<br>在程序中 int a = 06d(错了), 是一个八进制的形式。<br>在转义字符中，’\x6d’ 才是合法的，0不能写，并且x是小写。’\141’ 是合法的。<br>‘\208’是非法的，因为不可能出现8，八进制是没有8的，逢8进1。<br>转义字符的意义 ASCII码值(十进制)<br>\a 响铃(BEL) 007<br>\b 退格(BS) 008<br>\f 换页(FF) 012<br>\n 换行(LF) 010<br>\r 回车(CR) 013<br>\t 水平制表(HT) 009<br>\v 垂直制表(VT) 011<br>\ 反斜杠 092<br>? 问号字符 063<br>&#39; 单引号字符 039<br>&quot; 双引号字符 034<br>\0 空字符(NULL) 000<br>\ddd 任意字符 三位八进制<br>\xhh 任意字符 二位十六进制</li><li>强制类型转换：<br> 一定是 (int)a 不是int(a)，<strong>类型上一定有括号</strong>。<br> 注意(int)(a+b)和(int)a+b 的区别。前是把a+b转型，后是把a转型再加b。</li><li>表达式的考查：<br> 是表达式就一定有数值。<br> 赋值表达式：表达式数值是最左边的数值，a=b=5;该表达式为5，常量不可以赋值。</li></ol><p><strong>逗号表达式：优先级别最低</strong>;表达式的数值是逗号最右边的那个表达式的数值。<br>例：(2，3，4)的表达式的数值就是4。</p><ol start="8"><li>位运算的考查：<br>方法：几乎所有的位运算的题目都要按这个流程来处理（先把十进制变成二进制再变成十进制）。<br>例1：　char a = 6, b;<br>　　　　b = a&lt;&lt;2;<br>这种题目的计算是先要把a的十进制6转化成二进制110，再做位运算。将a的二进制向左移2位，后面补0，变为11000=24，所以b=24。<br>一定要记住，在没有舍去数据的时候，&lt;&lt;左移一位表示乘以2；&gt;&gt;右移一位表示除以2。<br>C语言中位运算符之间，按优先级顺序排列为<br>1    ~ 取反运算<br>2    &lt;&lt;、&gt;&gt; 左移右移运算<br>3    &amp; 与运算，同1为1，有0为0<br>4    ^ 异或运算，不同为1，相同为0<br>5    | 或运算，有1为1，同0为0<br>6    &amp;=、^=、|=、&lt;&lt;=、&gt;&gt;=</li><li>%符号两边要求是整数。不是整数就错了。</li><li>两种取整丢小数的情况：<br>int a =1.6；<br>(int)a；　<h3 id="第三章-顺序程序设计"><a href="#第三章-顺序程序设计" class="headerlink" title="第三章 顺序程序设计"></a>第三章 顺序程序设计</h3></li><li>printf函数的格式考查：<br> 宽度的%md,%m.nf，左对齐%-md等修饰。%ld对应 long int；%lf 对应double。</li><li>putchar ,getchar 函数的考查：<br>char  a = getchar() 是没有参数的，从键盘得到你输入的一个字符给变量a。<br>putchar(‘y’)把字符y输出到屏幕中。</li><li><strong>如何实现保留三位小数，第四位四舍五入的程序</strong><br> x=(int)(x*1000+0.5)/1000.0<br> 这个有推广的意义，注意 x = (int)x 这样是把小数部分去掉。<h3 id="第四章-选择结构程序设计"><a href="#第四章-选择结构程序设计" class="headerlink" title="第四章 选择结构程序设计"></a>第四章 选择结构程序设计</h3>注意：c语言中是用非0表示逻辑真的，用0表示逻辑假的。</li><li>关系表达式：<br> 表达式的数值只能为1（表示为真），或0（表示假）,当关系的表达是为真的时候得到1。如 9&gt;8这个是真的，所以表达式的数值就是1；</li><li>逻辑表达式：<br> 只能为1（表示为真），或0（表示假）<br>共有&amp;&amp;   ||   ！ 三种逻辑运算符号。</li></ol><p><strong>！&gt;&amp;&amp;&gt;||  优先的级别。</strong><br><strong>注意短路现象:设整型变量</strong> m,n,a,b,c,d 均为1，执行 (m=a&gt;b)&amp;&amp;(n=c&gt;d)后, m,n 的值是0，1。<br>要表示 x 是比0大，比10小的方法。<strong>0&lt;x&lt;10是不可以的</strong>。是先计算0&lt;x 得到的结果为1或为0；再用0，或1与10比较得到的总是真（为1）。所以一定要用 (0&lt;x)&amp;&amp;(x&lt;10)表示比0大比10小。</p><ol start="3"><li>if 语句<br> else 是与最接近的if且没有else的相组合的。</li><li>条件表达式： 正确书写if（条件表达式）计算整数位数、5个数输出一行<br> 表达式1 ？表达式2 ：表达式3<br> 注意是当非0时候是表达式2的数值，当为0时就是表达式3的数值。<h3 id="第五章-循环结构程序"><a href="#第五章-循环结构程序" class="headerlink" title="第五章 循环结构程序"></a>第五章 循环结构程序</h3></li><li>三种循环结构：<br> for(;;){}  while(){}  do{}while();三种。<br> 写程序的时候一定要注意，循环一定要有结束的条件，否则成了死循环。<br> <strong>do-while();的分号一定不能够丢。</strong></li><li>while((c=getchar())!=’\n’) 和 while(c=getchar() != ‘\n’）的差别<br>先看a = 3 != 2  和 (a=3)!=2 的区别：<br>(<strong>!=号的级别高于=号</strong> 所以第一个先计算 3!=2) 第一个a的数值是得到的1；第二个a的数值是3。注意: 括号在这里的重要性。<h3 id="第六章-数组"><a href="#第六章-数组" class="headerlink" title="第六章 数组"></a>第六章 数组</h3></li><li>一维数组的重要概念：<br>对a[10]这个数组的讨论。<br>a表示数组名，是第一个元素的地址，也就是元素a[0]的地址a==&amp;a[0]<br>a是地址常量，所以只要出现a++，或者是a=a+2赋值的都是错误的。<br>a是一维数组名，所以它是列指针，也就是说a+1是跳一列。</li><li>对a[3][3]的讨论。<br>a[0]、a[1]、a[2]也都是地址常量，不可以对它进行赋值操作，同时它们都是列指针，a[0]+1，a[1]+1，a[2]+1都是跳一列。<br>注意a和a[0] 、a[1]、a[2]是不同的，它们的基类型是不同的。前者是一行元素，后三者是一列元素。<br>数组的初始化，一维和二维的，一维可以不写，<strong>二维第二个一定要写</strong><br>int a[]={1，2} 合法。  int a[][4]={2，3，4}合法。  但int a[4][]={2，3，4}非法。<h3 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h3>函数：是具有一定功能的一个程序块；</li><li>一定要注意参数之间的传递<br> <strong>实参和形参之间 传数值，和传地址的差别。</strong><br> 传数值的话，形参的变化不会改变实参的变化。<br> 传地址的话，形参的变化就会有可能改变实参的变化。</li><li>函数声明的考查：<br>一定要有：函数名，函数的返回类型，函数的参数类型。<strong>不一定要有：形参的名称。</strong></li><li>局部、全局变量和存储分类<blockquote><p>【定义】局部变量是在函数内部或复合语句内部定义的变量。<br>【作用域】局部变量只能在定义它的函数（或复合语句）中使用，离开了定义，它的函数（或复合语句）就不能使用。<br>局部变量有 4种存储类型：自动型；寄存器型；静态型；外部参照型。</p></blockquote></li><li>局部变量的生存期<blockquote><p>自动（auto）型局部变量是分配在内存的堆栈段，内存的堆栈在程序中的运行过程中是重复使用的。<br>寄存器局部变量也是自动类局部变量。它与 auto 变量的区别在于，寄存器型变量是分配在 CPU 通用寄存器中的，而不是像一般变量那样占用内存单元。<br>静态局部型变量是分配在内存的数据段中的它们在程序开始运行时就分配了固定的存储单元，在程序运行过程中不释放，直到程序运行结束才释放它所占的存储空间。</p></blockquote></li><li>全局变量及其作用域和生存期<blockquote><p>【定义】全局变量在函数外部定义的变量，全局变量也称为外部变量。<br>【作用域】全局变量是在函数外部任意位置上定义的变量，它的作用域是从变量定义位置开始，到整个源文件结束为止。<br>全局变量的生存期是整个程序的运行期间。</p></blockquote></li><li>静态全局变量<blockquote><p>静态全局变量是用 static 说明符说明的全局变量，静态全局变量只限于本编译单位使用，不能被其他编译单位所引用。</p></blockquote></li><li>外部函数与静态函数<br>在 C 语言中可以用 extern 和 static 关键字来说明函数。<br>（1）外部函数<br>外部函数是用extern 说明符说明函数返回值的函数，extern 说明可以省略，一般的函数都隐含说明为extern。<br>（2）静态函数<br>静态函数是用 static 说明符说明函数返回值的函数。<h3 id="第八章-指针"><a href="#第八章-指针" class="headerlink" title="第八章 指针"></a>第八章 指针</h3></li><li>int *p 中*p和p的差别：<br>p是当作地址来使用，*p可以当做变量；*作用是取地址p里的值<br>*p++ 和 (*p)++的之间的差别：改错题目中很重要<br>*p++是 地址会变化。P的值是变化的，(*p)++ 是数值会要变化。P的值（地址）不变                   </li><li><strong>数组名、函数名和常量名</strong><br> 数组名：表示第一个元素的地址。数组名不可以自加，它是地址常量名。（考了很多次）<br> 函数名：表示该函数的入口地址。<br> 字符串常量名：表示第一个字符的地址。</li><li>二维数组中的行指针<br>int a[1][2]；<br>其中a现在就是一个行指针，a+1跳一行数组元素。  搭配(*)p[2]指针<br>a[0]，a[1]现在就是一个列指针。a[0]+1 跳一个数组元素。搭配*p[2]指针数组使用<br>a[2]变成*(a+2)、a[2][3]变成*(a+2)[3]和*(*(a+2)+3)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语试题</title>
      <link href="/2020/05/23/EN_exem/"/>
      <url>/2020/05/23/EN_exem/</url>
      
        <content type="html"><![CDATA[<h3 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h3><ol><li><p>现在(do/does)<br>客观真理 习惯性 经常反复发生 动作 状态 与表时间/频率副词连用<br>说话正在进行的动作 预定近期要发生的动作(精确到某某时间)</p></li><li><p>将来(shall/will do)<br>将要发生 反复发生 习惯性 will常指无计划<br>[1]be going to do(口语 安排计划 迹象)/ be about to do(眼下发生 when连用)/ be to do(安排好将发生)</p></li><li><p>过去(did)<br>过去特定某时间发生 经常发生 习惯 实际上是刚刚发生 (我刚知道，我刚忘了)<br>It is high/about time that接 一般过去</p></li><li><p>现在进行(is/am/are doing)<br>此刻进行 一直发生但说话时不一定发生 表达强烈情绪 见[1]替换位移词现在进行表将来</p></li><li><p>过去进行(was/were doing)<br>过去某时刻(需上下文 状语表示) 进行动作 过去<strong>来看将要</strong>发生<br>过去进行+when表正在…突然… 接长动作用过去进行 短一般过去 while只能接长</p></li><li><p>过去将来(should/would do)<br>过去某时刻<strong>说将要</strong>进行的动作 用于主句谓(过去)的宾从中<br>was/were going to do————was/were about to do————was/were to do同表过去某时<strong>预计</strong>做某事<br>would do 过去的某种习惯行为</p></li><li><p>现在完成(has/have done)<br>过去动作对现在影响(<strong>言外之意</strong>) 开始于过去至今且可能继续 过去发生一或多次且成为经验<br>to 地点时 有been表去过回来了，无been去了未回<br>与9区别 强调<strong>结果</strong> 无持续时间状语下<strong>可表延续</strong></p></li><li><p>过去完成(had done)<br>过去(be before或时间状语表示)完成的动作 两个过去动作<strong>先</strong>发生的过去完成 但紧接着发生且含before after时用一般过去<br>过去<strong>未完成的</strong>打算愿望</p></li><li><p>现在完成进行(has/have been done)<br>开始于过去至今且可能继续 直到说话为止反复发生<br>与7区别 强调<strong>持续</strong> 无持续时间状语下<strong>表结束</strong> 不适用感官 存在 从属 思维词，只能用7</p></li><li><p>过去完成进行(had been done)<br>过去某时间前一直进行的动作</p><h3 id="语态"><a href="#语态" class="headerlink" title="语态"></a>语态</h3></li><li><p>不知道或无必要动作发出者 用被动语态 不用by短语</p></li><li><p>强调动作承受者</p></li><li><p>为语言圆滑不说出动作执行者</p></li><li><p>用it作被动句的形式主语，谓语动词改成be done结构</p><h3 id="非谓语"><a href="#非谓语" class="headerlink" title="非谓语"></a>非谓语</h3><h4 id="不定式"><a href="#不定式" class="headerlink" title="不定式"></a>不定式</h4></li><li><p>一般 to do/ to be done 被动态表一个被动的动作<strong>将</strong>要发生</p></li><li><p>完成 to have done/ to have been done (主/被)发生在谓动之前 表情态 观点 推断谓动后不接<br>过去打算做却没实现 与表打算 计划的过去时搭配 与表愿望的现在时搭配</p></li><li><p>进行 to be doing 谓动发生<strong>时</strong>不定动正在进行</p></li><li><p>完成进行 to have been doing 谓动发生<strong>前</strong>不定动一直持续进行</p></li><li><p>常用结构<br>It (be) adj(for sb) to do/<br>V + (疑问词) + to do/<br>V it + 宾补 + to do/<br>in order (not) to do/<br>so as (not) to do/<br>(only) to do/<br>too… to…/<br>… enough to do </p></li><li><p>to的省略<br>and or but等词连接时<br>had better/ would rather/ would sooner/ would just as soon/ might (just) as well/ cannot but/ cannot help but后接原型</p><h4 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h4></li><li><p>一般 doing/ being done </p></li><li><p>完成 having done/ having been done (主/被)发生在谓动之前 与现在完成have done区分</p></li><li><p>demand/ deserve/ need/ require/ want后主动可表被动</p></li><li><p>结构<br>It is no good/ no use doing sth 干某事没用<br>There is no point/ use/ good (in) doing sth 干某事没必要/没意义</p><h4 id="现在-过去分词"><a href="#现在-过去分词" class="headerlink" title="现在/过去分词"></a>现在/过去分词</h4></li><li><p>一般 doing/ done </p></li><li><p>进行 doing/ being done</p></li><li><p>完成 having done/ having been done</p></li><li><p>结构<br>generally speaking/ strictly speaking/ judging from/by<br>现在分词 + (that) 从句/ seeing that…/ considering that…/ supposing that…</p><h3 id="主谓一致"><a href="#主谓一致" class="headerlink" title="主谓一致"></a>主谓一致</h3></li><li><p>and连接两人或事，谓动用复数(is-are has-have)，若表同一人用单数，且后无冠词</p></li><li><p>anyone/ anything/ no one/ nothing/ everyone/ someone/ something/ each/ either/ the order主语，用单</p></li><li><p>表时间 距离 价格 度量衡等词作主语 用单</p></li><li><p>不定式 动名词 主从 用单</p></li><li><p>主语后接跟随类词with/ togeher with/ along with/ like等，依然主语决定</p></li><li><p>表示一个整体family/ class等 用单 若表示各个成员 用复</p></li><li><p>分数 百分数 数量 + of + n. 由后名词决定(a number of 复 the number of 单)</p></li><li><p>or/ either or/ neither or/ whether…or/ not only…but also/ there/ here be句型，就近原则</p></li><li><p>定从that/ who/ which引导，先行词决定</p></li><li><p>more than one + 单/ many a + 单，用单</p><h3 id="名从"><a href="#名从" class="headerlink" title="名从"></a>名从</h3></li><li><p>判断类型<br>陈述-that(作宾可省)<br>一般疑问-whether/ if(是否含义，不能省)<br>特殊疑问-(when/ where/ why/ how<strong>副作状</strong>)(who/ whom/ what(前三作<strong>主宾表</strong>)/ which/ whose(作<strong>定</strong>)代词)(不能省)</p></li></ol><p><strong>倒装的引导后要转为陈述</strong></p><ol start="2"><li>结构<br>It 作形式主语 用that<br>if只引宾从，whether都可，但在<strong>句首</strong>和<strong>介词后宾从</strong>和<strong>or not</strong>时用whether<br>what可表“什么样的、所…的事情、什么的人、什么数量/数目/地方/时间，whatever更加强调<br>That is接because 引导<h3 id="定从"><a href="#定从" class="headerlink" title="定从"></a>定从</h3></li><li>限制定从，作句子成分，that/ why引导</li><li>非限定从，不一定作， which/ as引导<h3 id="谓语及非谓语"><a href="#谓语及非谓语" class="headerlink" title="谓语及非谓语"></a>谓语及非谓语</h3></li><li>He went from door to door, <strong>__</strong> waste papers and magazines.</li></ol><p><strong>A. gathering</strong>    B. gathered     C.gather       D.being gathered<br>主语主动收集，且done只指一般被动，being done指进行被动，C为谓语，故选A</p><ol start="2"><li><p>It’s an excellent job offer. Don’t let such a good opportunity _____ through your fingers.<br>A.slipped       B.to slip       <strong>C.slip</strong>      D.slipping<br>分析句子成分：别让如此好的机会从你手中溜走，仅缺谓语，故选C</p></li><li><p>If you have difficulty ____ your bill, please tell me as soon as possible.<br>A.pay   B.paid  C.to pay    <strong>D.paying</strong></p></li></ol><h3 id="时态-1"><a href="#时态-1" class="headerlink" title="时态"></a>时态</h3><ol><li><p>I don’t feel very well, Jack. I’m afraid you _____ your cold to me.<br>A.transmit      B.had transmitted       <strong>C.have transmitted</strong>      D.would transmit<br>恐怕你已经把感冒传染给我了，现在完成时have done，故选C</p></li><li><p>I’m afraid I won’t be available then. I _____ a friend off at 3:00 the afternoon.<br>A.see      B.am seeing      C.will see      <strong>D.will be seeing</strong><br>将时间精确至上下午甚至时分时用将来进行时will be doing，故选D</p></li><li><p>We won’t get married until we _____ enough money.<br>A.will save     B.save      C.saved     D.have saved</p></li></ol><h3 id="情态动词、引导词、定冠词等"><a href="#情态动词、引导词、定冠词等" class="headerlink" title="情态动词、引导词、定冠词等"></a>情态动词、引导词、定冠词等</h3><ol><li><p>The instructor, as well as his students, _____ to attend the lecture.<br>A.are agreed        B.was agreed        C.have agreed       <strong>D.has agreed</strong><br>修饰主语his，只有has修饰三单，其他均不符合，have修饰一二人称(I,we,you)和三人称复数(they)</p></li><li><p>The hall in our school is ___ to hold 500 people.</p></li></ol><p><strong>A.big enough</strong>    B.enough big    C.very small    D.very big<br>enough作副词时一定放在被修饰词后，故选A</p><ol start="3"><li>The engineer suggested that we _____ out productivity through technical innovation.</li></ol><p><strong>A.raise</strong>     B.be raised     C.to be raised      D.to raised<br>形如suggested表建议、请求、要求等时，后接should do，should可省略，故选A</p><h3 id="虚拟语气、主将从现等"><a href="#虚拟语气、主将从现等" class="headerlink" title="虚拟语气、主将从现等"></a>虚拟语气、主将从现等</h3><ol><li>but for the traffic jam, I _____ late for the conference.</li></ol><p><strong>A.wouldn’t have been</strong>    B.shouldn’t be  C.would be      D.hadn’t been<br>使用but for，句子必用虚拟语气，与过去相反，主句用would have done，故选A</p><ol start="2"><li>Each time he _____ from me, he will write to me as soon as possible.<br>A.will hear     B.had heard     <strong>C.hears</strong>     D.has heard<br>主句将来时且考时态时用主将从现，故选C</li></ol><h3 id="倒装"><a href="#倒装" class="headerlink" title="倒装"></a>倒装</h3><p>No sooner/</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>14年3/9月二级C语言</title>
      <link href="/2020/05/19/14-3C_Exem/"/>
      <url>/2020/05/19/14-3C_Exem/</url>
      
        <content type="html"><![CDATA[<h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><h3 id="一、选择题-每题1分-共40分"><a href="#一、选择题-每题1分-共40分" class="headerlink" title="一、选择题(每题1分,共40分)"></a>一、选择题(每题1分,共40分)</h3><p>1．有以下程序：程序运行后的输出结果是<strong>21</strong></p><pre><code>#include&lt;stdio.h&gt; int main(){int a=5,b=1,t;t=(a&lt;&lt;2)|b;printf(&quot;%d\n&quot;,t);}</code></pre><p>计算5&lt;&lt;2，即101左移2位后为10100，然后和00001进行或运算等于10101，其十进制为21。 </p><h4 id="2．设函数中有整型变量n，为保证其在未赋值的情况下初值为0，应选择的存储类别是"><a href="#2．设函数中有整型变量n，为保证其在未赋值的情况下初值为0，应选择的存储类别是" class="headerlink" title="2．设函数中有整型变量n，为保证其在未赋值的情况下初值为0，应选择的存储类别是"></a>2．设函数中有整型变量n，为保证其在未赋值的情况下初值为0，应选择的存储类别是</h4><p>A．auto    B．register    <strong>C．static</strong>    D．auto或register<br>静态存储类型变量在未对其初始化时的默认初始化值是0，其他存储类型不能确定变量在未赋值情况的初值。 </p><p>3．若有以下定义： int x[10],*pt=x; 则对x数组元素的正确引用是<br>A．*&amp;x[10]    <strong>B．*(x+3)==a[3]</strong>    C．*(pt+10)    D．pt+3==&amp;a[3]<br>【解析】数组的下标是从0开始的，故使用x[10]就会溢出，所以AC两项错误;D项,pt+ 3指向地址，并未引用到元素;B项的表达正确，引用x[3]。</p><p>4．有以下程序：输出结果是<strong>2，3</strong></p><pre><code>#include &lt;stdio.h&gt; struct ord{int x,y;}dt[2]={&#39;{1,2},{3,4}&#39;}; &#x2F;&#x2F;其中分号为了避免与js冲突，源码中不存在，下同int main(){struct ord *p=dt; printf(&quot;%d&quot;,++(p-&gt;x)); printf(&quot;%d&quot;,++(p-&gt;y)); }</code></pre><p>dt是一个结构体数组，所以初始化的结果为dt[0]={1，2}，dt[1]={3，4}。*p=dt;，表示p指向dt[0]。++p-&gt;x 中，-&gt;的优先级大于++，所以表达式等价于++(p-&gt;x)，因为p-&gt;x为1，所以输出这个值为2，同理，第二个++p-&gt;y的值为2+1=3。 </p><p>5．以下函数按每行8个输出数组中的数据：</p><pre><code>void fun(int *w,int n){int i; for(i=0;i&lt;n;i++)printf(&quot;%d&quot;,w[i]);  __________________}</code></pre><p>下划线处应填入的语句是<br>A．if(i/8==0) printf(“\n”);   B．if(i/8==0) continue;<br><strong>C．if(i%8==0) printf(“\n”);</strong>   D．if(i%8==0) continue;<br>每行输出8个数组数据后输入一个换行，应该采取对8取余的方法，余数循环一次便换行一次，所以语句为if(i%8==0) printf(“\n”);。</p><p>6．有以下程序：输出结果是<strong>1028</strong></p><pre><code>#include &lt;stdio.h&gt; int b=2;int fun(int *k){b=*k+b;return(b);}main(){int a[10]={1,2,3,4,5,6,7,8},i;for(i=2;i&lt;4;i++){b=fun(&amp;a[i])+b;printf(&quot;%d&quot;,b);}printf(&quot;\n&quot;);}</code></pre><p>变量b是全局变量。for循环第一次i=2，a[i]=3，所以fun(&amp;a[i])=3+2=5，这时b为5，所以输出的b=fun(&amp;a[i])+b=5+5=10。for循环第二次，i=3,b=10，然后fun(&amp;a[i])，代入a[i]=4，这时fun(&amp;a[i])=10+4=14，所以输出的b=fun(&amp;a[i])+b=14+14=28。</p><p>7．有以下程序：字母a的ASCII码值为97，程序运行后的输出结果是<strong>d</strong></p><pre><code>#include &lt;stdio.h&gt;void fun(char *s){while(*s) {if(*s%2==0)printf(&quot;%c&quot;,*s);s++;} }main(){char a[]=(&quot;good&quot;);fun(a);printf(&quot;\n&quot;);}</code></pre><p>字符串”good”中g的ASCII码值为103，o为111，d为100。在函数中选择值为偶数的字母输出。只有d的ASCII码值为偶数，所以结果为d。</p><h4 id="8．有以下程序：若文本文件filea-txt中原有内容为：hello，则运行以上程序后，文件filea-txt中的内容为abc"><a href="#8．有以下程序：若文本文件filea-txt中原有内容为：hello，则运行以上程序后，文件filea-txt中的内容为abc" class="headerlink" title="8．有以下程序：若文本文件filea.txt中原有内容为：hello，则运行以上程序后，文件filea.txt中的内容为abc"></a>8．有以下程序：若文本文件filea.txt中原有内容为：hello，则运行以上程序后，文件filea.txt中的内容为<strong>abc</strong></h4><pre><code>#include &lt;stdio.h&gt;main(){FILE *f; f=fopen(&quot;filea.txt&quot;,&quot;w&quot;);fprintf(f,&quot;abc&quot;);fclose(f);}</code></pre><p>以只写模式打开文件;先清空再写入。</p><h4 id="10．有以下程序：程序运行后的输出结果是7-5"><a href="#10．有以下程序：程序运行后的输出结果是7-5" class="headerlink" title="10．有以下程序：程序运行后的输出结果是7.5"></a>10．有以下程序：程序运行后的输出结果是<strong>7.5</strong></h4><pre><code>#include &lt;stdio.h&gt; #define PT 3.5 #define S(x) PT*x*x &#x2F;&#x2F;PT*a+b*a+b=3.5*1+2*1+2 = 7.5main(){int a=1,b=2;printf(&quot;%4.1f\n&quot;,S(a+b));}</code></pre><p>S(a+b)=7.5。注意：宏只能简单替换，不能做任何修改。</p><p>12．设有宏定义：</p><p>#define IsDIV(k，n) ((k%n==1)?1∶0)<br>且变量m已正确定义并赋值,则宏调用：IsDIV(m，5)&amp;&amp;IsDIV(m，7)为真时所要表达的是<br>A．判断m是否能被5或者7整除    B．判断m是否能被5和7整除<br>C．判断m被5或者7整除是否余1    <strong>D．判断m被5和7整除是否都余1</strong></p><h4 id="15．有以下程序：输出结果是1-3"><a href="#15．有以下程序：输出结果是1-3" class="headerlink" title="15．有以下程序：输出结果是1,3"></a>15．有以下程序：输出结果是<strong>1,3</strong></h4><pre><code>#include &lt;stdio.h&gt; void fun(int *p,int *q)main(){int m=1,n=2,*r=&amp;m;f(r,&amp;n);printf(&quot;%d,%d&quot;,m,n);} void f(int *p,int *q){p=p+1;&#x2F;&#x2F;p=&amp;m+1*q=*q+1;&#x2F;&#x2F;n=n+1}</code></pre><p>执行语句 p=p+1;只改变指针p的地址，跟p内容无关，所以m值没有改变</p><p>17．设有定义：char s[81];int i=0;，以下不能将一行(不超过80个字符)带有空格的字符串正确读入的语句或语句组是<br>A．gets(s);<br>B．while((s[i++]=getchar())!=′\n′);s[i]=′\0′;<br><strong>C．scanf(“%s”,s);</strong><br>D．do{scanf(“%c”,&amp;s[i]);}while(s[i++]!=′\n′);s[i]=′\0′;<br>字符串的输入有两种方式：scanf()函数;gets()函数。s代表<strong>输入一个字符数组，遇到空格时会默认字符串输入结束</strong>。</p><p>18．若有定义语句：double x，y，*px，*py;执行了px=&x;py=&y;之后，正确的输入语句是<br>A．scanf(“%f%f”,x,y);    B．scanf(“%f%f”,&amp;x,&amp;y);<br><strong>C．scanf(“%lf%lf”,px,py);</strong>    D．scanf(“%1f%1f”,x,y);<br>输入函数scanf的标准格式是：scanf(格式控制，地址列表)。double型为%lf。</p><h4 id="19．以下选项中正确的语句组是"><a href="#19．以下选项中正确的语句组是" class="headerlink" title="19．以下选项中正确的语句组是"></a>19．以下选项中正确的语句组是</h4><p>A．char s[];s=”BOOK!”;    B．char *s;s={“BOOK!”};<br>C．char s[10];s=”BOOK!”;    <strong>D．char *s;s=”BOOK!”;</strong><br>AC两项错误，不能直接将一个字符串整体赋值给字符数组;B项错误，{“BOOK!”}表示一个字符串数组，对应char **的指针结构;D项正确，语句先定义一个字符串变量，然后将变量指向一个字符串常量。</p><h4 id="20．有以下程序：输出结果是3，5，3，5"><a href="#20．有以下程序：输出结果是3，5，3，5" class="headerlink" title="20．有以下程序：输出结果是3，5，3，5"></a>20．有以下程序：输出结果是<strong>3，5，3，5</strong></h4><pre><code>#include &lt;stdio.h&gt;void fun(int *a,int *b){int *c;c=a;a=b;b=c;}&#x2F;&#x2F;*c=*a;*a=*b;*b=*c;实参的值会改变main() {int x=3,y=5,*p=&amp;x,*q=&amp;y;fun(p,q);printf(&quot;%d,%d&quot;,*p,*q);fun(&amp;x,&amp;y);printf(&quot;%d,%d\n&quot;,*p,*q);}</code></pre><p>C语言中，函数参数传递的功能是“单向传值”，即形参和实参是两个没有关系的变量。<strong>函数的形参为指针变量，函数内部交换的是地址值，不是地址值所指向的值，所以不会改变实参的值。</strong></p><p>21．以下选项中，能用作数据常量的是<br>A．o115    B．0118    C．1-5e1.5    <strong>D．115L</strong><br>C语言中实型常量有两种表示：小数形式和指数形式。在指数形式中，字母e(或E)之前必须要有数字，且e或E后面的指数必须为整数，故C项错误;八进制整数常量以数字0开始，故A项错误。在八进制数中的有效数字为0～7，故B项错误;L是长整型数据标识，115L为长整型常数即long int，D项正确。 </p><p>24．以下是if语句的基本形式： if(表达式)语句 其中“表达式”<br>A．必须是逻辑表达式    B．必须是关系表达式<br>C．必须是逻辑表达式或关系表达式    <strong>D．可以是任意合法的表达式</strong><br>if中的表达式一般是关系表达式或逻辑表达式，用于描述选择结构的条件，但也可以是其他类型表达式，在其值非零时为真，所以任意合法的表达式都可以做if语句的判断条件。 </p><p>28．以下程序段中的变量已正确定义：</p><pre><code>for(i=0;i&lt;4;i++,i++)for(k=1;k&lt;3;k++);printf(&quot;*&quot;); </code></pre><p>程序段的输出结果是(D)。<br>A．****** B．**** C．** D．*<br>第二个for循环以“;”结束，整个双重循环将被视为空语句。执行下一个顺序语句，输出一个*。</p><h4 id="30．若函数中有定义语句：int-k-，则"><a href="#30．若函数中有定义语句：int-k-，则" class="headerlink" title="30．若函数中有定义语句：int k;，则"></a>30．若函数中有定义语句：int k;，则</h4><p>A．系统将自动给k赋初值0    <strong>B．这时k中的值无定义</strong><br>C．系统将自动给k赋初值-1    D．这时k中无任何值<br>定义一个整型变量是动态定义，所以k中的值无定义。</p><p>31．设变量已正确定义，以下<strong>不能</strong>统计出一行中输入字符个数(不包含回车符)的程序段是<br>A．n=0;while((ch=getchar())!=”\n”)n++;<br>B．n=0;while(getchar()!=”\n”)n++;<br>C．for(n=0;getchar()!=”\n”;n++);<br><strong>D．n=0;for(ch=getchar()!=”\n”;n++);</strong><br>D项中for循环表达式格式错误，应在ch前添加“;”。</p><h4 id="33．有以下程序：输出结果是1，3，3"><a href="#33．有以下程序：输出结果是1，3，3" class="headerlink" title="33．有以下程序：输出结果是1，3，3"></a>33．有以下程序：输出结果是<strong>1，3，3</strong></h4><pre><code>#include &lt;stdio.h&gt;main(){int a=1,b=2,c=3,d=0;if(a==1&amp;&amp;b++==2)if(b!=2||c--!=3)printf(&quot;%d,%d,%d\n&quot;,a,b,c);elseprintf(&quot;%d,%d,%d\n&quot;,a,b,c);elseprintf(&quot;%d,%d,%d\n&quot;,a,b,c);}</code></pre><p>第一个if语句的判断条件为真，进入if语句。b经过b++运算后值为3，<strong>所以第二个if语句为真(逻辑或运算时，一个为真，整体都为真，并且第一个为真时第二个不会被执行运算</strong>，这时后面的运算都忽略,c仍为3。</p><h4 id="34．有以下程序：字母A的ASCII码值为65，程序运行后的结果是567"><a href="#34．有以下程序：字母A的ASCII码值为65，程序运行后的结果是567" class="headerlink" title="34．有以下程序：字母A的ASCII码值为65，程序运行后的结果是567"></a>34．有以下程序：字母A的ASCII码值为65，程序运行后的结果是<strong>567</strong></h4><pre><code>#include &lt;stdio.h&gt; main(){char *s={&quot;ABC&quot;}; do{printf(&quot;%d&quot;,*s%10);s++;}while(*s);}</code></pre><p>指针指向串结束标志’\0’，’\0’对应ASCII值为0，即*s等于0，退出循环。因此，输出结果为567。</p><h4 id="36．有以下程序：输出结果是aegi"><a href="#36．有以下程序：输出结果是aegi" class="headerlink" title="36．有以下程序：输出结果是aegi"></a>36．有以下程序：输出结果是<strong>aegi</strong></h4><pre><code>#include &lt;stdio.h&gt; main(){char *a[]={&quot;abcd&quot;,&quot;ef&quot;,&quot;gh&quot;,&quot;ijk&quot;};int i; for(i=0;i&lt;4;i++)printf(&quot;%c&quot;,*a[i]);}</code></pre><p><strong>输出语句要求输出的格式是％c，为一个字符</strong>，所以每个元素输出第一个字符，即aegi。</p><p>38．程序段：int x =12;double y=3.141593;printf(“%d%8.6f”,x,y);输出结果是<br><strong>A．123.141593</strong>    B．123.141493    C．12，3.141593    D．123.1415930<br>输出的x与y间没有空格或逗号，”％8.6f”代表输出字符型数据y的格式应为小数点后保留6位。</p><p>39．设有定义：int x=2;，以下表达式中，值<strong>不</strong>为6的是(D)。<br>A．x*=x+1    B．x++，2*x    C．x*=(1+x)    <strong>D．2*x，x+=2</strong><br>A项，先执行x+1，赋值符号右侧为3，然后再x*=3，所以x=2*3=6;B项，x++得3然后2*x得6;C项与A项原理一致。D项，2*x虽然结果为4，但没有赋值，此时x的值仍为2，所以最终为4。</p><h3 id="二、程序填空题-共18分"><a href="#二、程序填空题-共18分" class="headerlink" title="二、程序填空题(共18分)"></a>二、程序填空题(共18分)</h3><p>请补充fun函数，该函数的功能是：按‘0’到‘9’统计一个字符串中的奇数数字字符各自出现的次数，结果保存在数组num中。注意：不能使用字符串库函数。<br>例如，输入“x=1123.456+0.909*bc”，结果为：1=2，3=1，5=1，7=0，9=2。<br>注意： 请勿改动主函数main和其他函数中的任何内容，仅在函数fun的横线上填入所编写的若干表达式或语句。<br>【试题源程序】</p><pre><code>#include &lt;conio.h&gt; #include &lt;stdio.h&gt; #define N 20 fun(char *tt,int num[]) {int i,j;int bb[10];char *p=tt;for(i=0;i&lt;10;i++){num[i]=0;bb[i]=0;}while((1)_____){if(*p&gt;=′0′&amp;&amp;*p&lt;=′9′)(2)_____p++;}for(i=1,j=0;i&lt;10;i=i+2,j++)(3)_____} main(){char str[N];int num[10],k;printf(&quot;\nPlease enter a string：&quot;); gets(str);printf(&quot;\n******* The original string *******\n&quot;);puts(str);fun(str,num);printf(&quot;\n******* The number of letter *******\n&quot;);for(k=0;k&lt;5;k++){printf(&quot;\n&quot;);printf(&quot;%d=%d&quot;,2*k+1,num[k]);} printf(&quot;\n&quot;);return;}</code></pre><p>答：(1)*p    (2)bb[*p-′0′]++    (3)num[j]=bb[i]<br>①先把数组num的各元素清0;②遍历字符串，利用数字字符在ASCII码中的连续规律，使用(数字字符 -′0′)作数组的下标，个数作数组元素的值。<br>填空(1)：此处用临时指针p遍历字符串str，所以应填*p。<br>填空(2)：因为10个数字字符在ASCII码中是连续的，将它们和字符′0′作差刚好用来作为数组的下标。所以此处应该填bb[*p-′0′]++。<br>填空(3)：在bb数组中是将所有数字出现的数字都统计了出来，所以在赋值给num数组时要将奇数提出来，故for条件中i+2。</p><h3 id="三、程序修改题-共18分"><a href="#三、程序修改题-共18分" class="headerlink" title="三、程序修改题(共18分)"></a>三、程序修改题(共18分)</h3><p>下列给定程序中，函数fun()的功能是：用选择法对数组中的n个元素按从小到大的顺序进行排序。<br>请改正程序中的错误，使它能得到正确结果。<br>注意：不要改动main函数，不得增行或删行，也不得更改程序的结构。<br>【试题源程序】</p><pre><code>#include &lt;stdio.h&gt;#define N 20void fun(int a[],int n){int i,j,t,p;for(j=0;j&lt;n-1;j++){p=j&#x2F;&#x2F;errorfor(i=j;i&lt;n;i++)if(a[i]&lt;a[p]) p=j;&#x2F;&#x2F;errort=a[p];a[p]=a[j];a[j]=t;}}main(){int a[N]={9,6,8,3,-1},i,m=5;printf(&quot;排序前的数据：&quot;);for(i=0;i&lt;m;i++)printf(&quot;%d&quot;,a[i]);printf(&quot;\n&quot;);fun(a,m);printf(&quot;排序后的数据：&quot;);for(i=0;i&lt;m;i++)printf(&quot;%d&quot;,a[i]);printf(&quot;\n&quot;);}</code></pre><p>答：本题采用了选择排序法。错误(1)：p=j后面应加分号。错误(2)：根据选择排序法的逻辑，此处应将i赋给p。 </p><h3 id="四、程序设计题-共24分"><a href="#四、程序设计题-共24分" class="headerlink" title="四、程序设计题(共24分)"></a>四、程序设计题(共24分)</h3><p>学生的记录由学号和成绩组成，N名学生的数据已在主函数中放入结构体数组s中，请编写函数fun，它的功能是：按分数的高低排列学生的记录，高分在前。注意：请勿改动主函数main和其他函数中的任何内容，仅在函数fun的花括号中填入所编写的若干语句。<br>【试题源程序】</p><pre><code>#include &lt;stdio.h&gt;#define N 16typedef struct{char num[10];int s;}STREC;int fun(STREC a[]){}main(){STREC s[N]={&#39;{&quot;GA005&quot;,85},{&quot;GA003&quot;,76},{&quot;GA002&quot;,69},{&quot;GA004&quot;,85},{&quot;GA001&quot;,91},{&quot;GA007&quot;,72},{&quot;GA008&quot;,64},{&quot;GA006&quot;,87},{&quot;GA015&quot;,85},{&quot;GA013&quot;,91},{&quot;GA012&quot;,64},{&quot;GA014&quot;,91},{&quot;GA011&quot;,66},{&quot;GA017&quot;,64},{&quot;GA018&quot;,64},{&quot;GA016&quot;,72}&#39;}; int i;FILE *out;fun(s);printf(&quot;The data after sorted：\n&quot;);for(i=0;i&lt;N;i++){if((i)%4==0)printf(&quot;\n&quot;);printf(&quot;%s %4d&quot;,s[i].num,s[i].s);}printf(&quot;\n&quot;);}答： int fun(STREC a[]){STREC tmp;int i,j;for(i=0;i&lt;N;i++) for(j=i+1;j&lt;N;j++) if(a[i].s&lt;a[j].s){tmp=a[i];a[i]=a[j];a[j]=tmp;}     return 1;}</code></pre><p>采用冒泡排序的方法，对结构体中按照成绩s进行降序排列，将其结果仍存入当前结构体中。</p><h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><h3 id="一、选择题-每题1分，共40分"><a href="#一、选择题-每题1分，共40分" class="headerlink" title="一、选择题(每题1分，共40分)"></a>一、选择题(每题1分，共40分)</h3><p>1．下列关于C语言文件的叙述中正确的是<br>A．文件由一系列数据依次排列组成，只能构成二进制文件    B．文件由结构序列组成，可以构成二进制文件或本文件<br><strong>C．文件由数据序列组成，可以构成二进制文件或文本文件</strong>    D．文件由字符序列组成，其类型只能是文本文件<br>C语言将文件看作是个字符(字节)的序列，即由一个一个字符(字节)数据顺序组成。根据数据的组成形式，可将文件分为两种：①ASCII文件，又称文本(text)文件，它的每个字节可放一个ASCII码，代表一个字符；②二进制文件，是把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放。</p><p>10．下面结构体的定义语句中，错误的是<br>A．struct ord{int x;int y;int z;};struct ord a;<br><strong>B．struct ord{int x;int y;int z;}struct ord a;</strong><br>C．struct ord{int x;int y;int z;}a;<br>D．struct {int x;int y;int z;}a;<br>结构体变量的定义有3种方法：1.定义结构体类型的同时定义结构体变量；2.使用无名结构体类型定义结构体变量；3.先定义结构体类型，后定义结构体变量。</p><p>12．以下函数findmax拟实现在数组中查找最大值并作为函数值返回，但程序中有错导致不能实现预定功能。</p><pre><code>#define MIN -2147483647int findmax(int x[],int n){    int i,max;    for(i=0;i&lt;n;i++){        max=MIN;        if(max &lt; x[i])            max=x[i];    }    return max;}</code></pre><p>造成错误的原因是<br>A．定义语句int i，max；中,max未赋初值<br>B．赋值语句max＝MIN；中，不应给max赋MIN值<br>C．语句if(max&lt;x[i])max＝x[i]；中,判断条件设置错误<br><strong>D．赋值语句max＝MIN；放错了位置</strong></p><h4 id="13．设有定义：char-c；以下选项中能够使字符型指针c正确指向一个字符串的是"><a href="#13．设有定义：char-c；以下选项中能够使字符型指针c正确指向一个字符串的是" class="headerlink" title="13．设有定义：char *c；以下选项中能够使字符型指针c正确指向一个字符串的是"></a>13．设有定义：char *c；以下选项中能够使字符型指针c正确指向一个字符串的是</h4><p><strong>A．char str[]=”string”;c=str;</strong>    B．scanf(“%s”,c);<br>C．c=getchar();                  D．*c=”string”;<br>B项scanf( )函数是将c定义为一个字符数组的数组名，C是将c定义为一个字符型变量，D项是在指针定义时为它赋值，是不合法的，所以BCD三项都不正确。A项定义字符数组str，再将字符数组str的首地址赋给字符型指针c，正确。</p><h4 id="15．下列函数的功能是"><a href="#15．下列函数的功能是" class="headerlink" title="15．下列函数的功能是"></a>15．下列函数的功能是</h4><pre><code>fun(char *a,char *b){    while((*b=*a)!=′\0′){        a++;        b++;    }}</code></pre><p><strong>A．将a所指字符串赋给b所指空间</strong><br>B．使指针b指向a所指字符串<br>C．将a所指字符串和b所指字符串进行比较<br>D．检查a和b所指字符串中是否有′\0′<br>函数fun中a和b是两个字符型指针，在while语句的表达式中将指针a所指向的字符赋给指针b所指向的内存单元，再判断该字符是不是字符串中的结尾符，若不是，则字符指针a和b分别自增，再执行循环语句，直至b所指向的字符为字符串中的空字符。</p><p>17．有以下程序：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;main(){    char str[][20]={&quot;One * World&quot;,&quot;One*Dream!&quot;},*p=str[1];    printf(&quot;%d,&quot;,strlen(p));    printf(&quot;%s\n&quot;,p);}</code></pre><p>程序运行后的输出结果是<br>A．9，One*World    B．9，One*Dream！    <strong>C．10，One*Dream!</strong>    D．10，One*World</p><p>20．有以下程序：</p><pre><code>#include &lt;stdio.h&gt;main(){    int c=0,k;    for(k=1;k&lt;3;k++)        switch(k){            default：c+=k;            case 2：c++;break;            case 4：c+=2;break;        }    printf(&quot;%d\n&quot;,c);}</code></pre><p>程序运行后的输出结果是<strong>3</strong><br>default后没有break则继续执行下一项。</p><h4 id="22．下面是有关C语言字符数组的描述，其中错误的是-D-。"><a href="#22．下面是有关C语言字符数组的描述，其中错误的是-D-。" class="headerlink" title="22．下面是有关C语言字符数组的描述，其中错误的是(D)。"></a>22．下面是有关C语言字符数组的描述，其中错误的是(D)。</h4><p>A．不可以用赋值语句给字符数组名赋字符串<br>B．可以用输入语句把字符串整体输入给字符数组<br>C．字符数组中的内容不一定是字符串<br><strong>D．字符数组只能存放字符串</strong><br>C语言中，字符数组可以用来存放单个的字符或者字符串。</p><h4 id="23．若有定义语句：int-a-4-10-，-p，-q-4-；且0≤i-lt-4，则错误的赋值是"><a href="#23．若有定义语句：int-a-4-10-，-p，-q-4-；且0≤i-lt-4，则错误的赋值是" class="headerlink" title="23．若有定义语句：int a[4][10]，*p，*q[4]；且0≤i&lt;4，则错误的赋值是"></a>23．若有定义语句：int a[4][10]，*p，*q[4]；且0≤i&lt;4，则错误的赋值是</h4><p><strong>A．p＝a</strong>    B．q[i]＝a[i]    C．p＝a[i]    D．p＝&amp;a[2][1]<br>二维数组名是指向指针的指针，所以a和q都为指向指针的指针，而p为指向int类型的指针，p和a不同类型，故p=a赋值语句错误。其余选项可以正确赋值，其中D项是用取地址符&amp;返回整数的地址，然后赋值给p。</p><p>24．以下程序段中，与语句：k＝a&gt;b？(b&gt;c？1∶0)∶0；功能相同的是<br><strong>A．if((a&gt;b)&amp;&amp;(b&gt;c))k=1; else k=0;</strong><br>B．if((a&gt;b)||(b&gt;c)),k=1; else k=0;<br>C．if(a&lt;=b)k=0; else if(b&lt;=c)k=1;<br>D．if(a&gt;b)k=1; else if(b&gt;c)k=1; else k=0;</p><h4 id="35．设有以下函数："><a href="#35．设有以下函数：" class="headerlink" title="35．设有以下函数："></a>35．设有以下函数：</h4><p>void fun(int n, char *s){……} 则下面对函数指针的定义和赋值均是正确的是<br><strong>A．void (*pf)();pf=fun;</strong>    B．void *pf();pf=fun;<br>C．void *pf();*pf=fun;    D．void (*pf)(int,char);pf=&fun;<br>函数指针的一般定义形式为：数据类型(*指针变量名)( )。D项，void(*pf)(int，char)带有两个数据类型，不符合函数指针定义。</p><h4 id="39．设有定义："><a href="#39．设有定义：" class="headerlink" title="39．设有定义："></a>39．设有定义：</h4><p>int a＝1，b＝2，c＝3；，以下语句中执行效果与其他三个不同的是<br>A．if(a＞b)c＝a,a＝b,b＝c;    B．if(a＞b){c＝a,a＝b,b＝c;}<br><strong>C．if(a＞b)c＝a;a＝b;b＝c;</strong>    D．if(a＞b){c＝a;a＝b;b＝c;}<br>if语句仅作用于紧随其后的那条语句或者是复合语句的内容，A项，执行三条语句组成的复合语句；BD两项执行大括号中的三条语句；而C项只执行c=a。</p><h3 id="二、程序填空题-共18分-1"><a href="#二、程序填空题-共18分-1" class="headerlink" title="二、程序填空题(共18分)"></a>二、程序填空题(共18分)</h3><p>N个有序整数数列已放在一维数组中，给定下列程序中，函数fun()的功能是：利用折半查找法查找整数m在数组中的位置。若找到，则返回其下标值；反之，则返回“Not be found！”。 折半查找法的基本算法是：每次查找前先确定数组中待确定的范围：low和high(low&lt;high),然后把m与中间位置(mid)中元素的值进行比较。如果m的值大于中间位置元素中的值，则下一次的查找范围放在中间位置之后的元素中；反之，下次查找范围落在中间位置之前的元素中。直到low&gt;high ，查找结束。注意：请勿改动主函数main和其他函数中的任何内容，仅在函数fun的横线上填入所编写的若干表达式或语句。<br>【试题源程序】</p><pre><code>#include &lt;stdio.h&gt;#define N 10int fun(int a[],int m){    int low=0,high=N-1,mid;    while(low&lt;=high){        mid=_______;        if(m&lt;a[mid])            high=________;        else if(m&gt;a[mid])            low=mid+1;        else            return(mid);    }    _______ (-1);} main(){    int i,a[N]={-3,4,7,9,13,24,67,89,100,180},k,m;    printf(&quot;a数组中的数据如下：&quot;);    for(i=0;i&lt;N;i++)        printf(&quot;%d&quot;,a[i]);    printf(&quot;Enter m：&quot;);    scanf(&quot;%d&quot;,&amp;m);    k=fun(a,m);    if(k&gt;=0)        printf(&quot;m=%d,index=%d\n&quot;,m,k);    else        printf(&quot;Not be found\n&quot;);}</code></pre><p>答：【1】(low+high)/2 【2】mid-1 【3】return</p><h3 id="三、程序修改题-共18分-1"><a href="#三、程序修改题-共18分-1" class="headerlink" title="三、程序修改题(共18分)"></a>三、程序修改题(共18分)</h3><p>下列给定程序中，函数fun()的功能是计算并输出high以内的素数之和。high由主函数传给fun( )函数。例如：若high的值为100，则函数的解为1060。请改正程序中的错误，使它能得到正确结果。 注意： 不要改动main函数，不得增行或删行，也不得更改程序的结构。<br>【试题源程序】</p><pre><code>#include &lt;conio.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;int fun(int high){    int sum=0,n=0,j,yes;    while(high&gt;=2){        yes=1;        for(j=2;j&lt;=high&#x2F;2;j++)            if high%j==0{   &#x2F;&#x2F;error                yes=0;                break;            }        if(yes==0){         &#x2F;&#x2F;error            sum+=high;            n++;        }        high--;    }    return sum;}main(){    printf(&quot;%d\n&quot;,fun(100));}</code></pre><p>答：错误(1)：if语句的两侧要加括号;错误(2)：yes为1时，说明被判断的数是素数，要累加到sum。</p><h3 id="四、程序设计题-共24分-1"><a href="#四、程序设计题-共24分-1" class="headerlink" title="四、程序设计题(共24分)"></a>四、程序设计题(共24分)</h3><p>请编写函数fun，其功能是：计算并输出3到n之间(含3和n)所有素数的平方根之和。例如，在主函数中从键盘给n输入100后，输出为：sum＝148.874270。 注意： 要求n的值大于2但不大于100。部分源程序给出如下。 请勿改动主函数main和其他函数中的任何内容，仅在函数fun的花括号中填入所编写的若干语句。<br>【试题源程序】</p><pre><code>#include &lt;math.h&gt;#include &lt;stdio.h&gt;double fun(int n){} main(){    int n;    double sum;    printf(&quot;\n\nInput n：&quot;);    scanf(&quot;%d&quot;,&amp;n);    sum=fun(n);    printf(&quot;\n\nsum=%f\n\n&quot;,sum);}答： double fun(int n){    int i,j;    double s=0;    if(n&gt;2&amp;&amp;n&lt;=100){        for(i=3;i&lt;=n;i++){            for(j=2;j&lt;i;j++)                if(i%j==0)                    break;            if(j==i)                s=s+sqrt(i);        }        return s;    }    return (-1);}</code></pre><p>【解析】程序是计算并输出3到n之间(含3和n)所有素数的平方根之和，所以fun应当具有判断一个数是否为素数的功能，可以利用sqrt()函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构考纲识记理解内容（下）</title>
      <link href="/2020/05/01/Datasource2/"/>
      <url>/2020/05/01/Datasource2/</url>
      
        <content type="html"><![CDATA[<h3 id="第八章-树和二叉树"><a href="#第八章-树和二叉树" class="headerlink" title="第八章 树和二叉树"></a>第八章 树和二叉树</h3><h4 id="树的定义、相关术语、表示方法和存储结构。（识记）"><a href="#树的定义、相关术语、表示方法和存储结构。（识记）" class="headerlink" title="树的定义、相关术语、表示方法和存储结构。（识记）"></a>树的定义、相关术语、表示方法和存储结构。（识记）</h4><p><strong>树</strong>是由n个结点构成的集合，n = 0的树称为空树。n = 1的树只有一个节点。<br>常用术语：<br>    结点：包括一个数据元素和若干个指向其子树的分支。<br>    结点的度：结点所<strong>拥有的子树的个数</strong>称为该结点的度。<br>    叶结点：度为0的结点，即<strong>终端结点</strong>。<br>    分支结点：度不为0的结点，即<strong>非终端结点</strong>。<br>    孩子结点：树中一个结点的子树的根节点称为这个结点的孩子结点。<br>    双亲结点：字面。<br>    兄弟结点：字面。<br>    树的度：树中<strong>所有结点的度的最大值</strong>称为该树的度。<br>    结点的层次：根节点的层次规定为0，其他结点的层次等于双亲层次+1。<br>    树的深度：树中<strong>所有结点的层次的最大值</strong>称为该树的深度。<br>    无序树：树中任意结点的各孩子结点之间的<strong>次序构成无关紧要</strong>的树称为无序树。通常树指无序树。<br>    有序树：树中任意结点的各孩子结点有<strong>严格排列次序</strong>的树为有序树。<br>    森林：m棵树的集合称为森林，一棵树也可称为森林。</p><p>存储结构<br>    双亲表示法：用指针表示每个结点的<strong>双亲结点</strong>。<br>    孩子表示法：表示每个结点的<strong>孩子结点</strong>。<br>    双亲孩子表示法：既表示每个结点的<strong>双亲结点</strong>，也表示<strong>孩子结点</strong>。<br>    孩子兄弟表示法：既表示每个结点的<strong>第一个孩子结点</strong>，也表示<strong>下一个兄弟结点</strong>。（常用）</p><h4 id="二叉树-完全二叉树、满二叉树-的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）"><a href="#二叉树-完全二叉树、满二叉树-的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）" class="headerlink" title="二叉树(完全二叉树、满二叉树)的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）"></a>二叉树(完全二叉树、满二叉树)的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）</h4><p><strong>二叉树</strong>是由n个有限结点构成的集合。n = 0的树称为空二叉树，n = 1的树只有一个根结点。<strong>二叉树不是有序树</strong>。<br><strong>满二叉树</strong>：在一棵二叉树中，所有的结点都存在左右子树，并且所有叶结点都在同一层，这样的树称为满二叉树。<br><strong>完全二叉树</strong>：如果一棵n个结点的二叉树结构与满二叉树的前n个结点结构相同，就称为完全二叉树。具有n个结点的二叉树深度是log2n。<br><strong>满二叉树一定是完全二叉树。</strong></p><p>二叉树的<strong>性质</strong>：<br>    1. 根结点的层数为0，则一棵非空二叉树的<strong>第i层上最多有2^i个</strong>结点。<br>    2. 根结点的深度为0，则深度为i的<strong>二叉树的最大结点数为2^(i+1)-1 (i &gt;= -1)个</strong>。<br>    3. 对于一个非空树，<strong>有n0个叶结点，度为2的结点数为n2（即分支结点），则有n0 = n2 + 1</strong>。<br>    4. 有n个结点的<strong>完全二叉树的深度k &gt;= lb(n+1)-1的最小整数</strong>。<br>    5. 有n个结点的完全二叉树，若从上至下，从左只有从0开始编号(i)，则有：<br>        1) i &gt; 0时，第i个结点的双亲为(i-1)/2 整除。<br>        2) 2i+1 &lt; n时，i的左孩子序号2i+1，若&gt;= n，则无左孩子。<br>        3) 2i+2 &lt; n时，i的右孩子序号2i+2，若&gt;= n，则无右孩子。</p><p>二叉树的<strong>顺序存储结构</strong><br>利用性质5可以求得各个元素的编号，故采用数组进行存储，空结点则用NULL表示。仅适用于完全二叉树和空结点不多的树。<br>二叉树的<strong>链式存储结构</strong><br>常用结构，每个结点包含左孩子指针、数据域和右孩子指针三个域。</p><p>—操作实现见应用代码块—</p><h4 id="二叉树的三种遍历方法及相应的递归算法。（应用）"><a href="#二叉树的三种遍历方法及相应的递归算法。（应用）" class="headerlink" title="二叉树的三种遍历方法及相应的递归算法。（应用）"></a>二叉树的三种遍历方法及相应的递归算法。（应用）</h4><p>—操作实现见应用代码块—</p><h4 id="二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）"><a href="#二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）" class="headerlink" title="二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）"></a>二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）</h4><p>二叉树中，从A到B结点所经过的<strong>分支序列</strong>为A-B的<strong>路径</strong>。<br>从A-B所经过的分支<strong>个数</strong>为A-B的<strong>路径长度</strong>。<br>从<strong>根结点至所有叶结点</strong>的路径长度之和为该<strong>二叉树的路径长度</strong>。<br>所有各分支结点的<strong>路径长度*相应权值</strong>的和为<strong>带权路径长度（WPL）</strong>。</p><p>对于一组有权值的叶结点，可构造出多种不同带权路径长度的二叉树，其中具有<strong>最小带权路径长度</strong>的二叉树称为<strong>哈夫曼树</strong>。</p><h4 id="根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）"><a href="#根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）" class="headerlink" title="根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）"></a>根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）</h4><img src="/2020/05/01/Datasource2/Harfman.gif"><p>哈夫曼树构造步骤：<br>    1. 将所有叶结点视为根节点，从而得到一个二叉树森林集合F。<br>    2. 将权值<strong>最小和次小的二叉树分别</strong>作为新左子树和右子树，它们的<strong>根节点权值为两子树权值之和</strong>。<br>    3. 删除先前两棵二叉树，并将新二叉树加入集合。<br>    4. 重复步骤2、3，当集合中只剩一棵二叉树时，这就时哈夫曼树。</p><p>哈夫曼编码构造步骤：<br>    哈夫曼树构造完成后，规定树中左分支为0，右分支为1，经过的路径（分支序列）则为对应元素的哈夫曼编码。</p><h4 id="树与二叉树的转换、树的遍历。（应用）"><a href="#树与二叉树的转换、树的遍历。（应用）" class="headerlink" title="树与二叉树的转换、树的遍历。（应用）"></a>树与二叉树的转换、树的遍历。（应用）</h4><p>树-&gt;二叉树：<br>    1. 树中所有同双亲的兄弟结点间加一条连线。<br>    2. 对该双亲下<strong>非第一个孩子删除与双亲的连接线</strong>。<br>    3. 整理所有的线，原第一个孩子为左子树，非第一孩子为右子树。</p><p>二叉树-&gt;树：<br>    1. 若结点是左孩子，则将<strong>双亲和该结点的右孩子，右孩子的右孩子作连接线</strong>。<br>    2. 删除这些右孩子<strong>与原双亲的连接线</strong>。<br>    3. 整理所有线，相同层次划到一起。</p><p>树的遍历：<br>    先根遍历：与二叉树时前序遍历相同<br>    后根遍历：与二叉树时中序遍历相同</p><h3 id="第九章-图"><a href="#第九章-图" class="headerlink" title="第九章 图"></a>第九章 图</h3><h4 id="图的定义和常用术语。（识记）"><a href="#图的定义和常用术语。（识记）" class="headerlink" title="图的定义和常用术语。（识记）"></a>图的定义和常用术语。（识记）</h4><p><strong>图</strong>是由顶点集合间的关系集合组成的一种数据结构。图G的定义是G = (V,E)，V为数据的集合value，E为边的集合edge。<br>常用术语：<br>    顶点和边：图中的结点一般称为<strong>顶点</strong>，第i个顶点称为vi，若vi和vj间相关联，则称vi-vj间有条边，图中第k条边称为ek，ek = (vi,vj)、&lt;vi,vj&gt;。<br>    有向图和无向图：有向图中顶点对&lt;x,y&gt;是有序的，意为x-&gt;y，所以&lt;x,y&gt;和&lt;y,x&gt;是两条不同的边；在无向图中(x,y)是无序的，意为x-y，所以(x,y)和(y,x)是同一条边。同时<strong>无向边(x,y)包含有向边&lt;x,y&gt;和&lt;y,x&gt;</strong>。<br>    完全图：在有n个顶点的无向图中，若有<strong>n(n-1)/2条边，即任意两顶点间有且只有一条边，则称其为无向完全图</strong>；若有<strong>n(n-1)条边，即任意两顶点间有且只有方向相反的两条边，则称其为有向完全图</strong>。<br>    邻接顶点：在无向图G中，若(u,v)是其中的一条边，则u，v互为邻接顶点，并称边(u,v)依附于顶点u,v。<br>    顶点的度：指与它相关联的边的条数。<br>    路径：从点vi到vj途径的<strong>顶点序列</strong>称为路径。<br>    权：边附带的数据信息。<br>    路径长度：对于不带权的图，长度指该路径上<strong>边的条数</strong>，带权图则指<strong>路径上所有权值的和</strong>。<br>    子图：若图G2的值集合与边集合都含于G1，则称为G2是G1的子图。<br>    连通图和强连通图：无向图中，如果图中<strong>任意一对</strong>顶点都是<strong>连通（指仅有路径相通，不一定直接相连）</strong>的，则为<strong>连通图</strong>；有向图则称为<strong>强连通图（即一对两边）</strong>。<br>    生成树：连通图的最小连通子图称作该图的生成树。<br>    简单路径和回路：若路径上顶点不重复经过，则称为简单路径；若首尾顶点相连，则此路径称为回路或环。</p><p>常见性质：<br>    若无向图/有向图从<strong>任一顶点</strong>出发进行<strong>一次</strong>深度优先搜索就能访问<strong>所有</strong>结点，那么该图一定是连通图/强连通图；<br>    连通分量是<strong>无向图</strong>中的<strong>极大连通子图</strong>；强连通分量是<strong>有向图</strong>中的<strong>极大强连通子图</strong>；<br>    任何一个无向连通图的最小生成树<strong>有一棵或多颗</strong>；<br>    一个连通图的生成树是一个<strong>极小连通子图</strong>.</p><h4 id="图的邻接矩阵存储结构和邻接表存储结构。（应用）"><a href="#图的邻接矩阵存储结构和邻接表存储结构。（应用）" class="headerlink" title="图的邻接矩阵存储结构和邻接表存储结构。（应用）"></a>图的邻接矩阵存储结构和邻接表存储结构。（应用）</h4><p>—操作实现见应用代码块—</p><h4 id="邻接矩阵存储结构下图操作的实现。（理解）"><a href="#邻接矩阵存储结构下图操作的实现。（理解）" class="headerlink" title="邻接矩阵存储结构下图操作的实现。（理解）"></a>邻接矩阵存储结构下图操作的实现。（理解）</h4><p>—操作实现见应用代码块—</p><h4 id="图的深度和广度优先遍历算法。（理解）"><a href="#图的深度和广度优先遍历算法。（理解）" class="headerlink" title="图的深度和广度优先遍历算法。（理解）"></a>图的深度和广度优先遍历算法。（理解）</h4><p>深度相当于二叉树的先序，广度相当于层次；</p><img src="/2020/05/01/Datasource2/DFS&BFS.gif"><p>连通图的深度遍历算法：<br>    1. 访问顶点v并标记已访问<br>    2. 查找v的第一个邻接结点w<br>    3. 若w存在则继续，否则结束算法<br>    4. 若w未被访问，用深度遍历算法递归访问w<br>    5. 查找w的第一个邻接结点，转至步骤3</p><p>连通图的广度遍历算法：<br>    1. 访问顶点v并标记已访问<br>    2. <strong>v入队列</strong><br>    3. 若队列非空则继续，若空则结束算法<br>    4. 取队头结点u<br>    5. 查找u的第一个邻接结点w<br>    6. 若w不存在则返回步骤3，存在则循环执行：<br>        1) 若w未被访问，则访问并标记<br>        2) 顶点w入列<br>        3) 查找w的第一个邻接结点，转至步骤6</p><p>非连通图的遍历算法<br>    <strong>依次将每个结点作为初始顶点</strong>进行深度或广度优先遍历，并根据访问标记来执行访问或跳过操作，直至遍历所有结点。</p><h4 id="生成树和最小生成树的概念。（识记）"><a href="#生成树和最小生成树的概念。（识记）" class="headerlink" title="生成树和最小生成树的概念。（识记）"></a>生成树和最小生成树的概念。（识记）</h4><p><strong>生成树</strong>指连通图的最小连通子图称作该图的生成树。<br><strong>最小生成树</strong>：如果无向连通图是一个带权图，那么必有一棵其边所有权值总和最小的生成树，称之为最小代价生成树，简称最小生成树。</p><h4 id="构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）"><a href="#构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）" class="headerlink" title="构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）"></a>构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）</h4><img src="/2020/05/01/Datasource2/prim.gif"><img src="/2020/05/01/Datasource2/Kruskal.gif"><h4 id="最短路径及相关概念。（识记）"><a href="#最短路径及相关概念。（识记）" class="headerlink" title="最短路径及相关概念。（识记）"></a>最短路径及相关概念。（识记）</h4><p>图中两个顶点间可能存在多条路径，将<strong>路径长度</strong>最短的那条称为<strong>最短路径</strong>，其长度称为<strong>最短路径长度</strong>或<strong>最短距离</strong>。<br>在一个<strong>带权图中</strong>则为<strong>带权路径长度</strong>最小的路径也叫<strong>最短路径</strong>，其长度同上。</p><h4 id="求最短路径的狄克斯特拉算法。（应用）"><a href="#求最短路径的狄克斯特拉算法。（应用）" class="headerlink" title="求最短路径的狄克斯特拉算法。（应用）"></a>求最短路径的狄克斯特拉算法。（应用）</h4><img src="/2020/05/01/Datasource2/Dijkstra.gif"><h4 id="AOV网的概念及有向图的拓扑排序算法。（应用）"><a href="#AOV网的概念及有向图的拓扑排序算法。（应用）" class="headerlink" title="AOV网的概念及有向图的拓扑排序算法。（应用）"></a>AOV网的概念及有向图的拓扑排序算法。（应用）</h4><p>若以有向图的<strong>顶点</strong>来表示活动，以<strong>边</strong>来表示活动间的顺序，则将此有向图称为<strong>顶点表示活动的网（AOV）</strong>。</p><p>有向图的拓扑排序算法：<br>    1. 在有向图中选择一个<strong>无前驱的结点</strong>，并输出<br>    2. 从有向图中<strong>删去此点及相关的有向边</strong>。<br>    重复上述步骤，直至输出所有结点/和或剩余顶点找不到符合条件的顶点（即呈环状）<br>    若为前种情况，此时输出的序列即为拓扑排序；<br>    若为后种情况，说明回路图<strong>一定无法</strong>得到拓扑序列</p><h4 id="AOE网、关键路径、关键活动的概念。（识记）"><a href="#AOE网、关键路径、关键活动的概念。（识记）" class="headerlink" title="AOE网、关键路径、关键活动的概念。（识记）"></a>AOE网、关键路径、关键活动的概念。（识记）</h4><p>若以有向图的<strong>顶点</strong>来表示活动，以<strong>边</strong>来表示活动间的顺序，<strong>权</strong>表示活动持续的时间，则将此有向图称为<strong>边表示活动的网（AOE）</strong>。<br>在AOE网中，从源点至汇点的所有路径中<strong>最大路径长度</strong>的路径称为<strong>关键路径</strong>。<br>关键路径上的活动称为<strong>关键活动</strong>。</p><h3 id="第十章-排序"><a href="#第十章-排序" class="headerlink" title="第十章 排序"></a>第十章 排序</h3><h4 id="排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）"><a href="#排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）" class="headerlink" title="排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）"></a>排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）</h4><p><strong>排序</strong>是对数据元素序列建立某种有序排列的过程，或为按关键字递增或递减排列的过程。<br><strong>关键字</strong>是数据元素中的一个数据项，其中若值不同时关键字也不一定相同，则称为<strong>主关键字</strong>，不满足定义的称为<strong>次关键字</strong>。</p><p>排序分为<strong>内部排序</strong>和<strong>外部排序</strong>两种，内部指数据<strong>全部调入</strong>内存进行排序，外部指<strong>分批</strong>导入内存排序后分批导出至磁盘等外部介质。</p><p>好坏的评判标准通常为：<strong>时间复杂度</strong>、<strong>空间复杂度</strong>、<strong>稳定性</strong>三种，其中稳定性指<strong>当使用主关键字排序时，任何排序算法的结果必定相同</strong>，次关键字可能相同，也可能不同。</p><p>在10000个元素中只想获取前十个最小元素时应用<strong>堆排序</strong>；<br>快速排序在<strong>数据已经基本有序的情况下</strong>最不利；<br>在所有人的生日排序，使用<strong>基数排序</strong>最快；<br>若数据已基本<strong>正序</strong>，用<strong>插入</strong>，<strong>逆序</strong>则用<strong>选择</strong></p><h4 id="简单选择排序的基本思想。（应用）"><a href="#简单选择排序的基本思想。（应用）" class="headerlink" title="简单选择排序的基本思想。（应用）"></a>简单选择排序的基本思想。（应用）</h4><p>依次遍历数据，将最小值交换到遍历的位置，注意数据在符合它位置时也算趟数，总遍历次数 == 数据数量</p><img src="/2020/05/01/Datasource2/Sim_Sort.jpg"><h4 id="直接插入排序的基本思想。（应用）"><a href="#直接插入排序的基本思想。（应用）" class="headerlink" title="直接插入排序的基本思想。（应用）"></a>直接插入排序的基本思想。（应用）</h4><p>顺序把数据元素按<strong>关键字值大小</strong>插入值已排序的数据元素<strong>子集合</strong>的适当位置。子集合的元素个数从一开始逐次增大，当两者大小相同时排序完毕。<br>从第二项(下标1)开始遍历，将其插入前面序列的合适位置，同样在合适位置时也算趟数，总遍历次数 == 数据数量 - 1</p><img src="/2020/05/01/Datasource2/Insert_Sort.jpg"><h4 id="冒泡排序的基本思想。（应用）"><a href="#冒泡排序的基本思想。（应用）" class="headerlink" title="冒泡排序的基本思想。（应用）"></a>冒泡排序的基本思想。（应用）</h4><p>数组a中有n个数据，循环依次比较a[i]和a[i+1]的主关键字值，若逆序则交换，否则不交换；一轮后最大数据沉入数组尾部，然后减少一次循环再进行排序，直至n-1躺结束，此时a[0]为最小数据。</p><h4 id="希尔排序的基本思想。（应用）"><a href="#希尔排序的基本思想。（应用）" class="headerlink" title="希尔排序的基本思想。（应用）"></a>希尔排序的基本思想。（应用）</h4><p>把待排序的元素<strong>分成若干小组</strong>，对组内的元素进行<strong>直接插入排序</strong>，然后再减少组的数量后再次划分重复排序，只剩一个组时排序结束。</p><img src="/2020/05/01/Datasource2/Shell_Sort.jpg"><h4 id="快速排序的基本思想。（应用）"><a href="#快速排序的基本思想。（应用）" class="headerlink" title="快速排序的基本思想。（应用）"></a>快速排序的基本思想。（应用）</h4><p>数组a中有n个数据，分别设高端和低端两个下标，任取一个元素（通常为a[low]）作标准，调整各元素的位置，关键字小于标准的排在其前面，大于等于排后面。此时数组由标准数据化为两个区块，分别对其进行递归操作，当high &lt;= low时结束。<br>即数据头尾分别设一个指针，<strong>先后指针往前遍历</strong>，遇到第一个小于前指针所指数据时，则前后<strong>指针的数据</strong>交换，指针不变；然后<strong>前指针往后遍历</strong>，遇到第一个大于后指针所指数据时交换，反复遍历直至<strong>后指针 &lt;= 前指针</strong>。</p><img src="/2020/05/01/Datasource2/Quick_Sort.jpg"><h4 id="各种排序方法的优缺点的性能比较。（理解）"><a href="#各种排序方法的优缺点的性能比较。（理解）" class="headerlink" title="各种排序方法的优缺点的性能比较。（理解）"></a>各种排序方法的优缺点的性能比较。（理解）</h4><img src="/2020/05/01/Datasource2/sort_compare.jpg"><h3 id="第十一章-查找"><a href="#第十一章-查找" class="headerlink" title="第十一章 查找"></a>第十一章 查找</h3><h4 id="查找的基本概念、分类、平均查找长度。（识记）"><a href="#查找的基本概念、分类、平均查找长度。（识记）" class="headerlink" title="查找的基本概念、分类、平均查找长度。（识记）"></a>查找的基本概念、分类、平均查找长度。（识记）</h4><p><strong>查找</strong>是在元素集合中查找是否存在<strong>关键字等于某个给定关键字数据元素</strong>的过程。<br><strong>主次关键字</strong>概念同上。<br>查找分为<strong>静态查找</strong>和<strong>动态查找</strong>，静态指<strong>只在</strong>集合中查找是否存在关键字相等的数据元素；动态指除静态要求相等外，还包括<strong>查找过程中同时插入的数据集合中不存在</strong>的数据。<br><strong>平均查找长度（ASL）</strong>指查找过程中关键字<strong>比较次数的平均值</strong>。为查找数据的出现概率<em>查找此数据的比较次数。<br>二叉树的*</em>中序遍历**可得到结点值从小到大的排序序列。</p><h4 id="在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）"><a href="#在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）" class="headerlink" title="在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）"></a>在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）</h4><p>从顺序表的一端开始，用给定的关键字逐个进行比较，若查找成功返回其位置，否则返回-1。<br>有序顺序表的<strong>顺序查找</strong>：因为表原有序，所以当存在一个指大于查找值时直接结束算法，不必遍历全表。<br>有序顺序表的<strong>折半查找</strong>：确定表的中心位置，将查找值与中心比较，并移至前半或后半递归，直至上界小于下界时结束。</p><h4 id="哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）"><a href="#哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）" class="headerlink" title="哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）"></a>哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）</h4><p>有n个数据要存储，先设置长度为m的连续内存单元<br>将每个数据的关键字通过hash(key)函数可得到某个地址，并将其关键字的数据存入该地址<br>实际上可看作关键字是对地址的映射，因此hash(key)也称散列地址，哈希表也称散列表。<br>有时存在两个不同关键字映射到同一个地址的现象，称为<strong>哈希冲突</strong>，也称<strong>同义词冲突</strong>。<br>哈希函数的形式为hash(key) = key mod m，m的取值范围是数据个数n的<strong>1.1n-1.7n倍</strong>之间的<strong>素数</strong>。<br>平均查找承担与结点个数n无关的查找方法是<strong>哈希查找</strong>。</p><p>哈希表的构造方法主要有：<strong>除留余数法</strong>、<strong>直接定址法</strong>和<strong>数字分析法</strong>。<br>除留余数法：是指用关键字除以哈希表长度m所得余数作为地址的方法。<br>直接定址法：直接用关键字或关键字加个常数C作为地址的方法。<br>数字分析法：取关键字中某些取值较均匀的数字位作为地址的方法。</p><p>哈希冲突的解决方法主要由<strong>开放定址法</strong>和<strong>链表法</strong>。<br>开放定址法：在产生哈希冲突后再采用若干个<strong>哈希冲突函数</strong>得到一个新的空闲地址的方法，此类哈希冲突函数通常是一组。开放定址法有<strong>线性探查法</strong>、<strong>平方探查法</strong>和<strong>伪随机数法</strong>三种。<br>链表法：如果没有产生哈希冲突则直接存储，若产生则将元素<strong>放入某个单链表中</strong>。方法一是为发生冲突的不同同义词<strong>建立不同的单链表</strong>，二是所有的同义词<strong>建立一个单链表</strong>。</p><img src="/2020/05/01/Datasource2/Hash_Sheet.jpg">]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构考纲识记理解内容（上）</title>
      <link href="/2020/05/01/Datasource1/"/>
      <url>/2020/05/01/Datasource1/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="数据、数据元素、数据项的基本概念（识记）"><a href="#数据、数据元素、数据项的基本概念（识记）" class="headerlink" title="数据、数据元素、数据项的基本概念（识记）"></a>数据、数据元素、数据项的基本概念（识记）</h4><p><strong>数据</strong>是人们利用文字、数字及其他规定的<strong>符号</strong>对事物及其活动所做的<strong>抽象描述</strong>。<br>表示一个事物的一组数据称作一个<strong>数据元素</strong>。构成数据元素的数据称作该数据的<strong>数据项</strong>。</p><h4 id="数据结构的三种逻辑结构和两种存储结构表示方法（理解）"><a href="#数据结构的三种逻辑结构和两种存储结构表示方法（理解）" class="headerlink" title="数据结构的三种逻辑结构和两种存储结构表示方法（理解）"></a>数据结构的三种逻辑结构和两种存储结构表示方法（理解）</h4><p>数据元素之间的相互联系方式称为<strong>数据的逻辑结构</strong><br>逻辑结构分为<strong>线性结构</strong>、<strong>树状结构</strong>和<strong>图形结构</strong>三种。<br>线性结构：除首尾数据元素外，每个数据元素只有一个<strong>唯一前驱</strong>数据元素<strong>唯一后继</strong>数据。<br>树状结构：除根节点外，每个数据元素只有一个<strong>唯一前驱</strong>和<strong>零或若干个后继</strong>。<br>图形结构：每个数据元素可有<strong>零或若干个前驱</strong>和<strong>零或若干个后继</strong>。</p><p>数据元素在计算机中的存储方式称为<strong>数据的存储结构</strong><br>存储结构有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。<br>顺序存储结构是指把数据元素存储在一块<strong>连续地址空间</strong>的内存中。<br>链式存储结构使用<strong>指针</strong>把相互直接关联的点链接起来，逻辑上相邻的数据元素在物理上不一定相邻。</p><p>数据结构被形式的定义为(D,R)，其中D是<strong>数据</strong>的有限集合，R是D上的<strong>关系</strong>的有限集合。</p><h4 id="数据结构和抽象数据类型的概念（理解）"><a href="#数据结构和抽象数据类型的概念（理解）" class="headerlink" title="数据结构和抽象数据类型的概念（理解）"></a>数据结构和抽象数据类型的概念（理解）</h4><p>数据结构主要讨论<em>表、堆栈、队列、串、数组、树、二叉树和图</em>等典型的常用数据结构，在讨论这些数据结构时，主要从它们的<strong>逻辑结构</strong>、<strong>存储结构</strong>和<strong>数据操作</strong>三个方面进行分析讨论。</p><p><strong>类型</strong>是一组值的集合，<strong>数据类型</strong>是指一个<strong>类型和定义</strong>在这个<strong>类型上的操作集合</strong>。通常在已有数据类型基础上设计新的数据类型的过程称为<strong>数据结构设计</strong>。<br><strong>抽象数据类型(Abstract Data Type(ADT))</strong>是指一个<strong>逻辑概念</strong>上的<strong>类型</strong>和这个<strong>类型上的操作集合</strong>。<br>数据类型和抽象数据类型的不同之处在于：数据类型指高级程序设计语言本身支持的基本数据类型，而抽象指在基本数据类型支持下的用户新设计的数据类型。</p><h4 id="算法的概念、性质和目标（识记）"><a href="#算法的概念、性质和目标（识记）" class="headerlink" title="算法的概念、性质和目标（识记）"></a>算法的概念、性质和目标（识记）</h4><p><strong>算法</strong>是描述求解问题方法的<strong>操作步骤集合</strong>。<br><strong>性质</strong>：<br>    1. 输入性<br>    2. 输出性<br>    3. 有限性<br>    4. 确定性<br>    5. 可执行性<br><strong>目标</strong>：<br>    1. 正确性：<strong>基本目标</strong>。<br>    2. 可读性<br>    3. 健壮性<br>    4. 高时间效率：运行需要<strong>花费时间的多少</strong>。<br>    5. 高空间效率：运行需要<strong>占用的额外内存空间的多少</strong>。</p><h3 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h3><h4 id="线性表的定义和抽象数据类型（识记）"><a href="#线性表的定义和抽象数据类型（识记）" class="headerlink" title="线性表的定义和抽象数据类型（识记）"></a>线性表的定义和抽象数据类型（识记）</h4><p><strong>线性表</strong>是一种可以在任意位置进行插入和删除数据元素操作的、由n个相同类型数据元素组成的线性结构。<br>线性表的抽象数据类型包括<strong>数据集合</strong>和<strong>该数据集合上的操作集合</strong>。<br>操作集合：<br>    1. <strong>初始化ListInitiate(L)</strong>：初始化线性表。<br>    2. <strong>求当前数据元素个数ListLenght(L)</strong>，返回表L的元素个数。<br>    3. <strong>插入数据元素ListInsert(L,i,x)</strong>，i为位置，x为元素值，插入成功返回1，否则返回0，针对最后一位存在i = ListLenght(L)-1时，为最后一位前插入数据，i = ListLenght(L)时为在最后一位后插入数据。<br>    4. <strong>删除数据元素ListDelete(L,i,x)</strong>，x为元素值存储位，删除成功返回1，否则返回0，存在i = 0时，删取第一位，i = ListLenght(L)-1时，删取最后一位。<br>    5. <strong>取数据元素ListGet(L,i,x)</strong>，于删除类同，仅取数据。</p><h4 id="线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）"><a href="#线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）" class="headerlink" title="线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）"></a>线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）</h4><p>—实现见应用代码块—<br>顺序存储结构的线性表就是<strong>顺序表</strong>。<br>实现<strong>顺序存储结构</strong>的方法是使用<strong>数组</strong>。数组把线性表的数据结构存储在一块连续地址空间的内存单元中，所以线性表逻辑相连的数据元素物理上也相邻。<br>顺序表中<strong>插入和删除</strong>的平均时间复杂度为<strong>O(n)</strong>，其余操作的时间复杂度均为O(1)。</p><h4 id="线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）"><a href="#线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）" class="headerlink" title="线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）"></a>线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）</h4><p>—实现见应用代码块—<br>存储结构：<br>    <strong>单链表</strong>：构成链表的节点<strong>只有一个</strong>指向<strong>直接后继节点</strong>的指针域。<br>    <strong>循环单链表</strong>：是单链表的另一种形式，结构特点是链表中<strong>最后一个节点的指针域不再是NULL而是指向第一个节点</strong>，形成一个环。<br>    <strong>双向链表</strong>：每个节点除了后继指针域外<strong>还有一个前驱指针域</strong>，带头节点的双向链表更为常用。</p><h4 id="单链表上实现的建表、查找、插入和删除等基本算法。（理解）"><a href="#单链表上实现的建表、查找、插入和删除等基本算法。（理解）" class="headerlink" title="单链表上实现的建表、查找、插入和删除等基本算法。（理解）"></a>单链表上实现的建表、查找、插入和删除等基本算法。（理解）</h4><p>见第二章第三节。</p><h4 id="顺序表和链表的比较，各自的优缺点。（理解）"><a href="#顺序表和链表的比较，各自的优缺点。（理解）" class="headerlink" title="顺序表和链表的比较，各自的优缺点。（理解）"></a>顺序表和链表的比较，各自的优缺点。（理解）</h4><p>链表中<strong>插入、删除、求元素个数和撤销单链表</strong>的平均时间复杂度为<strong>O(n)</strong>，其余操作的时间复杂度均为O(1)。<br>优点：不需要预先确定数据元素的最大个数。<br>缺点：每个节点都包含了指针域，空间利用率不高，且算法较为复杂。<br>顺序表的优缺点于链表相异即可。</p><h3 id="第三章-堆栈和队列"><a href="#第三章-堆栈和队列" class="headerlink" title="第三章 堆栈和队列"></a>第三章 堆栈和队列</h3><h4 id="堆栈的定义和特点。栈顶和栈底相关术语。（识记）"><a href="#堆栈的定义和特点。栈顶和栈底相关术语。（识记）" class="headerlink" title="堆栈的定义和特点。栈顶和栈底相关术语。（识记）"></a>堆栈的定义和特点。栈顶和栈底相关术语。（识记）</h4><p><strong>堆栈</strong>是一种特殊的线性表，堆栈的逻辑关系和线性表完全相同，差别在于堆栈<strong>只允许在固定一端</strong>进行插入和删除数据的操作。堆栈中允许进行插入和删除数据元素操作的一段称为<strong>栈顶</strong>。另一端称为<strong>栈底</strong>。栈顶的位置是动态的，拥有标记栈顶位置的变量称为<strong>栈顶指示器（栈顶指针）</strong>。堆栈的插入操作通常称为<strong>进栈或入栈</strong>，删除操作称为<strong>出栈或退栈</strong>。是个<strong>先进后出表</strong>。</p><h4 id="顺序-链式堆栈的存储结构和操作实现。（理解）"><a href="#顺序-链式堆栈的存储结构和操作实现。（理解）" class="headerlink" title="顺序/链式堆栈的存储结构和操作实现。（理解）"></a>顺序/链式堆栈的存储结构和操作实现。（理解）</h4><p>—实现见应用代码块—<br>存储结构：顺序堆栈和顺序表的差别是只对栈顶进行操作，将数组a[]抽象成堆栈，且a0为栈底，ai为栈顶，存在变量top表示栈顶位置。<br>同时，链式堆栈和单链表的差别同上，将靠近头指针的节点定为栈顶，另一端为栈底。</p><h4 id="队列的概念和特点。队首和队尾相关术语。（识记）"><a href="#队列的概念和特点。队首和队尾相关术语。（识记）" class="headerlink" title="队列的概念和特点。队首和队尾相关术语。（识记）"></a>队列的概念和特点。队首和队尾相关术语。（识记）</h4><p><strong>队列</strong>也是一种特殊的线性表，于线性表完全相同，差别在于队列<strong>只允许在其一端</strong>进行插入操作，在<strong>其另一端</strong>进行删除操作。<br>队列中插入操作的一端称为<strong>队尾</strong>，进行删除操作的一端称为<strong>队头</strong>。与堆栈相同同样存在<strong>队头指示器（队头指针）</strong>和<strong>队尾指示器（队尾指针）</strong>。队列的插入操作通常称为<strong>入队列</strong>，删除操作称为<strong>出队列</strong>。是个<strong>先进先出表</strong>。</p><h4 id="顺序-链式队列的存储结构、顺序循环队列的表示和实现。（理解）"><a href="#顺序-链式队列的存储结构、顺序循环队列的表示和实现。（理解）" class="headerlink" title="顺序/链式队列的存储结构、顺序循环队列的表示和实现。（理解）"></a>顺序/链式队列的存储结构、顺序循环队列的表示和实现。（理解）</h4><p>—实现见应用代码块—<br>顺序队列存储结构与堆栈类似，使用顺序循环队列的原因是因为<strong>尾指针会超出队列定义的最大存储空间</strong>，造成<strong>假溢出</strong>的现象。<br>故采用循环队列，当为指针超出最大时重置为0，作环状。<br>判断队空满的三种方法：<br>    1. 少用一个存储空间<br>    队满(rear + 1) % MaxQueueSize == front<br>    队空rear == front<br>    2. 设置一个标志位<br>    队满rear == front &amp;&amp; tag == 0<br>    队空rear == front &amp;&amp; tag == 1<br>    3. 设置一个计数器<br>    队满count == 0<br>    队空count &gt; 0 &amp;&amp; rear == front</p><h4 id="堆栈和队列的应用。（应用）"><a href="#堆栈和队列的应用。（应用）" class="headerlink" title="堆栈和队列的应用。（应用）"></a>堆栈和队列的应用。（应用）</h4><p>堆栈应用：括号匹配问题/算数表达式问题<br>队列应用：打印任务管理器</p><h3 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h3><h4 id="串的定义、空串、空格串、子串、主串、串相等。（识记）"><a href="#串的定义、空串、空格串、子串、主串、串相等。（识记）" class="headerlink" title="串的定义、空串、空格串、子串、主串、串相等。（识记）"></a>串的定义、空串、空格串、子串、主串、串相等。（识记）</h4><p><strong>串（也称字符串）</strong>是由n个字符组成的有限序列。<br><strong>空串</strong>为字符数为0的串，<strong>空格串</strong>表示只含空格字符的串。<br>一个<strong>串中</strong>任意个连续字符组成的<strong>子序列</strong>称为该串的<strong>子串</strong>，包含子串的串称为该子串的<strong>主串</strong>。<br><strong>串相</strong>？</p><h4 id="串的基本操作（理解）"><a href="#串的基本操作（理解）" class="headerlink" title="串的基本操作（理解）"></a>串的基本操作（理解）</h4><p>—实现见应用代码块—</p><h3 id="第五章-数组"><a href="#第五章-数组" class="headerlink" title="第五章 数组"></a>第五章 数组</h3><h4 id="数组的定义（识记）"><a href="#数组的定义（识记）" class="headerlink" title="数组的定义（识记）"></a>数组的定义（识记）</h4><p><strong>数组</strong>是n个相同数据类型的数据元素构成的占用一块地址连续的内存单元的有限序列。</p><h4 id="数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）"><a href="#数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）" class="headerlink" title="数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）"></a>数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）</h4><p>对一个有n个数据元素的<strong>一维数组</strong>，a0是下标为0的数组元素，loc(a0)是a0的内存单元地址，k是每个数据元素所需的字节个数，则数组中任一数据元素ai的内存单元地址loc(ai)可由下面公式求出：<br><strong>loc(ai) = loc(a0) + i * k (0 &lt;= i &lt;= n)</strong></p><p><strong>二维数组</strong>为m行n列的矩阵，因为计算机的存储原理所以存在二维数组向一位数组映射的问题。映射有两种方法，分别称为<strong>行主序</strong>和<strong>列主序</strong>方法，C语言采用行主序方法。则数组中任一数据元素aij的内存单元地址loc(aij)可由下面公式求出：<br><strong>loc(aij) = loc(a00) + (i * n + j) * k (0 &lt;= i &lt; m, 0 &lt;= i &lt; n)</strong></p><p>用高级语言定义数组时，数组的首地址由系统分配并保存。通常用数组名保存数组的首地址，编译器可快速算出任一元素的地址。<br>应为计算元素地址的速度相同，所以存取时间也相同，通常称具有这种特性的存储结构为随机存储结构。<strong>数组是一种随机存储结构</strong>。</p><h4 id="特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）"><a href="#特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）" class="headerlink" title="特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）"></a>特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）</h4><p>存在许多值相同或许多零元素，且分布有一定规律的矩阵称为<strong>特殊矩阵</strong>。<br>对于一个m * n = s的矩阵，设t为矩阵中非零元素的总和，满足t &lt;&lt; s(即t * 10^2 &lt; s)的矩阵称为<strong>稀疏矩阵</strong>。</p><p>若存在一个n * n的矩阵，且内部数据沿主对角线对称，则将其称为<strong>n阶对称矩阵</strong>。<br>当对称矩阵由一维数组映射时，则有k = 下标坐标：<br><strong>k = i(i + 1)/2 + j - 1 当i &gt;= j时，即上半区含中线</strong><br><strong>k = n(n + 1)/2 当i &lt; j时，即下半区</strong></p><p>稀疏矩阵的压缩存储结构主要有<strong>三元组顺序表</strong>和<strong>三元组链表</strong>。<br>三元组顺序表形式：{1,3,11},{1,5,17},{2,2,25},{4,1,19}，其中三元素第一位为行号，第二位为列号，第三位为元素值。<br>三元组链表形式：形如数组，每个元素表示行号，数组的值为指针，每个行号作为头指针衍生出单链表，存储列号和元素值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）概论</title>
      <link href="/2019/08/27/os1/"/>
      <url>/2019/08/27/os1/</url>
      
        <content type="html"><![CDATA[<h2 id="概述及公式"><a href="#概述及公式" class="headerlink" title="概述及公式"></a>概述及公式</h2><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>周转时间：作业完成时刻-作业到达时刻<br>平均周转时间：作业周转总时间/作业个数<br>带权周转时间：周转时间/服务时间<br>平均带权周转时间：带权周转总时间/作业个数<br>等待时间：周转时间-服务时间<br>平均等待时间：等待总时间/作业个数<br>响应比：作业周转时间/作业执行时间 = （等待时间+要求服务时间）/要求服务时间</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>先来先服务算法：如名字所说，先进入就绪队列的进程先运行</p><p>非抢占式优先级算法：执行完一个进程后在队列中挑选一个优先级最高的进程运行</p><p>银行家算法：银行家算法是死锁<strong>预防</strong>策略<br>    四个规则：<br>    1.当一个进程的最大需求不超过现有资源时可允许<br>    2.进程可以分期获取资源，但不能超过最大资源数<br>    3.不能满足进程的需求时可推迟，但总能在有限时间内分配资源<br>    4.当进程获取完全部所需资源时一定在有限的时间内归还<br>死锁的解除分为：剥夺资源和撤销进程</p><p>在<strong>交互式用户环境</strong>中采用抢占式调度算法</p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>操作系统结构研究<strong>不包括</strong>规则统一化<br><strong>不属于</strong>特权指令的是管访命令<br>中断屏蔽标志位是<strong>IF</strong><br><strong>不属于临时性资源</strong>的是共享程序代码<br>把逻辑地址转绝对地址的工作称为<strong>地址重定位</strong><br>Unix接口有内存与硬件、内核与shell两个接口<br>整理内存碎片的技术叫<strong>紧缩</strong><br>SPOOLing系统主要三部分：输入程序模块、输出程序模块、作业调度<br>分时操作系统不具有实时性<br>消息缓冲区是由消息长度、消息正文、发送者、消息队列指针四项组成</p><h3 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h3><p>P操作对资源S进行预测，其内部动作为：<br>    1.S-1<br>    2.判断若S-1后大于或等于0，则进程继续执行<br>    3.若小于0，就阻塞并放入S的等待队列中<br>V操作释放信号量，内部动作为：<br>    1.S+1<br>    2.若大于0，继续执行<br>    3.若小于等于0，则从S等待队列中释放一个等待进程<br>信号量：是整数，互斥信号量一般是1<br>信号量值的物理意义：若为正数，意味着S还有若干个资源可使用；若为负数，意味着有若干个进程在队列中等待，为0时表示有进程正在占用最后这个S资源<br>PV操作的缺点是：<br>    1.程序可读性差<br>    2.不利于修改和维护<br>    3.正确性难以保证<br>例题：将整型电压值从传感器中取出存入缓冲区，然后取出转换成温度值后再次存入，最后再次取出显示。用PV操作来实现三个过程共享缓冲区的同步问题。</p><h3 id="资源分配图及化简方法"><a href="#资源分配图及化简方法" class="headerlink" title="资源分配图及化简方法"></a>资源分配图及化简方法</h3><p>1.查看是否有满足需求的资源，将它的所有边去掉，变成一个孤立的点<br>2.重复上述过程<br>3.若所有点都能孤立就能避免死锁，否则就是死锁状态<br>死锁：</p><h3 id="磁盘调度的几种方法"><a href="#磁盘调度的几种方法" class="headerlink" title="磁盘调度的几种方法"></a>磁盘调度的几种方法</h3><p>先来先服务(FCFS)：先进入队列的申请先调度，不过有相邻申请磁道却相隔很远的不利情况<br>最短寻找时间有限算法(SSTF)：选择离当前磁道最近的申请进行调度，不过可能产生饥饿<br>扫描算法（SCAN/LOOK）：无申请时不动，有申请时磁头沿该方向扫描，若这个方向还有申请就继续前进，若没有申请或走到尽头则调头，对两头区域不利<br>循环扫描算法(C-SCAN/C-LOOK)：规定磁头单向移动，扫描至尽头后直接折返至起点，折返间不接受任何申请</p><p>用于储存数据物理、线性和有效地址的寄存器是地址寄存器<br>实现存储保护，对属于自己区域的信息<strong>可读可写</strong><br>存储系统的设计<strong>不考虑时间</strong>问题<br>流式文件没有结构</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程由程序、数据、进程控制块组成<br>进程的特性不包括随机性；含有并发、动态、交往、异步、结构、独立性<br>在Unix系统中，创建子进程使用fork()函数，exec()函数要配合vfork()函数使用，功能是加载一个可执行文件，wait()函数用于等待并回收子进程，而waitpid()函数是等待并回收一个<strong>指定</strong>的子进程<br>资源拥有的<strong>基本单位是进程</strong>不是线程<br>当一个管程无法继续执行时也是用wait操作</p><h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>将程序划分为若干个长度相等的页，然后各自放入内存，并记录下该页所存放的内存地址并和页码(页式虚拟地址)一一对应形成<strong>页表</strong>；页表存放在内存中一块固定的存储区，每个进程至少有一个页表<br>缺页中断：有时某一页还未加载进内存，程序试图访问这一页时CPU的内存管理单元会发出中断<br>页面置换算法：<br>    LRU(Least Recently Used)把<strong>最近最少使用置换</strong>的页面淘汰<br>    LFU(Least Frequently Used)<strong>最少使用置换</strong>每个页面都设置一个移位寄存器，用来记录移位的频率，频率最低的页面被淘汰<br>    OPT(不可实现)<strong>最佳置换算法</strong>因为OS不知道各页面什么时候会被访问<br>    FIFO(First Input First Output)<strong>先进先出置换</strong>，最先进入内存的页面最先被淘汰</p><h3 id="通道技术"><a href="#通道技术" class="headerlink" title="通道技术"></a>通道技术</h3><p>独立于CPU，在内存和I/O设备间交换数据，启动时由CPU执行相应指令启动，结束时向CPU发送中断信号<br>DMA(直接存储器访问)：将数据成块的传递给CPU，例如使用键盘输入的时候，CPU不用一直等待，可以去处理其他任务</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>一级文件称为主文件目录，二级称为用户文件目录<br>二级目录的优缺点-优：解决了文件的重名问题，查找时间减少，实现不同用户间的文件共享；缺：增加了系统开销<br>索引文件结构既适合顺序存储，也适合随机存储<br>逻辑文件可以采用的逻辑方式是记录式文件和流式文件</p><h2 id="详细内容"><a href="#详细内容" class="headerlink" title="详细内容"></a>详细内容</h2><h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统是集中了<em>资源管理功能</em>和<em>控制程序执行功能</em>的一种<strong>软件</strong><br>意为能有效的组织和管理计算机系统的硬件和软件资源，合理地组织计算机工作流程，控制程序地执行，并向用户提供各种服务功能，使得用户能够灵活、方便、有效地使用计算机，并使整个计算机系统能高效地运行。</p><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><h4 id="1-并发性"><a href="#1-并发性" class="headerlink" title="1.并发性"></a>1.并发性</h4><p>指在系统中<em>同时</em>存在若干个运行着的程序，从<strong>宏观</strong>上看，这些程序在同时向前推进。<br>（并行性-指两个或两个以上的事件在同一时刻发生，是具有<strong>微观</strong>意义的同时，并发只是多个程序交替进行，是一种<em>假象</em>的同时）</p><h4 id="2-共享性"><a href="#2-共享性" class="headerlink" title="2.共享性"></a>2.共享性</h4><p>指操作系统和多个用户共用系统中的各种资源<br>    a.互斥共享-如打印机、扫描仪等，在一段时间内只能由某一个用户程序使用<br>    b.同时共享-如音响等，可以在一段时间内被多个程序同时访问。</p><h4 id="3-虚拟性"><a href="#3-虚拟性" class="headerlink" title="3.虚拟性"></a>3.虚拟性</h4><p>指把物理上的实体变为若干个逻辑上的对应物。前者是实际存在的，而后者是用户感受到的，譬如一个计算机的实际物理内存只有4GB，而同时运行的软件的需要内存早已超过了4GB，采用虚拟存储器技术（空分/时分复用技术）将空间和时间微分并交替进行造成运行内存超过物理内存的假象，与并发性类似。</p><h4 id="4-随机性"><a href="#4-随机性" class="headerlink" title="4.随机性"></a>4.随机性</h4><p>操作系统的运行是建立在随机发生事件的情况下的，操纵系统不能对所运行的程序的行为以及硬件设备的情况做出任何实现的假定。</p><h3 id="研究操作系统的观点"><a href="#研究操作系统的观点" class="headerlink" title="研究操作系统的观点"></a>研究操作系统的观点</h3><h4 id="1-软件的观点"><a href="#1-软件的观点" class="headerlink" title="1.软件的观点"></a>1.软件的观点</h4><p>操作系统是一种软件，是最接近硬件的软件</p><h4 id="2-资源管理的观点"><a href="#2-资源管理的观点" class="headerlink" title="2.资源管理的观点"></a>2.资源管理的观点</h4><p>操作系统负责登记谁在使用什么样的资源，系统中还有哪些资源空闲，当前响应了谁对资源的要求，以及回收了哪些不再使用的资源等。</p><h4 id="3-进程的观点"><a href="#3-进程的观点" class="headerlink" title="3.进程的观点"></a>3.进程的观点</h4><p>把操作系统看成由<em>多个同时独立运行的程序</em>和<em>一个对这些程序进行协调的*</em>核心***所组成。</p><h4 id="4-虚机器的观点（非虚拟机）"><a href="#4-虚机器的观点（非虚拟机）" class="headerlink" title="4.虚机器的观点（非虚拟机）"></a>4.虚机器的观点（非虚拟机）</h4><p>用户通过操作系统来控制硬件，看作一个虚拟的机器</p><h4 id="5-服务提供者的观点"><a href="#5-服务提供者的观点" class="headerlink" title="5.服务提供者的观点"></a>5.服务提供者的观点</h4><p>为用户提供服务的提供者</p><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><h4 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1.进程管理"></a>1.进程管理</h4><p>进程管理的实质是<strong>对中央处理器进行管理</strong>，为了描述多道程序的并发执行，就要引入进程的概念。<br>    a.进程控制-即进程创建时要分配其资源，进程结束时回收其资源<br>    b.进程同步-多个进程是并发的，并且以<em>异步</em>的方式运行，所以执行速度是不能确定的。为了宏观上同步就要对进程进行协调。主要有<em>互斥</em>和<em>同步</em>两种方式，在遇到硬件是否冲突的时候协调他们的运行顺序。其中一个方法是调用<em>原语</em>中的资源加锁语句。<br>    c.进程间通信-操作系统提供进程间相互交换数据的手段<br>    d.调度-即从进程（线程）的就绪队列中按照一定算法调出一个并分配资源让他执行</p><h4 id="2-存储管理"><a href="#2-存储管理" class="headerlink" title="2.存储管理"></a>2.存储管理</h4><p>任务是管理计算机中的内存<br>    a.内存的分配和回收<br>    b.存储保护-已经使用的内存不会被再次调用<br>    c.内存扩充-即空分复用技术</p><h4 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3.文件管理"></a>3.文件管理</h4><p>对硬盘的管理<br>    a.文件存储空间的管理（常采用离散分配的方式，以512B或几KB为单位进行分配）<br>    b.目录管理<br>    c.文件系统的安全性</p><h4 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4.设备管理"></a>4.设备管理</h4><h4 id="5-用户接口"><a href="#5-用户接口" class="headerlink" title="5.用户接口"></a>5.用户接口</h4><h3 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows<img src="/2019/08/27/os1/win.JPG"></h4><p>1.内核-提供线程调度、陷入处理和异常调度、中断处理和调度、多处理器同步、供执行体使用的基本内核对象<br>2.硬件抽象层-将硬件的接口封装成一个可加载的核心态模块，隐藏细节，作为黑箱一般，只要调用即可<br>3.执行体-处于内核上层，可调用函数执行<br>4.系统进程和线程</p><h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix<img src="/2019/08/27/os1/unix.JPG"></h4><p>1.内核层-常驻于内存，下接硬件接口，上接shell接口。本身分为两大部分，一部分为进程控制子系统，一部分为文件子系统<br>2.系统调用层-可进行文件管理，终端状态和进程管理等<br>3.应用层-即应用通过shell再通过系统调用层访问硬件，所有应用都基于shell运行</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux<img src="/2019/08/27/os1/linux.JPG"></h4><p>1.内核-负责管理系统的进程、内存、设备驱动、文件和网络系统<br>2.shell-是一个命令解释器，将用户输入的指令直接解释给内核执行<br>3.文件系统-即文件在硬盘等存储设备上的组织方法<br>4.应用程序-最上层的应用程序一般都有图形界面，包括有文本编辑器、办公套件等软件</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android<img src="/2019/08/27/os1/and.jpg"></h4><p>1.应用程序-由Java编写的如电话、短信等自带程序<br>2.应用框架-为开发者提供可以访问各类API的框架，只要程序遵循这个框架就能安全的通过API访问核心功能<br>3.C/C++本地库和运行环境-程序在安装时实际上是一个由Java编译至机器码的过程，通过框架得知所需的功能后再从库中查找功能<br>4.Linux内核-包括系统层的安全机制、内存管理、进程管理、网络堆栈及一系列其他模块</p><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><h4 id="1-手工发展"><a href="#1-手工发展" class="headerlink" title="1.手工发展"></a>1.手工发展</h4><p>打孔二进制放入机器运行，这种形式运行一个程序时占用整个计算机的全部资源</p><h4 id="2-监控程序"><a href="#2-监控程序" class="headerlink" title="2.监控程序"></a>2.监控程序</h4><p>程序可以监督一个作业是否完成，可将多个作业打包排队运行，不必一个一个存入取出，即早期的批处理</p><h4 id="3-多道批处理"><a href="#3-多道批处理" class="headerlink" title="3.多道批处理"></a>3.多道批处理</h4><p>输入输出和处理器操作可以并行处理，只要一个硬件空余就执行下个可执行的作业（类似工程中的流水节拍）</p><h4 id="4-分时与实时系统"><a href="#4-分时与实时系统" class="headerlink" title="4.分时与实时系统"></a>4.分时与实时系统</h4><p>当遇到多个用户同时使用一个计算时就需要将时间微分交替为每个用户服务；实时系统用在对时间要求严格的场景中</p><h4 id="5-Unix操作系统"><a href="#5-Unix操作系统" class="headerlink" title="5.Unix操作系统"></a>5.Unix操作系统</h4><p>Unix是使用C语言编写的，可移植性很强；是一个良好的、通用的、多用户、多任务、分时操作系统，同时有shell解释命令和编写程序</p><h4 id="6-个人计算机操作系统"><a href="#6-个人计算机操作系统" class="headerlink" title="6.个人计算机操作系统"></a>6.个人计算机操作系统</h4><p>如Linux和Windows都是如今流行的个人操作系统</p><h4 id="7-Android系统"><a href="#7-Android系统" class="headerlink" title="7.Android系统"></a>7.Android系统</h4><p>基于Linux发展的移动平台操作系统</p><h3 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h3><h4 id="1-批处理操作"><a href="#1-批处理操作" class="headerlink" title="1.批处理操作"></a>1.批处理操作</h4><p>即早期的批处理系统，将作业成堆的输入计算机执行后输出；在整个程序的头部有一份作业控制说明书，其中写明了各个作业的执行顺序，类似于以下形式：<br>    STEP1    ASM        A<br>    STEP2    FTN     B<br>    STEP3    LINK    A, B, C<br>    STEP4    RUN        C<br>    意为A由汇编语言编译，B由Fortran编译，将A和B连成C，最后运行C<br>一般指令和特权指令<br>    中央处理器（CPU）有两个运行状态，用户态（目态）和核心态（管态），特权指令只能在核心态时执行，一般指令在两个状态都能执行；特权指令包括输入/输出指令、停机指令等，应用程序只能间接调用这些功能，当需要调用这些功能时，监控程序移动到这个部分，再将目态切换至管态，执行后监控程序复原，管态切至目态<br>SPOOLing技术<br>    自动根据作业控制说明书完成计算机的输入输出部分，不具有并发功能，没有根本上解决输入输出缓慢的问题，只能看作一个高级的I/O接口；当然它为多道批处理的发展提供了基础，表明了能利用空闲的硬件提高效率</p><h4 id="2-分时操作系统"><a href="#2-分时操作系统" class="headerlink" title="2.分时操作系统"></a>2.分时操作系统</h4><p>将时间微分，即具有并发的特性，宏观上实时反馈多个信息；具有多路性、交互性、“独占性”与及时性，用户可以干预每一步的进行</p><h4 id="3-实时操作系统"><a href="#3-实时操作系统" class="headerlink" title="3.实时操作系统"></a>3.实时操作系统</h4><p>同上，具有并行的特性，微观上同时进行，运用在时钟管理、过载保护等地</p><h4 id="4-嵌入式操作系统"><a href="#4-嵌入式操作系统" class="headerlink" title="4.嵌入式操作系统"></a>4.嵌入式操作系统</h4><p>高定制性的操作系统，可根据每个应用场景的不同改变其中的原语、调度算法和内存管理等分配策略，在工业上广泛应用，同时是具有高度统一协调、调度、指挥和控制的系统</p><h4 id="5-个人计算机系统"><a href="#5-个人计算机系统" class="headerlink" title="5.个人计算机系统"></a>5.个人计算机系统</h4><h4 id="6-网络操作系统"><a href="#6-网络操作系统" class="headerlink" title="6.网络操作系统"></a>6.网络操作系统</h4><p>为计算机网络所配置的操作系统，包括网络管理、通信、安全、资源共享等功能</p><h4 id="7-分布式操作系统"><a href="#7-分布式操作系统" class="headerlink" title="7.分布式操作系统"></a>7.分布式操作系统</h4><p>将大量运行同一个操作系统的计算机通过网络连接，再通过调度它们的资源执行任务造成一台计算能力非常强大的计算机的假象，任何一台计算机下线都不影响整个系统的运行</p><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><h4 id="1-整体式结构"><a href="#1-整体式结构" class="headerlink" title="1.整体式结构"></a>1.整体式结构</h4><p>类似将所有功能封装成各个模块，然后整个模块又封装成一个整体，优点是结构紧密，运行效率高，但是这种情况下一个变量进入后没有哪个模块可调用哪个模块不可调用的约定，会造成循环调用，引发错误；整体式结构的特点就在于接口简单直接，但无运行顺序</p><h4 id="2-层次式结构"><a href="#2-层次式结构" class="headerlink" title="2.层次式结构"></a>2.层次式结构</h4><p>为了解决整体式的问题，需要对接口的输入输出做出规范；将模块们分层，本层只能和上层或者下层单向的交换数据，同层间的模块或许能交换数据（不能则是全序），这样子每个层次的功能都可以修改，只要接口的约定不变就不会影响整个系统</p><h4 id="3-微内核结构"><a href="#3-微内核结构" class="headerlink" title="3.微内核结构"></a>3.微内核结构</h4><p>内核功能较少，不像整体式或层次式那样将所有模块封装在一起，而是只封装最核心的部分，这样能对内核的修改非常简便且维护简单，缺点是频繁被调用核心功能，多次在目态和管态间切换，效率低</p><h3 id="处理器（CPU）"><a href="#处理器（CPU）" class="headerlink" title="处理器（CPU）"></a>处理器（CPU）</h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>一般由运算器、控制器一系列的寄存器以及高速缓存构成<br>其中<strong>运算器</strong>能实现指令中的算术和逻辑运算；<strong>控制器</strong>负责程序运行的流程，包括取指令、维护处理器状态、处理器和内存的交互等；<strong>寄存器</strong>是一种暂时存储的器件，用于存储运行指令过程中暂存数据、地址以及指令信息<br>寄存器的运行速度比内存快上许多，寄存器通常分为两种：<br>用户可见寄存器-编译器可以调用这些寄存器，减少使用内存的次数以提高程序运行的效率<br>控制和状态寄存器-包括数据寄存器、地址寄存器和条件码寄存器，数据寄存器存储算术逻辑指令和访存指令；地址寄存器储存数据和指令的物理地址、线性地址或者有效地址；条件码存储器保存运算后的各种标记，如溢出、符号等</p><h4 id="指令执行的基本过程"><a href="#指令执行的基本过程" class="headerlink" title="指令执行的基本过程"></a>指令执行的基本过程</h4><p>首先处理器每次从存储器中读取一条指令，并根据指令类别将程序计数器的指改为下一条指令的地址（通常情况下指令在内存中都是连续的，所以大多是自增1）；其次指令被存储到指令寄存器中，然后处理器解释并执行，这就被成为一个指令周期<br>程序的执行就是不断地取指令→存指令→执行指令组成的，只有机器关机、发生未知错误或遇到停止指令时机器才会停止<br>指令大概分为五类（与特权非特权不同）<br>访问存储器指令-负责存储器和处理器间的数据传送<br>I/O指令-负责处理器和I/O模块间的数据和命令发送<br>算术逻辑指令-执行数据的算术和逻辑操作<br>控制转移指令-可以指定一个<strong>新的</strong>指令的<strong>执行地点</strong><br>处理器控制指令-用于修改处理器状态，改变其工作方式（即目态和管态的切换）</p><h4 id="特权与非特权指令"><a href="#特权与非特权指令" class="headerlink" title="特权与非特权指令"></a>特权与非特权指令</h4><p>用户不允许随意使用特权指令，以免造成系统的混乱；特权指令一般包括：<em>设置程序状态字、启动某种设备、设置中断屏蔽、设置时钟指令、清理内存和建立存储保护指令等</em>，用户只能间接的使用这些指令，每次使用时就需要将CPU的状态从目态切换至管态，这一过程被称为陷入（Trap）<br>操作系统运行的过程中目态和管态是在动态切换的，<strong>目态至管态</strong>的切换只能通过<strong>中断</strong>来进行，中断响应时交换中断向量，新的中断向量中的PSW（程序状态字）状态位标为管态；<strong>管态至目态</strong>直接修改PSW即可，不必经历中断<br>系统启动时，CPU的<strong>初始状态为管态</strong>，后装入操作系统后，让用户在目态执行</p><h4 id="程序状态字PSW"><a href="#程序状态字PSW" class="headerlink" title="程序状态字PSW"></a>程序状态字PSW</h4><p>有一个专门的寄存器来寄存处理器的状态；如程序计数器就来指示下一条要执行的指令<br>通常包括以下几个状态代码：<br>CPU的工作状态代码-指明是目态还是管态<br>条件码-反应指令执行后的结果特征<br>中断屏蔽码-指出是否运行中断</p><h3 id="硬件部件"><a href="#硬件部件" class="headerlink" title="硬件部件"></a>硬件部件</h3><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><p>基本上可以划分为两类：读写型的存储器和只读型的存储器<br>读写型的可以将数据存入任一地址单元并任意去取出或重新载入，即随机访问存储器（RAM）<br>只读型不能随意写入数据，称为只读存储器（ROM），还有PROM和EPROM等变种，PROM可用特殊的写入器写入，EPROM可用特殊的紫外线“擦去”信息位，再用写入器写入<br>存储的最小单位是1位（bit）只能存储1或0，<strong>一个字节包含8位</strong>，两个字节称为一个字，四个字节称为双字，1024个字节则为1KB，类推出MB、GB等<br>存储系统的设计要考虑三个问题：<strong>容量、速度和成本</strong><br>一般情况下，速度越快价格越高容量越小；速度越慢价格越低容量越大，合理分配计算机存储硬件等级也是值得考虑的，一般情况下<strong>寄存器&gt;高速缓存&gt;内存&gt;硬盘&gt;磁带、光驱</strong>比较合理<br>内存的保护<br>利用界地址寄存器来存储作业在内存中的上限和下限地址，当处理器访问内存时对比现请求的内存和已经在使用的内存是否越界，若越界则产生程序中断</p><h4 id="I-O部件"><a href="#I-O部件" class="headerlink" title="I/O部件"></a>I/O部件</h4><p>早期计算机是用CPU轮流询问硬件是否有处理请求后再处理，这种方式效率过低被淘汰<br>如今则采用<strong>通道</strong>的方式，通道是独立于CPU的，各种外部设备的设备控制器通过通道连接到系统的公共系统总线上；通道代替CPU处理I/O操作，使得外部设备和处理器可以<em>并行</em>工作；通道又被称为<strong>I/O处理器</strong><br>当CPU处理到“启动外设”的命令时就启动外设并将控制权交给通道，外设和内存的数据交换直接由通道控制，不经过CPU；外设工作结束后，形成一个“输入输出操作结束”的I/O中断事件，由CPU处理结束<br>这样大大提高了运行效率，不让设备和CPU空转运行；还会使用<strong>直接存储器访问（DMA）</strong>技术，DMA是一个总线中的一个独立的控制单元，自动控制成块的数据在内存和I/O单元间传送。处理器需要读取设备数据时给DMA发一条命令后可以处理其他事情，当DMA整理好数据发送过来时会触发中断来接收数据，这条命令通常包括设备的编址、开始读写的内存编制，需要传送的数据长度、是否请求读写等信息<br>当DMA和CPU在总线上冲突时，CPU会稍微等待一下<br>因为CPU的处理速度远远超过数据的输入输出速度，不可能在键盘敲下一个键就执行一次指令，这样大大浪费了CPU的速度，所以采用<strong>设立缓冲区</strong>的方法输入一定量的数据后再一次性传送给CPU</p><h4 id="时钟部件"><a href="#时钟部件" class="headerlink" title="时钟部件"></a>时钟部件</h4><p>计算机系统中时间部件是必要的，可以为系统发现一个死循环的程序，实现分时和实时系统、定时唤醒事先给定的外部事件、记录用户使用设备的时间和事件发生间隔以及记录绝对时间年月日等<br>时间部件一般分为硬件时钟和软件时钟，硬件则是利用电路中的晶体震荡器，每隔一段时间激发出一个频率的脉冲，时钟寄存器就不停对这个电路执行+1的操作，当计算机关机时，利用纽扣电池仍然在不停计时；软件则是利用程序来进行计时，系统需要同步硬件和软件时钟，绝对时间是执行+1操作，而相对时间执行-1操作（即倒计时）</p><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><h4 id="中断与异常的概念"><a href="#中断与异常的概念" class="headerlink" title="中断与异常的概念"></a>中断与异常的概念</h4><p><strong>中断</strong><br>CPU对系统内外发生的异步事件的响应即中断，异步事件指无一定顺序关系随机发生的事件；中断时实际意义是发生了异步事件后CPU中断当前程序转而处理异步事件，处理完后再回来执行先前的程序；几种名词的解释：<br>中断事件/中断源-引起中断的事件<br>中断请求-中断源向CPU发出的请求信号<br>中断处理程序-处理中断事件的程序<br>中断断点-原先程序的暂停点<br>中断响应-CPU暂停原先程序去处理中断的<em>过程</em><br>中断返回-处理结束后恢复原先程序的执行<br>中断字-计算机系统提供的中断源的有序集合，存在逻辑结构，不同处理器有不同的实现方式，Intel的x86处理器能处理256种中断<br>中断向量表-表中的每一项称为一个中断向量，主要有PSW和指令计数器PC组成，不同性质的中断源有不同的PSW和PC，通过此表找到相应的中断处理程序<br>中断技术的应用使得CPU运行效率提高，不用到处询问是否有事件发生，只要等待中断并且处理<br><strong>异常</strong><br>中断和异常的差别主要在中断是由外部事件引发的，而异常指由正在执行的指令引发的<br>中断的分类<br>时钟中断-按一定函数中断事件寄存器<br>输入输出（I/O）中断-硬件完成使用或期间引发的错误<br>控制台中断-操作员通过控制台发出命令<br>硬件故障中断-如断电存储器校验错误等<br>异常的分类<br>程序性中断-如溢出，除零，目态试图使用特权指令，访问不存在的目录等<br>访管指令异常-要求操作系统提供系统服务等</p><h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p>中断系统分为两个部分<br>硬件中断装置-负责捕获中断源发出的中断请求，以一定方式响应中断源，然后将处理器的权限转接给软件中断程序<br>软件中断程序-根据中断事件的性质执行相应的操作<br>请求的接收基本原理是通过中断逻辑线路接受并寄存到硬件触发器中，中断寄存器中包含了多种中断位，每一个中断位对应一种中断源<br>相应的具体过程是处理器接收中断信号→保护现场，将中断断点的PSW和PC存入系统堆栈→分析接收的中断向量，取得中断处理程序的地址→将CPU的PC设为此地址→调用中断处理程序→处理完后恢复现场原有程序继续运行<br>几种典型的中断处理<br>I/O中断-设备的唤醒和结束都会引发一次中断，多次引发会判断为设备故障通知管理员<br>时钟中断-控制定时任务和进程的处理器时间配额、处理器调度、维护软件时钟和实时处理<br>硬件故障中断-硬件问题引发的中断<br>程序性中断-指令出错、越权或越界而引发的系统保护；程序性中断可由系统完成也可以由程序自己完成<br>系统服务请求（自愿性中断）</p><h4 id="中断优先级、中断屏蔽和中断嵌套"><a href="#中断优先级、中断屏蔽和中断嵌套" class="headerlink" title="中断优先级、中断屏蔽和中断嵌套"></a>中断优先级、中断屏蔽和中断嵌套</h4><p>优先级-连接在不同的<strong>中断请求线</strong>上的中断信号，表示它们有不同的中断级别，硬件就决定了各个中断的优先级；例如电池即将没电，这类中断的优先级高于大多数中断；若同级中断有两种优先方法：一是硬件固定的优先数；二是轮转法<br>屏蔽-有些情况下一个中断在执行的时候，处于它级别低或者不会发生的中断都会被屏蔽；还有一类不可屏蔽的中断信号，屏蔽由卸载PSW中的中断屏蔽位中<br>嵌套-处理器在处理一个中断程序时又接收到一个中断信号时会有两种响应方式：<br>一是上述的中断屏蔽-新来的中断级别低于或相等于现在处理的中断等级<br>二就是中断嵌套；新来的中断级别高度现处理的中断，会类似递归一般在上个中断中再进行一次中断处理，处理过程和一般情况无异</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用时系统提供给用户访问特权指令的<strong>唯一接口</strong>，通过调用把CPU从目态切换至管态</p><h4 id="系统调用和函数调用的区别"><a href="#系统调用和函数调用的区别" class="headerlink" title="系统调用和函数调用的区别"></a>系统调用和函数调用的区别</h4><p>函数调用下-调用程序和被调用程序都运行在目态；系统调用下-调用程序在目态，而被调用程序在管态<br>因为不同调用运行在不同的状态，所以系统调用下的调用程序不能<strong>被</strong>调用，需要通过中断切换状态<br>系统调用也可以嵌套调用，不过嵌套的深度各有区别</p><h4 id="系统调用的分类"><a href="#系统调用的分类" class="headerlink" title="系统调用的分类"></a>系统调用的分类</h4><p>进程控制类-创建和终止<strong>进程的系统调用、获得和设置进程属性</strong>的系统调用<br>文件操作类-创建、打开、关闭和读写文件；创建目录以及移动文件的读写指针、改变文件的属性等<br>进程通信类-用于进程间传递信息和信号<br>设备管理类-用于请求和释放有关设备，以及启动设备操作等<br>信息维护类-用于获得当前时间和日期、设置文件访问和修改时间、了解当前用户数、系统版本号、空闲的内存磁盘等信息</p><h4 id="与库函数、API、内核函数的关系"><a href="#与库函数、API、内核函数的关系" class="headerlink" title="与库函数、API、内核函数的关系"></a>与库函数、API、内核函数的关系</h4><p>以库函数、API和内核函数为接口使用户能够调用特权指令</p><h4 id="系统调用的处理过程"><a href="#系统调用的处理过程" class="headerlink" title="系统调用的处理过程"></a>系统调用的处理过程</h4><p>与中断类似，不过这个过程称为陷入<br>当处理器执行到陷入指令时，首先调用中断，通过中断向量表把控制权交给系统调用总入口程序，该程序会进行现场保护和数据存入堆栈等操作，然后再查看<strong>系统调用表</strong>把控制权移交给相应的系统调用畜栏里例程或内核函数，执行完后恢复现场并返回用户程序</p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><h4 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h4><p>程序是指在一个时间上按严格次序前后相继的<strong>操作序列</strong>，程序的顺序执行有如下特点<br>顺序性-程序所规定的动作再机器上严格地按顺序执行。每个动作的执行都以前一个动作的结束为前提<br>封闭性-程序运行后的计算结果只和程序自己有关，不受外界影响<br>执行结果的确定性-程序执行的结果和执行时间无关，中断不会影响结果<br>执行结果的可再现性-只要输入的初始条件相同，不论运行多少次结果都是一样的</p><h4 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h4><p>资源的共享和竞争存在于多道程序的并发中，从而制约了各道程序的执行速度；并发程序会出现“执行-暂停-执行”的活动现象<br>程序与计算不再一一对应，一个编译程序可为几个用户提供编译服务<br>执行结果不可重现-并发执行的结果会因为多道程序之间的相互制约关系导致不确定<br>程序的并发和并行执行与第一章的说法相同，并发为宏观，并行为微观</p><h4 id="多道程序设计-1"><a href="#多道程序设计-1" class="headerlink" title="多道程序设计"></a>多道程序设计</h4><p>与先前提到的一样，是为了减少设备的空转提高利用率采用多道程序设计，举一个例子<br>程序A的执行顺序为：CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)，共40s<br>程序B的执行顺序为：设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)，共40s</p><p>若是<strong>顺序执行</strong>则肯定要么先执行A后执行B，要么先B后A<br>所以执行情况为【CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)】→【设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)】，共80s<br>CPU、设备1和设备2的利用率分别为50%、18.75%和31.25%<br><strong>并发执行</strong>时为<br> CPU(10s)   →设备1(5s)        →CPU(5s)   →      设备2(10s)   →CPU(10s)<br>设备2(10s)  →     CPU(10s)    →设备1(5s) →CPU(5s)            →设备2(10s)<br>共45s，CPU、设备1和设备2的利用率分别为89%、33%和56%</p><p>特点：目的是提高整个系统的效率，提高系统吞吐量（指单位时间内系统处理的进程的道数）<br>拥有<strong>独立性</strong>、<strong>随机性</strong>和<strong>资源共享性</strong>等特征；缺点是在某些情况下延长了程序的执行时间，如上面的例子，程序A本可以40s内执行完，应用在多道技术后延长至45s，在特定的程序内这5s是非常致命的</p><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>进程是具有<strong>一定独立功能的程序</strong>在某个数据集合上的一次<strong>运行活动</strong>，是系统进行资源分配和调度的一个<strong>独立单位</strong><br>进程由<strong>程序</strong>、<strong>数据</strong>和<strong>进程控制块（PCB）</strong>三部分组成；程序是静态的、线程是动态的；线程为了程序而存在；进程也可以创建进程，被创建的叫子进程，创建者叫父进程<br>一个能被多个用户同时调用的程序称作<strong>可再入的程序</strong>，此程序在执行过程中不会修改自身的代码；现代的操作系统和编译程序都属于可再入程序<br>进程的几个特性<br>并发性-进程的第一个动作可以在上一个进程最后一个动作之前开始<br>动态性-进程有生命周期，状态不断在发生变化<br>独立性-进程是一个相对完整的资源分配单位<br>交往性-一个进程在运行过程中可能和其他进程发生直接或间接的相互作用<br>异步性-每个程序按照各自独立的、不可预知的速度往前推进<br>结构性-由程序、数据和进程控制块组成</p><h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><p><strong>三状态模型</strong><br>此模型下的进程可以有以下三种状态之一，在任何时刻，任何进程都处于且仅处于三种状态之一<br>运行-进程已经获得处理器，并在处理器上执行的状态；在分时操作系统中，正在运行的程序的时间片使用完后会发出中断请求并将进程转为就绪或等待状态<br>就绪-已经具备运行条件，但还没有空闲的处理器分配给他，当处理器空闲时会根据调度算法把处理器分配给其中一个就绪的进程<br>等待-进程因为等待某个时间而暂时不能运行的状态，当事件结束时转为就绪状态等待分配处理器<br><strong>五状态模型</strong><br>运行-进程占用完CPU的资源，道数≤CPU数量；通常没有其他进程执行时（如所有进程都在阻塞状态），会自动执行空闲进程<br>就绪-与上述一致，I/O设备会排入高级优先队列<br>阻塞-进程等待I/O操作或进程同步等条件而暂停运行，条件满足前即使分配了处理器也无法运行，排成一个阻塞队列<br>创建-在此状态的工作有分配和建立进程控制块表项、建立资源表格并分配资源，加载程序并建立地址空间等；<em>创建至就绪称为提交</em><br>结束-进程结束后回收<strong>除进程控制块</strong>之外的其他资源，并让其他进程从进程控制块中收集有关信息；<em>运行至结束称为释放</em><br><strong>七状态模型</strong><br>七状态模型区分内外存<br>就绪、阻塞、创建、退出（结束）-一致<br>阻塞挂起-进程在外存并等待时间出现；<em>阻塞至阻塞挂起：没有就绪进程或就绪进程需要更多内存资源</em><br>就绪挂起-进程在外存，但只要进入内存即可运行；<em>就绪至就绪挂起：高优先级阻塞进入低优先级就绪时会就绪挂起；运行到就绪挂起：与前面一致，不过对象时在运行的进程</em><br>挂起-把进程从内存转到外存<br>激活-把进程从外存转入内存</p><h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>PCB是进程重要的组成部分，它包含<strong>调度信息</strong>和<strong>现场信息</strong>两部分<br>调度信息中包括了进程号和进程名-作用是标识一个进程，每个进程号都是唯一的<br>地址信息空间-记录了系统为每个进程分配的一个地址空间<br>优先级-确定的优先级信息<br>当前状态-表明是现在是就绪、等待还是运行状态<br>资源清单-包含了进程执行所需的资源<br>“家族”关系-包含了其父进程和子进程关系<br>消息队列指针-表明进程所属的消息队列所在的地址，消息队列的作用是与其他进程进行通讯<br>进程队列指针-指出现在进程所在队列的位置<br>当前打开文件-记录进程使用文件的情况<br>PCB大致有三种组织方式<br>线性-将所有PCB组织在一个连续表上，简单不需要额外开销，缺点是找一个PCB时需要遍历整个表<br>索引-对具有相同状态的线程，分别设置PCB表，表目是每个PCB的地址，就构成了索引表和被索引表<br>链接-对相同状态线程-利用PCB中的链接字构成队列，链接字指出PCB在表中的编号，与索引类似<br>进程的队列根据状态分为就绪队列、等待队列和运行队列<br>队列的具体组成和链表类似，都是利用单向或双向指针来进行索引，当然在表头有一个头指针；线程的出/入队操作都和链表的操作集合一样</p><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>进程状态的切换具体是由<strong>原语</strong>进行实现的，原语是系统的核心功能，运作在管态，常驻于内存；原语和系统调用都可被进程调用，不过原语有<strong>不可中断</strong>的特性<br>用于进程控制的原语有：<br>创建原语-可以创建一个进程并构造父子关系；其主要任务是申请一块空闲的PCB区域，然后将信息填入PCB，置该进程于就绪状态插入队列<br>撤销原语-进程完成后释放资源并撤销PCB；具体过程是找到该PCB的位置后移出队列，撤销它的所有子孙队列，释放全部资源，最后撤销PCB<br>阻塞原语-执行I/O操作，将运行换至阻塞；过程是中断处理器的执行，保存PCB的现场信息，将进程状态切换并置入等待队列<br>唤醒原语-等待事件的进程用唤醒原语转换至就绪状态；在队列中找到PCB，切换状态，然后从等待队列出队置入就绪队列</p><h4 id="实例：Unix操作系统的进程创建操作fork"><a href="#实例：Unix操作系统的进程创建操作fork" class="headerlink" title="实例：Unix操作系统的进程创建操作fork"></a>实例：Unix操作系统的进程创建操作fork</h4><p>待补充</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>为了减少程序并发执行所付出的时间和空间的开销，人们引入了线程的概念。线程是进程中的一个实体，是处理器调度和分派的<strong>基本单位</strong>，线程基本不拥有资源，只占有必须的少量资源，但他可以使用所处进程下的所有资源。<br>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程可以并发执行，同样有就绪、等待和运行三种状态。<br>线程有以下属性：<br>1.每个线程为一个唯一的标识符和一张线程描述表，记录了线程执行的寄存器以及栈等现场状态<br>2.不同的线程可以执行相同的程序，也就是同一个服务被不同用户调用时创建两个不同的线程<br>3.同进程中的各个线程共享进程的内存空间<br>4.线程是CPU的基本调度单位，可以并发执行；单核可交替占用处理器，多核多线程可占用不同的处理器，若多个核心为一个进程运算，那么会减少计算时间<br>5.线程在创建后拥有一个生命周期，周期内会经历就绪、等待和运行多种状态的切换，直至周期终止<br>引入线程的好处：<br>1.创建新线程所需要的时间少，而且不必重新分配资源<br>2.线程相互切换所需的时间少<br>3.因同进程内的线程共享内存空间，所以线程之间交换数据不必调用内核，效率更高<br>4.线程能独立运行，能充分发挥处理器和io设备的并行工作能力</p><h4 id="线程的实现机制"><a href="#线程的实现机制" class="headerlink" title="线程的实现机制"></a>线程的实现机制</h4><p>用户级线程：<br>只存在于用户态中，对其的创建、撤销和切换都<strong>不会</strong>通过系统调用来实现。优点是有些操作系统不支持线程，但因为这种线程存在于目态，也可以用函数库实现线程<br><strong>线程表</strong>：用来跟踪该进程中的线程，和PCB类似，不过仅仅记录各个线程的属性，如程序计数器、堆栈指针、寄存器和状态等。当一个线程转换到就绪或者阻塞时，就在表中存放重新启动该线程时所需要的信息。<br>内核级线程:<br>内核级和用户级的区别基本上在于进程中的线程表分别存放在核心态和用户态，内核级线程的切换效率会稍低些<br>混合实现方式：<br>一些系统混合使用了用户级和内核级线程，实例P99</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>实际情况下，进程的数量是多于处理器数量的，如何做好调度是关键</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>根据一定的调度算法，在就绪队列中选出一个进程将PCB中相关信息放入寄存器中，并分配处理器运行。<br>调度的时机一般有：<br>正在执行的进程运行完毕<br>正在执行的进程因某种错误终止<br>时间片用完，进程从运行转为就绪状态<br>正在执行的进程用阻塞原语将自己阻塞起来<br>创建了新进程进入了就绪队列<br>正在执行的进程用唤醒原语激活了等待队列的进程使其归入就绪队列</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>进程行为</p><h3 id="进程间相互作用"><a href="#进程间相互作用" class="headerlink" title="进程间相互作用"></a>进程间相互作用</h3><h4 id="相关进程和无关进程"><a href="#相关进程和无关进程" class="headerlink" title="相关进程和无关进程"></a>相关进程和无关进程</h4><p>有逻辑相关的即相关进程，无关进程同理，并发的进程间不一定有逻辑关系</p><h4 id="与时间有关的错误"><a href="#与时间有关的错误" class="headerlink" title="与时间有关的错误"></a>与时间有关的错误</h4><p>例如两个不同的程序运行，它们都共同使用的一个名为”n”的变量，因为两个程序是在交替运行的，使用同一个变量很容易发成错误，这类错误统称与时间有关的错误。</p><h3 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h3><h4 id="同步关系"><a href="#同步关系" class="headerlink" title="同步关系"></a>同步关系</h4><p>为了完成某种工作，进程间经常需要合作。例如一批数据记录需要加工处理，为此创建两个进程，还设置了容量为一个记录单位的缓冲器。进程A在硬盘上读取记录，每读出一个记录就存入缓冲区，进程B从缓冲区内取出数据加工，直到所有记录都处理完毕<br>当然它们是在并发运行，而且在同时使用缓冲区，如果不对它们进行制约就会发生冲突，运行速度也是关键，若A的速度比B快，则有可能丢失数据等错误发生，所以协调它们的节奏非常重要</p><h4 id="互斥关系"><a href="#互斥关系" class="headerlink" title="互斥关系"></a>互斥关系</h4><p>与前文相同，试图调用如打印机等单一访问的设备时应该要产生互斥</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>系统中的某些资源一次只允许一个进程访问，则这类资源称为<strong>临界资源或共享变量</strong>而在进程中访问临界资源的程序称为<strong>临界区</strong><br>系统对临界区的调度使用原则归纳如下：<br>1.临界区为空时，有一个进程要求访问应立即允许其进入<strong>有空让进</strong><br>2.有一个进程处于临界区时，其他请求进入的进程必须等待<strong>无空等待</strong><br>3.临界区空闲，而多个进程请求访问时只允许其中一个进入，其他的必须等待<strong>多种择一</strong><br>4.任一进程进入临界区的要求应在有限的时间内完成<strong>有限等待</strong><br>5.处于等待状态下的进程应主动放弃CPU<strong>让权等待</strong><br>1表示要有效利用临界资源；2反映了互斥的含义，资源具有排他性；3是1和2的一个特殊情况；4、5是为了避免进程间发生忙等待或死锁</p><h3 id="信号量与P、V操作"><a href="#信号量与P、V操作" class="headerlink" title="信号量与P、V操作"></a>信号量与P、V操作</h3><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是种特殊的变量，它的表面形式是<strong>一个整形变量加一个队列</strong>，并且只能被P、V操作使用，P、V操作都是原语（P是荷兰语”等待”的首字母，而V是”发信号”的首字母）。</p><h4 id="P、V操作"><a href="#P、V操作" class="headerlink" title="P、V操作"></a>P、V操作</h4><p>定义如下<br>P(S)<br>{<br>    S = S-1;<br>}<br>若S&lt;0，将该进程状态置为等待，然后再PCB中插入响应的S信号量等待队列末尾，直到其他进程再S上执行V操作<br>V(S)<br>{<br>    S = S+1;<br>}<br>若S≤0，释放再S信号量队列中等待的一个进程，将其状态改变为就绪态，并将其插入就绪队列；然后执行本操作的进程继续执行；<br>S即表示某类可用的临界资源，当S&gt;0时表示该类资源可以分配，S&lt;0时表示没有可分配的资源数量，其<strong>S的绝对值表示排在S信号量的等待队列中进程的数目</strong><br>每执行一次P操作，意味请求的进程分配到一个资源，每执行一次V操作，意味该进程释放了一个资源</p><h4 id="用P、V操作实现进程间的互斥"><a href="#用P、V操作实现进程间的互斥" class="headerlink" title="用P、V操作实现进程间的互斥"></a>用P、V操作实现进程间的互斥</h4><p>S = 1<br>进程A、B都执行：<br>P(S);<br>    operation;<br>V(S);</p><h4 id="用P、V操作实现进程间的同步"><a href="#用P、V操作实现进程间的同步" class="headerlink" title="用P、V操作实现进程间的同步"></a>用P、V操作实现进程间的同步</h4><p>例如存在两个信号量S1与S2<br>赋值为 S1 = S2 = 0    //S1表示在一个缓冲区内是否装满信息，S2表示该区中的信息是否取走<br>程序A<br>while(true){<br>    msginput;<br>    V(S1);<br>    P(S2);<br>};</p><p>程序B<br>while(true){<br>    P(S1);<br>    msgoutput;<br>    V(S2);<br>};<br>因为程序的交替执行，可以看出A先将信息放入缓冲区然后释放它，随后切换到B请求并取出，然后再检查缓冲区，如此循环<br>三进程或以上的情况见P118附图</p><h4 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h4><p>一、简单消费者问题<br>二、多个消费者问题<br>三、读写机制问题<br>四、综合应用-路口单双号交通管制<br>五、物流系统物品分拣问题</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>单纯使用PV操作有诸多问题，于是引入管程的概念；<br>管程的四个部分为管程名称、共享数据说明、对数据操作的一组过程和对共享数据赋初值的语句；类似面对对象程序语音中的类，定义了其中的初始属性和方法(函数)<br>管程主要有三个特性：<br>1.模块化，管程时一个基本程序单位，可单独编译<br>2.抽象数据类型，管程是一种特殊的数据类型，不仅有数据，而且有对数据进行操作的代码<br>3.信息隐蔽，管程是半透明的，他能实现某种功能，但具体的实现方式外部并不知道也没有必要知道</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_Note</title>
      <link href="/2019/07/23/Python-Note/"/>
      <url>/2019/07/23/Python-Note/</url>
      
        <content type="html"><![CDATA[<h3 id="与C语言的一些区别"><a href="#与C语言的一些区别" class="headerlink" title="与C语言的一些区别"></a>与C语言的一些区别</h3><p>代码<strong>行首</strong>不要随意插入空格，空格在python中具有缩进含义<br>    缩进在python中表示的是程序的分割<br>    C中是用大括号{}来分割程序,如:<br>    <pre><code>for(int i=0;i&lt;=10;i++){   printf(&quot;Hello World!\n&quot;);   printf(&quot;%d\n&quot;,1+2);}</code></pre><br>    而python中仅仅用缩进表示,如:<br>    <pre><code>for i in range(10)    print(&quot;Hello World!\n&quot;) print(i)#若代码为,如:for i in range(10)    print(&quot;Hello World!\n&quot;) print(i) </code></pre><br>则此时print(i)就不属于for循环中的代码<br>以及一行命令结束后不必用分号声明结束<br>同样是中文字符会报错</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>-#为行注释<br>-‘’’此为<br>段注释<br>以三个分号来声明<br>‘’’</p><h3 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h3><p>变量在声明和定义时不用有类似于int char等数据类型声明，直接将对象的地址赋值给变量如a = 1<br>python中可以删除变量，进行<br>    del a<br>的操作后将a从栈中删除，变量是存储在栈中的，而对象”1”则是存储在堆中的，将a删除后对象”1”仍然存在，但没人使用后会被垃圾回收器删除(删除的实际时间待补充)<br>和c相同可以采用链式赋值法<br>    如 a=b=22<br>这样a和b的值都是22<br>注意，声明变量时，值为[-5，256]区间内的值会被python解释器缓存起来，这样不论时什么变量指向这个对象，都是同一个对象，并不是生成一个新的对象。可用is()  is not()函数验证，这两个函数分别判断两个标识符是否为一个对象和是否不是为一个对象<br>也可采用解包赋值，形如<br>    a,b = b,a<br>意味着a和b的变量互换了，不必在代码中加一个中间变量temp参与互换<br>同时注意，<strong>Python不支持常量</strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>+、-、<em>和c语言相同<br>但由于Python不声明数据类型，所以在除法上有区别<br>如a = 2/3采用浮点计算，就是会将得出的结果保留小数，和float数据类型一样，此时a=0.66..67<br>若采用a = 2//3就是采用整型计算，意味着不保留小数，此时a=0<br>%同样为取模(余数)，但注意+、-、</em>的两者分别是整型和浮点型时默认为浮点型数据计算<br>双星号为幂</p><pre><code>a = 2**3 #**</code></pre><p>就是2的三次方，此时a=8<br>关于科学计数法如3.14就表示为”314E-2”，意为314×10^(-2)<br>注意双斜杠’//‘在C语言中表示注释，在Python中表示整型除法计算</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>python中没有单个字符的概念，只有字符串或者是单个字符的字符串<br>在声明字符串的时候既可以用单引号，也可用双引号<br>形如a = “abc”  a = ‘abc’  都是合法的，这样子可以对一个字符串中同时出现单引号和双引号的情况作临时的解决，并且字符串中支持换行，只要连续三个单引号或双引号就可以在中间换行。<br>例如a = ‘’’abc<br>def<br>“ghi”’’’<br>合法，中间有双引号时也不会冲突，如果还有冲突，就使用转移字符/‘和/“来解决<br>对于字符串也可以使用+、-、<em>来操作，但要注意，+、-时两者必须同为字符串</em><br>在使用print()函数时可采用加一个end来改变要增加的字符(默认为\n)<br>例如 print(“abc”,end=”\t”)<br>在python中使用input()函数来输入</p><pre><code>&gt;&gt;&gt; name=input(&quot;please input your name:&quot;)please input your name:soya&gt;&gt;&gt; print(&quot;Hello，&quot;+name)Hello，soya</code></pre><p>同样可以利用str()函数把数字、布尔值等转为字符串<br>类似于数组的下标，字符串也有索引，和下标相同，正向时是从0开始，但Python还可以使用反向搜索</p><pre><code>&gt;&gt;&gt; c = &quot;asdfbd&quot;&gt;&gt;&gt; c[0]&#39;a&#39;&gt;&gt;&gt; c[-1]   #从-1开始倒数就是从最后一个字符到第一个字符，注意不是0开始&#39;d&#39;字符串替换&gt;&gt;&gt; c.replace(&quot;a&quot;,&quot;5&quot;)&#39;5sdfbd&#39;&gt;&gt;&gt; c&#39;asdfbd&#39;    #这里意为着是创建了一个新的对象，但如果没有指向一个变量那就不会被引用&gt;&gt;&gt; c=c.replace(&quot;a&quot;,&quot;5&quot;)    #此为利用原来的变量重新指向新创建的字符串&gt;&gt;&gt; c&#39;5sdfbd&#39;提取字符串中的部分字符&gt;&gt;&gt; c[1:5]    #意为着从下标1&#39;s&#39;开始提取到下标5&#39;d&#39;之间的字符，注意不包含第五个(超出)&#39;sdfb&#39;&gt;&gt;&gt; c[:]    #提取全部字符&#39;5sdfbd&#39;&gt;&gt;&gt; c[0:5:2]    #第三个参数表示步长，2表示隔一个提取一个(每两个提取一个)&#39;5db&#39;&gt;&gt;&gt; c[::-1]    #表示每隔-1个提取一个(可以理解为每隔一个提取一个，但是是倒序提取)&#39;dbfds5&#39;</code></pre><h3 id="列表、元组、字典"><a href="#列表、元组、字典" class="headerlink" title="列表、元组、字典"></a>列表、元组、字典</h3><p>三者的创建有一些区别</p><pre><code>&gt;&gt;&gt; a = [ 10, 20, 30]  #列表方括号，或以list()创建&gt;&gt;&gt; b = ( 10, 20, 30)  #元组小括号，或以tuple()创建&gt;&gt;&gt; c = { &quot;one&quot;:10, &quot;two&quot;:20, &quot;three&quot;:30}  #字典花括号，或以dict()创建</code></pre><p>三者的操作集合在需要使用的时候再查询，不必背诵<br>变量段落中的解包赋值对它们同样有效<br>三者都可以通过推导式来生成，即在声明的时候加入循环，运算和筛选，例</p><pre><code>y = [x*2 for x in range(1,5) if x%2==0]   #意为生成一个1-4的列表，随后筛选出能被2整除的数，最后乘2得出最后的列表&gt;&gt;&gt; [4,8]#*</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>while()和for()循环都和C类似，有几个新特性值得记下来。<br>python中循环也可以加else判断，条件是循环没有被break中断的就执行else语句(即正常结束循环就执行)<br>for循环中可以使用zip()函数达到几个列表并列循环的效果<br>例如</p><pre><code>a = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]b = [1,2,3]c = [&quot;!&quot;,&quot;@&quot;]for a1,b1,c1 in zip(a,b,c):    #前面的名字和列表名字不能相同，与变量i同理    print(&quot;{0},{1},{2}&quot;.format(a1,b1,c1))&gt;&gt;&gt; A,1,!B,2,@</code></pre><p>需要理解的是for在python中不仅仅是循环，而是更接近于“遍历”，所以不必局限于循环次数，而是根据列表来进行遍历，这里意味着同时对a，b，c进行遍历。要注意，当次数不相同时按最短列表遍历次数，如例子中a，和b的长度都是3，c是2，就循环两次</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与C相同，函数的返回值只能返回一个。但不同的是，python可以返回一个对象，这意味着能把多个值放在列表中返回，以达到返回多个值的效果(但本质还是只返回一个对象)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言100题相关解题思路(部分)</title>
      <link href="/2019/07/22/Frist-Artical/"/>
      <url>/2019/07/22/Frist-Artical/</url>
      
        <content type="html"><![CDATA[<h3 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h3><p><strong>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</strong><br>该题的关键在于兔子的数量符合<strong>斐波那契数列</strong>-即第n位数等于n-1位和n-2位数相加。同样是通过相互赋值的方法改变相加数的位置。<br>例如1+1=2视为x+y=z，下一次计算应该为1+2=3，则相当于把y值当成新的x，把z看成新的y<br>即x+y=z<br>    x+y=z<br>相关代码</p><pre><code>printf(&quot;%d\n&quot;,y*2); &#x2F;&#x2F;打印出第一位数，乘二是因为一对兔子为两只for(i=0;i&lt;30;i++){    z=x+y;    printf(&quot;%d\n&quot;,z*2); &#x2F;&#x2F;注意先打印后赋值    x=y;    y=z;}</code></pre><h3 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h3><p><strong>判断101-200之间有多少个素数，并输出所有素数。</strong><br><strong>素数</strong>-指除了自身和1外，不能被其他数整除的数。主要是用两个for循环嵌套，首先循环查找的范围，然后循环查找的条件，查找条件比较简单，把被判断数从2除到201，每被整除就标记一次，不能被整除的就continue结束。除完之后查看标记的次数，根据素数的特性，凡是标记次数小于2的就输出概述，并另标记打印的次数(即说明找到了一个素数)。<br>相关代码</p><pre><code>int a=101,b,c,e=0;for(;a&lt;201;a++){    c=0; &#x2F;&#x2F;初始化整除标记为0；    for(b=2;b &lt; a+1 ;b++) &#x2F;&#x2F;不检验被1整除，从2到a+1即可，若到a则测不到被自身整除    {        if(a%b==0) &#x2F;&#x2F;查找整除            c++; &#x2F;&#x2F;每整除一次就标记+1        else            continue; &#x2F;&#x2F;不能被整除就结束循环    }    if(c&lt;2) &#x2F;&#x2F;当数只整除一次时进入    {        e++; &#x2F;&#x2F;素数标记+1        printf(&quot;%d\n&quot;,a);    }}printf(&quot;e=%d\n&quot;,e); &#x2F;&#x2F;素数标记打印要放在所有循环外面</code></pre><h3 id="题目二十六"><a href="#题目二十六" class="headerlink" title="题目二十六"></a>题目二十六</h3><p><strong>利用递归方法求5!</strong><br>利用函数嵌套的递归算法，主要理清楚递归次数和值的关系，阶乘的关系如下<br>   函数递归的最终返回值<br>                 ↑ 值120返回<br>         【f(4) ×5】<br>             ↑ 值24返回<br>     【f(3) ×4】<br>         ↑ 值6返回<br>  【f(2)×3】<br>      ↑ 值2返回<br>【f(1)×2】<br>f(0)时返回1给f(1)；然后依次返回<br>相关代码</p><pre><code>int fact(int x);&#x2F;&#x2F;使用函数前需要提前声明int main(){    int a,b;    scanf(&quot;%d&quot;,&amp;a);&#x2F;&#x2F;将程序升级成阶乘计算器，输入数a，并计算a的阶乘    b=fact(a);    printf(&quot;%d\n&quot;,b);    return 0;}int fact(int x)&#x2F;&#x2F;函数定义{    int y;    if(x&gt;0)    {        x--;&#x2F;&#x2F;需要在递归前先进行条件变换，不然会造成递归死循环        y=fact(x)*(x+1);&#x2F;&#x2F;阶乘递归的关键，过程见上        return y;&#x2F;&#x2F;最后返回的y值    }    return 1;&#x2F;&#x2F;x==0时返回1值}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="题目四十一"><a href="#题目四十一" class="headerlink" title="题目四十一"></a>题目四十一</h3><p><strong>学习static定义静态变量的用法</strong><br>静态变量和普通的变量（即auto自动变量）的区别只有是否会自动释放内存。auto变量在函数调用结束的时候会自动释放，而static变量则不会释放，而是会一直存放在静态储存区，方便下次调用，适合类似求阶乘的算法，但这样的代价是内存得不到释放，同时降低了代码的可读性。<br>相关代码</p><pre><code>int main(){    int i;    for(i=0;i&lt;3;i++)        varer();}void varer(){    int var=0;    static int static_var=0;    printf(&quot;var=%d\n&quot;,var);    printf(&quot;static_var=%d\n&quot;,static_var);    var++;    static_var++;}</code></pre><p>程序执行后得到的值是<br>0 1<br>0 2<br>0 3<br>即auto变量var使用后释放，并再次赋值为0，而static_var不释放，一直自加到循环结束</p><h3 id="题目四十三"><a href="#题目四十三" class="headerlink" title="题目四十三"></a>题目四十三</h3><p><strong>学习使用static的另一用法。</strong><br>static变量和普通变量的另一区别就是储存的位置不同，内存供用户使用可分为三个部分<br>程序区、静态存储区和动态存储区。auto变量放在动态存储区，static变量放在静态存储区。<br>还有声明变量时不要放在同一层级即同一个花括号内<br>相关代码</p><pre><code>int i;for(i=0;i&lt;3;i++){    int num=2; &#x2F;&#x2F;auto变量在循环内外都可运行，在内每次都为2，在外则是递增    printf(&quot;auto num=%d\n&quot;,num);    num++;    &#x2F;&#x2F;若取消花括号会因为变量名相同而报错    {        static int num=1;        printf(&quot;static num=%d\n\n&quot;,num);        num++;    }    &#x2F;&#x2F;从static变量声明起至花括号结束，所有相关语句均只与static变量有关}</code></pre><p>相关代码2</p><pre><code>int var=0;{    var++; &#x2F;&#x2F;此时auto变量为1    static int var=10;    var++; &#x2F;&#x2F;static变量为11    var++; &#x2F;&#x2F;static变量为12    printf(&quot;-%d\n&quot;,var); &#x2F;&#x2F;打印static变量的var    var++; &#x2F;&#x2F;static变量为13，但不会打印出来}&#x2F;&#x2F;花括号结束，此时为auto变量var++; &#x2F;&#x2F;auto变量为2printf(&quot;%d\n&quot;,var);&#x2F;&#x2F;打印auto变量的var</code></pre><h3 id="题目六十六"><a href="#题目六十六" class="headerlink" title="题目六十六"></a>题目六十六</h3><p><strong>输入3个数a,b,c，按大小顺序输出，利用指针方法。</strong><br>运用指针分别指向a，b，c，然后像直接交换变量值一样交换指针地址就可以。<br>相关代码</p><pre><code>int main(){    int n1,n2,n3;    scanf(&quot;%d,%d,%d&quot;,&amp;n1,&amp;n2,&amp;n3);    int *p1,*p2,*p3;    p1=&amp;n1; &#x2F;&#x2F;依次把变量地址赋值给指针，注意给指针赋值时变量要带地址符&amp;，指针不用带*号    p2=&amp;n2;    p3=&amp;n3;    if(n1&gt;n2)        trans(p1,p2);&#x2F;&#x2F;为了方便创建一个函数，此处的排序是由小到大    if(n2&gt;n3)        trans(p2,p3);    if(n1&gt;n3)        trans(p1,p3);    printf(&quot;%d,%d,%d\n&quot;,n1,n2,n3);    return 0;}void trans(int *p1,int *p2){    int s;    s=*p1; &#x2F;&#x2F;除声明的时侯，*p1指的都是该指针指向变量的值，例如此时\*p1指向n1，相当于s=n1    *p1=*p2;    *p2=s;         &#x2F;&#x2F;若不加*号，即    &#x2F;&#x2F;s=p1;     &#x2F;&#x2F;p1=p2;     &#x2F;&#x2F;p2=s;    &#x2F;&#x2F;意味只交换了指针变量的值，即让p1指向n2，p2指向n1，这样子在打印n1、2、3时还是输入时的值}</code></pre><h3 id="题目六十七"><a href="#题目六十七" class="headerlink" title="题目六十七"></a>题目六十七</h3><p><strong>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</strong><br>题目意为创建一个数组，由用户自己输入，输入完成后查看数组中的值，其中最大的值与第一个元素交换，最小的值与最后一个元素交换，其他元素保持不变。<br>要求利用指针来完成。输入与输出函数没有什么好说的。关键是交换元素的时机与方法。<br>首先要定义储存最大和最小的元素的指针，以及一个检查指针。<br>第一步就是循环检查，用数组的第一个元素检查到最后一个元素，元素指针先指向第一个元素，检查指针可跳过第一个，因为max=min=p没有检查的必要。检查完成后就是交换元素，此时找到了max元素、min元素，以及p指针指向最后一个元素。此时就和先前的方法一致声明一个临时变量count来交换数值。不要直接用指针p来临时存储变量。这里要注意的是，当max指针和p指针同时指向最后一个元素时(即最后一个值最大)，改变p的值的同时也改变了max原本的变量。所以还是另外声明比较保险。<br>相关代码</p><pre><code>void max_min(int array[])&#x2F;&#x2F;貌似函数返回值默认为int值时可不用声明(待检验){    int *max,*min,*p;    int count;    max=min=array;    for(p=array+1;p&lt;=array+5;p++)&#x2F;&#x2F;单独数组名代表该数组的首地址，+5则代表数组下标为5的元素    {        if(*p&gt;*max)            max=p;        else if(*p&lt;*min)            min=p;    }    count=array[5];    array[5]=*min;    *min=count;    if(max!=array+5&amp;&amp;min!=array)    &#x2F;&#x2F;若数组是顺序的话，只交换头尾即可，所以检查max和min是否位于第一和最后一位    {        count=array[0];        array[0]=*max;        *max=count;    }}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="题目六十八"><a href="#题目六十八" class="headerlink" title="题目六十八"></a>题目六十八</h3><p><strong>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</strong><br>例如1，2，3，4，5；m=2，结果就是4，5，1，2，3；<br>主要思路还是和上题类似，要注意指针地址的变换。函数内只能用指针交换位置，具体见注释<br>相关代码</p><pre><code>int main(){    int a[5]={1,2,3,4,5};&#x2F;&#x2F;初始化数列    Move(a,2);&#x2F;&#x2F;用函数来完成，设定移动两位，可更改    for(int i=0;i&lt;5;i++)        printf(&quot;%d\t&quot;,a[i]);    printf(&quot;\n&quot;);    return 0;}void Move(int a[],int m){    int *R,*S,count;&#x2F;&#x2F;声明后指针和前指针以及临时变量    for(int i=0;i &lt; m;i++)    {        R=a+4;&#x2F;&#x2F;将后指针放在数组的最后一项        count=*R;&#x2F;&#x2F;同时将值赋给临时变量        for(int j=4;j&gt;0;j--)&#x2F;&#x2F;每次移动数组内部必定移动四次，要从后往前循环        {            S=a+(j-1);&#x2F;&#x2F;前指针依次向前移动            *R=*S;&#x2F;&#x2F;将前值赋给后值            R=S;&#x2F;&#x2F;后指针往前移，此时与前指针指向同一值        }        *S=count;&#x2F;&#x2F;数组内交换完后把临时变量(即原最后值)赋给前指针，此时前指针指向第一值    }}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="题目七十六"><a href="#题目七十六" class="headerlink" title="题目七十六"></a>题目七十六</h3><p><strong>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函1/1+1/3+…+1/n(利用函数指针)</strong><br>这题的主要关键是练习利用函数指针，与指针函数不同，指针函数是指一个返回值为指针的函数，而函数指针意为一个指向函数的指针，相当于深层次点的函数嵌套。首先是检测输入数的奇偶性，然后不论该数是奇数还是偶数都执行一个参数是指针的函数，不过要注意的是与数学不同，C语言中先执行的是外部的函数。<br>相关代码</p><pre><code>int main(){    float peven(),podd(),dcall();    float sum;    int n;    scanf(&quot;%d&quot;,&amp;n);    if(n%2==0)    {        printf(&quot;even=&quot;);        sum=dcall(peven,n);        &#x2F;&#x2F;函数声明在下面，这里先执行的是dcall函数，然后再执行参数中指向Peven函数的指针，下同    }    else    {        printf(&quot;odd=&quot;);        sum=dcall(podd,n);    }    printf(&quot;%f&quot;,sum);}float peven(int n){    float s;    int i;    s=1;    for(i=2;i&lt;=n;i+=2)        s+=1&#x2F;(float)i;    return(s);}float podd(int n){    float s;    int i;    s=0;    for(i=1;i&lt;=n;i+=2)        s+=1&#x2F;(float)i;    return(s);}float dcall(float (*fp)(),int n){    float s;    s=(*fp)(n);&#x2F;&#x2F;将指针指向的函数执行完后的返回值返回    return(s);}</code></pre><h3 id="题目一百"><a href="#题目一百" class="headerlink" title="题目一百"></a>题目一百</h3><p><strong>有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，况原有的数据和计算出的平均分数存放在磁盘文件”stud”中。</strong><br>难度不大，注意输入数据存储到结构体中的时候，即使是用指针指向的数据(即P-&gt;num)的形式，也要加地址符&amp;，因为这里的num依然是变量，而不是地址。<br>例如数组名本身代表数组的首地址，形如声明为</p><pre><code>char a[10];scanf(&quot;%c&quot;,a);&#x2F;&#x2F;合法scanf(&quot;%c&quot;,&amp;a[0]);&#x2F;&#x2F;合法scanf(&quot;%c&quot;,a[0]);&#x2F;&#x2F;不合法</code></pre><p>这里需要注意。<br>相关代码</p><pre><code>typedef struct S{    int num;    char name[10];    float scoreA;    float scoreB;    float scoreC;    float scoreADV;    struct S *NEXT;}SUT;&#x2F;&#x2F;此结构体前的typedef意为SUT等价于struct S*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突int main(){    SUT *HEAD,a,b,c,d,e,*P;    P=HEAD=&amp;a;    a.NEXT=&amp;b;    b.NEXT=NULL;    &#x2F;&#x2F;c.NEXT=&amp;d;  题目的要求为五个学生，但为了测试方便，故修改为两个    &#x2F;&#x2F;d.NEXT=&amp;e;    &#x2F;&#x2F;e.NEXT=NULL;    while(P!=NULL)    {        printf(&quot;please input number and name of the student:\n&quot;);        scanf(&quot;%d,%s&quot;,&amp;P-&gt;num,&amp;P-&gt;name);        &#x2F;&#x2F;注意地址符，详细见上，此处还要注意%s要写在最后，这样避免把‘，’算成字符造成错误，下同        printf(&quot;please input three score:\n&quot;);        scanf(&quot;%f,%f,%f&quot;,&amp;P-&gt;scoreA,&amp;P-&gt;scoreB,&amp;P-&gt;scoreC);        P-&gt;scoreADV=(P-&gt;scoreA+P-&gt;scoreB+P-&gt;scoreC)&#x2F;3;&#x2F;&#x2F;直接计算并存储平均成绩        P=P-&gt;NEXT;    }    P=HEAD;    FILE *F;    F=fopen(&quot;student&quot;,&quot;w&quot;);    while(P!=NULL)    {        fprintf(F,&quot;%d-%s\n&quot;,P-&gt;num,P-&gt;name);        fprintf(F,&quot;A=%.2f,B=%.2f,C=%.2f,ADV=%.2f\n&quot;,P-&gt;scoreA,P-&gt;scoreB,P-&gt;scoreC,P-&gt;scoreADV);        P=P-&gt;NEXT;    }    fclose(F);    return 0;}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="关于函数的实参和形参，以及指针作为参数时的情况"><a href="#关于函数的实参和形参，以及指针作为参数时的情况" class="headerlink" title="关于函数的实参和形参，以及指针作为参数时的情况"></a>关于函数的实参和形参，以及指针作为参数时的情况</h3><p>在声明一个函数时<br>例如：</p><pre><code>int Function(int a, int b);</code></pre><p>此时function函数中的a和b为形参</p><p>在主函数中</p><pre><code>int main(){    int Ra,Rb;    Ra=1;    Rb=2;    Function(Ra,Rb);    return 0;}</code></pre><p>此时主函数中的Ra和Rb为实参<br>需要注意的是形参在函数中的运算不会影响实参的值</p><p>而指针作为参数的时候有点特殊，如果直接写成</p><pre><code>int Function(int *a, int b);</code></pre><p>主函数中</p><pre><code>int main(){    int *Ra;    int Rb;    Rb=2;    Function(Ra,Rb);    return 0;}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><p>此时指针Ra同样不会因为函数中的指针a变化而变化。</p><blockquote><p>在初始化操作前，头指针参数head没有具体的地址值，在初始化操作前，头指针参数head才得到了具体的地址值，而这个地址值要返回给调用函数，所以，此时头指针参数head要设计成指针的指针类型。如果此时头指针参数head设计成指针类型，那么调用函数将无法得到在初始化函数中被赋值的头指针参数head的数值。</p><footer><strong>朱战立 数据结构—使用C语言</strong></footer></blockquote><p>总结就是作为参数形参不能影响实参，但是只要将指针的地址作为参数直接修改地址就可以影响主函数中指针参数的所指向的地址。</p><p>参考文档：<a href="https://www.jianshu.com/p/56d99a3049a5" target="_blank" rel="noopener">https://www.jianshu.com/p/56d99a3049a5</a><br>Sina博客原稿：<a href="http://blog.sina.com.cn/u/2292464751" target="_blank" rel="noopener">http://blog.sina.com.cn/u/2292464751</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读笔记</title>
      <link href="/2018/10/19/ReadNote/"/>
      <url>/2018/10/19/ReadNote/</url>
      
        <content type="html"><![CDATA[<h3 id="《上帝掷骰子吗》-2019-07-10"><a href="#《上帝掷骰子吗》-2019-07-10" class="headerlink" title="《上帝掷骰子吗》-2019-07-10"></a>《上帝掷骰子吗》-2019-07-10</h3><p>但是，统一以后呢？是不是一切都大功告成了？物理学是不是又走到了它的尽头，再没有更多的发现可以作出了？我们的后代是不是将再一次陷入无事可做的境地，除了修正几个常数在小数点后若干位的值而已？或者，在未来的某一天，地平线上又会出现小小的乌云，带来又一场迅猛的狂风暴雨，把我们的知识体系再一次砸烂，并引发新的革命？历史是不是这样一种永无止境的轮回，大自然是不是永远也不肯向我们展现它最终的秘密，而我们的探索，是不是永远也没有终点？</p><p>这一切都没有答案，我们只能义无反顾地沿着这条道路继续前进。或许历史终究是一场轮回，但在每一次的轮回中，我们毕竟都获得了更为伟大的发现。科学在不停的检讨自己，但这种谦卑的审视和自我否定不但没有削弱它的光荣，反而使它获得了永恒的力量，也不断地增强着我们对于它地信心。人类居住在太阳系中的一颗小小行星上，他们的文明不过万年的历史，现代科学创立不过300年，但他们的智慧贯穿整个时空，从最小的量子到最大的宇宙尺度，从大爆炸的那一刻到时间的终点，从最近的白矮星到最远的宇宙视界，没有什么可以阻挡我们的探寻的步伐。这一切，都来自我们对于成功的信念，对于科学的依赖，以及对于神奇的自然那永无休止的好奇。</p><h3 id="《家庭、私有制和国家的起源》-2019-06-27"><a href="#《家庭、私有制和国家的起源》-2019-06-27" class="headerlink" title="《家庭、私有制和国家的起源》-2019-06-27"></a>《家庭、私有制和国家的起源》-2019-06-27</h3><p>Familia这个词，起初并不表示现代庸人的那种由脉脉温情同家庭龃龉组合的理想；在罗马人眼里，它起初甚至不是指夫妻及其子女，而只是奴隶。<br>Famulus的意思是一个家庭奴隶，而Familia则是指属于一个人的全体奴隶。还在盖尤斯时代，Familia ，id est patrimonium（即遗产），就是通过遗嘱遗留的。这一用语是罗马人所发明，用以表示一种新的社会机体，这种机体的首长，以罗马的父权支配着妻子、子女和一定数量的奴隶，并且对他们握有生杀之权。</p><h3 id="《文明的冲突与世界秩序的重建》-2019-06-09"><a href="#《文明的冲突与世界秩序的重建》-2019-06-09" class="headerlink" title="《文明的冲突与世界秩序的重建》-2019-06-09"></a>《文明的冲突与世界秩序的重建》-2019-06-09</h3><p>思想的战争已经终结。<br>马克思列宁主义的信仰者可能将仍然存在于“像马那瓜、平壤和马萨诸塞的坎布里奇这样一些地方”，但是自由民主制已经获得全面胜利。未来人们将不再致力于令人振奋的思想斗争，而是致力于解决世间的经济问题和技术问题。<br>他相当惋惜的总结道，这将是十分令人厌倦的。</p><h3 id="《朝花夕拾》-2019-04-03"><a href="#《朝花夕拾》-2019-04-03" class="headerlink" title="《朝花夕拾》-2019-04-03"></a>《朝花夕拾》-2019-04-03</h3><p>他已经平静下去的脸，忽然紧张了，将眼微微一睁，仿佛有一些苦痛。<br>“叫呀！快叫呀！”她催促说。<br>“父亲！”<br>“什么呢？……。不要嚷……。不……。”他低低地说，又较急地喘了着气，好一会儿，这才复了原状，平静下去了。<br>“父亲！”我还叫他，一直到他咽了气。<br>我现在还听到那时的自己的声音，每听到时，就觉得这却是我对于父亲的最大的错处。</p><h3 id="《平凡的世界》2019-03-28"><a href="#《平凡的世界》2019-03-28" class="headerlink" title="《平凡的世界》2019-03-28"></a>《平凡的世界》2019-03-28</h3><p>我们出身于贫困的农民家庭————永远不要鄙薄我们的出身，它给我们带来的好处将一生受用不尽；但我们一定又要从我们出身的局限性中解脱出来，从意识上彻底背叛农民的狭隘性，追求更高的生活意义。<br>要知道，对于我们这样出身农民家庭的人来说，要做到这一点是多么不容易啊！<br>首先要自强自立，勇敢的面对我们不熟悉的世界。不要怕苦难！如果能深刻理解苦难，苦难就会给人带来崇高感。亲爱的妹妹，我多么希望你的一生充满欢乐。可是，如果生活需要你忍受痛苦，你一定要咬紧牙关坚持下去。有位了不起的人说过：痛苦难道是白忍受的吗？它应该使我们伟大！</p><h3 id="《断舍离》-2019-01-28"><a href="#《断舍离》-2019-01-28" class="headerlink" title="《断舍离》-2019-01-28"></a>《断舍离》-2019-01-28</h3><p>无论是居住空间和整个生活都被数量庞大的、多到塞不下的物品压垮，整个人生都在为没法收拾屋子而烦恼的状态，还是因为物资严重短缺而令生活难以维持下去的状态，都是当今世界不该出现的。既然如此，生活在物质充裕的环境下的我们，有没有什么可以做的呢？就是这种想法，促使我联想到了断舍离的基础——与物品的相处方式。</p><h3 id="《铁道之旅》-2018-11-09"><a href="#《铁道之旅》-2018-11-09" class="headerlink" title="《铁道之旅》-2018-11-09"></a>《铁道之旅》-2018-11-09</h3><p>此时此刻需要记住，机器(machine)的原初意义，也就是其前工业化的意义，并不是一种精巧的技术装置，而是就像阴谋诡计(machination)这个词或者天外救星(deus ex machina)这个短语所显示的那样，它只不过是被戏弄或者被欺骗的结果。</p><p>…</p><p>无论新技术是非物质的还是物质的，无论它是电影脚本、印刷机、金钱、机械钟表、火器、蒸汽机或者计算机，都不重要。</p><p>认识到这一点，就很容易看出19世纪的铁道和当下的计算机有何种相似之处了。两者都试图按照它们自己的图景来对这个世界进行再创造、再生产。它们都通过它们的阴谋诡计成功了。无论它们的产物是以蒸汽动力的工业生产与运输的全球网络，还是信息的数字化虚拟世界，这些都是它们的世界机器。</p><p>让他们出轨吧，爆炸吧，碰撞吧，或者就是停下来，两个世界机器就都立刻停止了。</p><h3 id="《发现东亚》-2018-11-01"><a href="#《发现东亚》-2018-11-01" class="headerlink" title="《发现东亚》-2018-11-01"></a>《发现东亚》-2018-11-01</h3><p>倒是纽约的华人移民，抛开加诸林则徐身上纠结不清的意识形态标签，回到历史本来的脉络中，给他一个最为朴素的评价：“禁毒战争先驱”。既不是悲剧，也不是说教；没有民族主义的流露，不必担心被污为“义和团”。有时候，真的，毒品就是毒品，战争就是战争罢了。</p><h3 id="《月亮与六便士》-2018-10-19"><a href="#《月亮与六便士》-2018-10-19" class="headerlink" title="《月亮与六便士》-2018-10-19"></a>《月亮与六便士》-2018-10-19</h3><p>我很怀疑，亚伯拉罕是否真的糟蹋了自己。做自己最想做的事，生活在自己喜爱的环境里，淡泊名利，与世无争，这难道是糟蹋自己吗？与此相反，做一个著名的外科医生，年薪一万镑，娶一位美丽的妻子，就是成功吗？我想，这一切取决于一个人如何看待生活的意义，取决于他认为对社会应尽什么义务，对自己有什么要求。但是我还是什么都没有说；我有什么资格同一位爵士争辩呢？</p><h3 id="《梵高传》-2018-10-19"><a href="#《梵高传》-2018-10-19" class="headerlink" title="《梵高传》-2018-10-19"></a>《梵高传》-2018-10-19</h3><p>一旦想象世界中有了所有这些元素—丝柏树、城镇风景、山峦、地平线，文森特的画笔就开始伸向天空。不受素描和眼前素材的约束，没有透视框的限制，也不被艺术热情左右，他的目光可以无拘无束地聚焦在光线上面—一直以来在夜空看到的深不可测却又安抚人心的星光。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
