<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构考纲识记理解内容（下）</title>
      <link href="/2020/05/01/Datasource2/"/>
      <url>/2020/05/01/Datasource2/</url>
      
        <content type="html"><![CDATA[<h3 id="第八章-树和二叉树"><a href="#第八章-树和二叉树" class="headerlink" title="第八章 树和二叉树"></a>第八章 树和二叉树</h3><h4 id="树的定义、相关术语、表示方法和存储结构。（识记）"><a href="#树的定义、相关术语、表示方法和存储结构。（识记）" class="headerlink" title="树的定义、相关术语、表示方法和存储结构。（识记）"></a>树的定义、相关术语、表示方法和存储结构。（识记）</h4><p><strong>树</strong>是由n(n &gt;= 0)个结点构成的集合，n = 0的树称为空树。n = 1的树只有一个节点。<br>常用术语：<br>    结点：包括一个数据元素和若干个指向其子树的分支。<br>    结点的度：结点所<strong>拥有的子树的个数</strong>称为该结点的度。<br>    叶结点：度为0的结点为叶结点，即<strong>终端结点</strong>。<br>    分支结点：度不为0的结点为分支结点，即<strong>非终端结点</strong>。<br>    孩子结点：树中一个结点的子树的根节点称为这个结点的孩子结点。<br>    双亲结点：字面。<br>    兄弟结点：字面。<br>    树的度：树中<strong>所有结点的度的最大值</strong>称为该树的度。<br>    结点的层次：根节点的层次规定为0，其他结点的层次等于双亲层次+1。<br>    树的深度：树中<strong>所有结点的层次的最大值</strong>称为该树的深度。<br>    无序树：树中任意结点的各孩子结点之间的<strong>次序构成无关紧要</strong>的树称为无序树。通常树指无序树。<br>    有序树：树中任意结点的各孩子结点有<strong>严格排列次序</strong>的树为有序树。<br>    森林：m(m &gt;= 0)棵树的集合称为森林，一棵树也可称为森林。</p><p>表示方法：<br>    直观表示法<br>    形式化表示法<br>    凹入表示法</p><p>存储结构<br>    双亲表示法：用指针表示每个结点的<strong>双亲结点</strong>。<br>    孩子表示法：表示每个结点的<strong>孩子结点</strong>。<br>    双亲孩子表示法：既表示每个结点的<strong>双亲结点</strong>，也表示<strong>孩子结点</strong>。<br>    孩子兄弟表示法：既表示每个结点的<strong>第一个孩子结点</strong>，也表示<strong>下一个兄弟结点</strong>。（常用）</p><h4 id="二叉树-完全二叉树、满二叉树-的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）"><a href="#二叉树-完全二叉树、满二叉树-的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）" class="headerlink" title="二叉树(完全二叉树、满二叉树)的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）"></a>二叉树(完全二叉树、满二叉树)的定义和性质、二叉树的存储结构——顺序表示法和链表表示法、二叉树的操作实现。（应用）</h4><p><strong>二叉树</strong>是由n(n &gt;= 0)个有限结点构成的集合。n = 0的树称为空二叉树，n = 1的树只有一个根结点。<strong>二叉树不是有序树</strong>。<br><strong>满二叉树</strong>：在一棵二叉树中，所有的结点都存在左右子树，并且所有叶结点都在同一层，这样的树称为满二叉树。<br><strong>完全二叉树</strong>：如果一棵n个结点的二叉树结构与满二叉树的前n个结点结构相同，就称为完全二叉树。具有n个结点的二叉树深度是log2n。<br><strong>满二叉树一定是完全二叉树。</strong></p><p>二叉树的<strong>性质</strong>：<br>    1、根结点的层数为0，则一棵非空二叉树的<strong>第i层上最多有2^i个</strong>结点。<br>    2、根结点的深度为0，则深度为k的<strong>二叉树的最大结点数为2^(k+1)-1 (k &gt;= -1)个</strong>。<br>    3、对于一个非空树，<strong>有n0个叶结点，度为2的结点数为n2（即分支结点），则有n0 = n2 + 1</strong>。<br>    4、有n个结点的<strong>完全二叉树的深度k &gt;= lb(n+1)-1的最小整数</strong>。<br>    5、有n个结点的完全二叉树，若从上至下，从左只有从0开始编号(i)，则有：<br>        1) i &gt; 0时，第i个结点的双亲为(i-1)/2 整除。<br>        2) 2i+1 &lt; n时，i的左孩子序号2i+1，若&gt;= n，则无左孩子。<br>        3) 2i+2 &lt; n时，i的右孩子序号2i+2，若&gt;= n，则无右孩子。</p><p>二叉树的<strong>顺序存储结构</strong><br>利用性质5可以求得各个元素的编号，故采用数组进行存储，空结点则用NULL表示。仅适用于完全二叉树和空结点不多的树。<br>二叉树的<strong>链式存储结构</strong><br>常用结构，每个结点包含左孩子指针、数据域和右孩子指针三个域。</p><p>—操作实现见应用代码块—</p><h4 id="二叉树的三种遍历方法及相应的递归算法。（应用）"><a href="#二叉树的三种遍历方法及相应的递归算法。（应用）" class="headerlink" title="二叉树的三种遍历方法及相应的递归算法。（应用）"></a>二叉树的三种遍历方法及相应的递归算法。（应用）</h4><p>—操作实现见应用代码块—</p><h4 id="二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）"><a href="#二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）" class="headerlink" title="二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）"></a>二叉树的路径、路径长度、带权路径长度、哈夫曼树（最优二叉树）的概念。（识记）</h4><p>在一棵二叉树中，从A结点到B结点所经过的<strong>分支序列</strong>为A-B的<strong>路径</strong>。<br>从A-B所经过的<strong>分支个数</strong>为A-B的<strong>路径长度</strong>。<br>从<strong>根结点至所有叶结点</strong>的路径长度之和为该<strong>二叉树的路径长度</strong>。<br>所有各分支结点的<strong>路径长度*相应权值</strong>的和为<strong>带权路径长度（WPL）</strong>。</p><p>对于一组有权值的叶结点，可构造出多种不同带权路径长度的二叉树，其中具有<strong>最小带权路径长度</strong>的二叉树称为<strong>哈夫曼树</strong>。</p><h4 id="根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）"><a href="#根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）" class="headerlink" title="根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）"></a>根据给定的叶结点及其权值构造出相应的最优二叉树、哈夫曼编码的方法。（应用）</h4><p>哈夫曼树构造步骤：<br>    1、将所有叶结点视为根节点，从而得到一个二叉树森林集合F。<br>    2、将权值<strong>最小和次小的二叉树分别</strong>作为新左子树和右子树，它们的<strong>根节点权值为两子树权值之和</strong>。<br>    3、删除先前两棵二叉树，并将新二叉树加入集合。<br>    4、重复步骤2、3，当集合中只剩一棵二叉树时，这就时哈夫曼树。</p><p>哈夫曼编码构造步骤：<br>    哈夫曼树构造完成后，规定树中左分支为0，右分支为1，经过的路径（分支序列）则为对应元素的哈夫曼编码。</p><h4 id="树与二叉树的转换、树的遍历。（应用）"><a href="#树与二叉树的转换、树的遍历。（应用）" class="headerlink" title="树与二叉树的转换、树的遍历。（应用）"></a>树与二叉树的转换、树的遍历。（应用）</h4><p>树-&gt;二叉树：<br>    1、树中所有同双亲的兄弟结点间加一条连线。<br>    2、对该双亲下<strong>非第一个孩子删除与双亲的连接线</strong>。<br>    3、整理所有的线，原第一个孩子为左子树，非第一孩子为右子树。</p><p>二叉树-&gt;树：<br>    1、若结点是左孩子，则将<strong>双亲和该结点的右孩子，右孩子的右孩子作连接线</strong>。<br>    2、删除这些右孩子<strong>与原双亲的连接线</strong>。<br>    3、整理所有线，相同层次划到一起。</p><p>树的遍历：<br>    先根遍历：先访问根结点，再按照从左至右的次序先根遍历根结点的每颗子树。（与二叉树时的前序遍历相同）<br>    后根遍历：先按照从左至右的次序后根遍历根结点的每颗子树，再访问根节点。（与二叉树时的中序遍历相同）</p><h3 id="第九章-图"><a href="#第九章-图" class="headerlink" title="第九章 图"></a>第九章 图</h3><h4 id="图的定义和常用术语。（识记）"><a href="#图的定义和常用术语。（识记）" class="headerlink" title="图的定义和常用术语。（识记）"></a>图的定义和常用术语。（识记）</h4><p><strong>图</strong>是由顶点集合间的关系集合组成的一种数据结构。图G的定义是G = (V,E)，V为数据的集合value，E为边的集合edge。<br>常用术语：<br>    顶点和边：图中的结点一般称为<strong>顶点</strong>，第i个顶点称为vi，若vi和vj间相关联，则称vi-vj间有条边，图中第k条边称为ek，ek = (vi,vj)、&lt;vi,vj&gt;。<br>    有向图和无向图：有向图中顶点对&lt;x,y&gt;是有序的，意为x-&gt;y，所以&lt;x,y&gt;和&lt;y,x&gt;是两条不同的边；在无向图中(x,y)是无序的，意为x-y，所以(x,y)和(y,x)是同一条边。同时<strong>无向边(x,y)包含有向边&lt;x,y&gt;和&lt;y,x&gt;</strong>。<br>    完全图：在有n个顶点的无向图中，若有<strong>n(n-1)/2条边，即任意两顶点间有且只有一条边，则称其为无向完全图</strong>；若有<strong>n(n-1)条边，即任意两顶点间有且只有方向相反的两条边，则称其为有向完全图</strong>。<br>    邻接顶点：在无向图G中，若(u,v)是其中的一条边，则u，v互为邻接顶点，并称边(u,v)依附于顶点u,v。<br>    顶点的度：指与它相关联的边的条数。<br>    路径：从点vi到vj途径的<strong>顶点序列</strong>称为路径。<br>    权：边附带的数据信息。<br>    路径长度：对于不带权的图，长度指该路径上<strong>边的条数</strong>，带权图则指<strong>路径上所有权值的和</strong>。<br>    子图：若图G2的值集合与边集合都含于G1，则称为G2是G1的子图。<br>    连通图和强连通图：无向图中，如果图中<strong>任意一对</strong>顶点都是<strong>连通（指仅有路径相通，不一定直接相连）</strong>的，则为<strong>连通图</strong>；有向图则称为<strong>强连通图（即一对两边）</strong>。<br>    生成树：连通图的最小连通子图称作该图的生成树。<br>    简单路径和贿赂：若路径上顶点不重复经过，则称为简单路径；若首尾顶点相连，则此路径称为回路或环。</p><p>常见性质：<br>    若无向图/有向图从<strong>任一顶点</strong>出发进行<strong>一次</strong>深度优先搜索就能访问<strong>所有</strong>结点，那么该图一定是连通图/强连通图；<br>    连通分量是<strong>无向图</strong>中的<strong>极大连通子图</strong>；强连通分量是<strong>有向图</strong>中的<strong>极大强连通子图</strong>；<br>    任何一个无向连通图的最小生成树<strong>有一棵或多颗</strong>；<br>    一个连通图的生成树是一个<strong>极小连通子图</strong>.</p><h4 id="图的邻接矩阵存储结构和邻接表存储结构。（应用）"><a href="#图的邻接矩阵存储结构和邻接表存储结构。（应用）" class="headerlink" title="图的邻接矩阵存储结构和邻接表存储结构。（应用）"></a>图的邻接矩阵存储结构和邻接表存储结构。（应用）</h4><p>—操作实现见应用代码块—</p><h4 id="邻接矩阵存储结构下图操作的实现。（理解）"><a href="#邻接矩阵存储结构下图操作的实现。（理解）" class="headerlink" title="邻接矩阵存储结构下图操作的实现。（理解）"></a>邻接矩阵存储结构下图操作的实现。（理解）</h4><p>—操作实现见应用代码块—</p><h4 id="图的深度和广度优先遍历算法。（理解）"><a href="#图的深度和广度优先遍历算法。（理解）" class="headerlink" title="图的深度和广度优先遍历算法。（理解）"></a>图的深度和广度优先遍历算法。（理解）</h4><p>深度相当于二叉树的先序，广度相当于层次；<br>连通图的深度遍历算法：<br>    1、访问顶点v并标记已访问<br>    2、查找v的第一个邻接结点w<br>    3、若w存在则继续，否则结束算法<br>    4、若w未被访问，用深度遍历算法递归访问w<br>    5、查找w的第一个邻接结点，转至步骤3</p><p>连通图的广度遍历算法：<br>    1、访问顶点v并标记已访问<br>    2、<strong>v入队列</strong><br>    3、若队列非空则继续，若空则结束算法<br>    4、取队头结点u<br>    5、查找u的第一个邻接结点w<br>    6、若w不存在则返回步骤3，存在则循环执行：<br>        1) 若w未被访问，则访问并标记<br>        2) 顶点w入列<br>        3) 查找w的第一个邻接结点，转至步骤6</p><p>非连通图的遍历算法<br>    <strong>依次将每个结点作为初始顶点</strong>进行深度或广度优先遍历，并根据访问标记来执行访问或跳过操作，直至遍历所有结点。</p><h4 id="生成树和最小生成树的概念。（识记）"><a href="#生成树和最小生成树的概念。（识记）" class="headerlink" title="生成树和最小生成树的概念。（识记）"></a>生成树和最小生成树的概念。（识记）</h4><p><strong>生成树</strong>指连通图的最小连通子图称作该图的生成树。<br><strong>最小生成树</strong>：如果无向连通图是一个带权图，那么必有一棵其边所有权值总和最小的生成树，称之为最小代价生成树，简称最小生成树。</p><h4 id="构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）"><a href="#构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）" class="headerlink" title="构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）"></a>构造最小生成树的普利姆算法和克鲁斯卡尔算法。（应用）</h4><p>—操作实现见应用代码块—</p><h4 id="最短路径及相关概念。（识记）"><a href="#最短路径及相关概念。（识记）" class="headerlink" title="最短路径及相关概念。（识记）"></a>最短路径及相关概念。（识记）</h4><p>图中两个顶点间可能存在多条路径，将<strong>路径长度</strong>最短的那条称为<strong>最短路径</strong>，其长度称为<strong>最短路径长度</strong>或<strong>最短距离</strong>。<br>在一个<strong>带权图中</strong>则为<strong>带权路径长度</strong>最小的路径也叫<strong>最短路径</strong>，其长度同上。</p><h4 id="求最短路径的狄克斯特拉算法。（应用）"><a href="#求最短路径的狄克斯特拉算法。（应用）" class="headerlink" title="求最短路径的狄克斯特拉算法。（应用）"></a>求最短路径的狄克斯特拉算法。（应用）</h4><p>—操作实现见应用代码块—</p><h4 id="AOV网的概念及有向图的拓扑排序算法。（应用）"><a href="#AOV网的概念及有向图的拓扑排序算法。（应用）" class="headerlink" title="AOV网的概念及有向图的拓扑排序算法。（应用）"></a>AOV网的概念及有向图的拓扑排序算法。（应用）</h4><p>若以有向图的<strong>顶点</strong>来表示活动，以<strong>边</strong>来表示活动间的顺序，则将此有向图称为<strong>顶点表示活动的网（AOV）</strong>。</p><p>有向图的拓扑排序算法：<br>    1、在有向图中选择一个<strong>无前驱的结点</strong>，并输出<br>    2、从有向图中<strong>删去此点及相关的有向边</strong>。<br>    重复上述步骤，直至输出所有结点/和或剩余顶点找不到符合条件的顶点（即呈环状）<br>    若为前种情况，此时输出的序列即为拓扑排序；<br>    若为后种情况，说明回路图<strong>一定无法</strong>得到拓扑序列</p><h4 id="AOE网、关键路径、关键活动的概念。（识记）"><a href="#AOE网、关键路径、关键活动的概念。（识记）" class="headerlink" title="AOE网、关键路径、关键活动的概念。（识记）"></a>AOE网、关键路径、关键活动的概念。（识记）</h4><p>若以有向图的<strong>顶点</strong>来表示活动，以<strong>边</strong>来表示活动间的顺序，<strong>权</strong>表示活动持续的时间，则将此有向图称为<strong>边表示活动的网（AOE）</strong>。<br>在AOE网中，从源点至汇点的所有路径中<strong>最大路径长度</strong>的路径称为<strong>关键路径</strong>。<br>关键路径上的活动称为<strong>关键活动</strong>。</p><h3 id="第十章-排序"><a href="#第十章-排序" class="headerlink" title="第十章 排序"></a>第十章 排序</h3><h4 id="排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）"><a href="#排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）" class="headerlink" title="排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）"></a>排序的概念、分类、排序算法好坏的评判标准、排序方法的稳定性的定义。（识记）</h4><p><strong>排序</strong>是对数据元素序列建立某种有序排列的过程，或为按关键字递增或递减排列的过程。<br><strong>关键字</strong>是数据元素中的一个数据项，其中若值不同时关键字也不一定相同，则称为<strong>主关键字</strong>，不满足定义的称为<strong>次关键字</strong>。</p><p>排序分为<strong>内部排序</strong>和<strong>外部排序</strong>两种，内部指数据<strong>全部调入</strong>内存进行排序，外部指<strong>分批</strong>导入内存排序后分批导出至磁盘等外部介质。</p><p>好坏的评判标准通常为：<strong>时间复杂度</strong>、<strong>空间复杂度</strong>、<strong>稳定性</strong>三种，其中稳定性指<strong>当使用主关键字排序时，任何排序算法的结果必定相同</strong>，次关键字可能相同，也可能不同。</p><p>在10000个元素中只想获取前十个最小元素时应用<strong>堆排序</strong>；<br>快速排序在<strong>数据已经基本有序的情况下</strong>最不利；<br>在所有人的生日排序，使用<strong>基数排序</strong>最快；<br>若数据已基本<strong>正序</strong>，用<strong>插入</strong>，<strong>逆序</strong>则用<strong>选择</strong></p><h4 id="简单选择排序的基本思想。（应用）"><a href="#简单选择排序的基本思想。（应用）" class="headerlink" title="简单选择排序的基本思想。（应用）"></a>简单选择排序的基本思想。（应用）</h4><p>依次遍历数据，将最小值交换到遍历的位置，注意数据在符合它位置时也算趟数，总遍历次数 == 数据数量</p><img src="/2020/05/01/Datasource2/Sim_Sort.jpg"><h4 id="直接插入排序的基本思想。（应用）"><a href="#直接插入排序的基本思想。（应用）" class="headerlink" title="直接插入排序的基本思想。（应用）"></a>直接插入排序的基本思想。（应用）</h4><p>顺序把数据元素按<strong>关键字值大小</strong>插入值已排序的数据元素<strong>子集合</strong>的适当位置。子集合的元素个数从一开始逐次增大，当两者大小相同时排序完毕。<br>从第二项(下标1)开始遍历，将其插入前面序列的合适位置，同样在合适位置时也算趟数，总遍历次数 == 数据数量 - 1</p><img src="/2020/05/01/Datasource2/Insert_Sort.jpg"><h4 id="冒泡排序的基本思想。（应用）"><a href="#冒泡排序的基本思想。（应用）" class="headerlink" title="冒泡排序的基本思想。（应用）"></a>冒泡排序的基本思想。（应用）</h4><p>数组a中有n个数据，循环依次比较a[i]和a[i+1]的主关键字值，若逆序则交换，否则不交换；一轮后最大数据沉入数组尾部，然后减少一次循环再进行排序，直至n-1躺结束，此时a[0]为最小数据。</p><h4 id="希尔排序的基本思想。（应用）"><a href="#希尔排序的基本思想。（应用）" class="headerlink" title="希尔排序的基本思想。（应用）"></a>希尔排序的基本思想。（应用）</h4><p>把待排序的元素<strong>分成若干小组</strong>，对组内的元素进行<strong>直接插入排序</strong>，然后再减少组的数量后再次划分重复排序，只剩一个组时排序结束。</p><img src="/2020/05/01/Datasource2/Shell_Sort.jpg"><h4 id="快速排序的基本思想。（应用）"><a href="#快速排序的基本思想。（应用）" class="headerlink" title="快速排序的基本思想。（应用）"></a>快速排序的基本思想。（应用）</h4><p>数组a中有n个数据，分别设高端和低端两个下标，任取一个元素（通常为a[low]）作标准，调整各元素的位置，关键字小于标准的排在其前面，大于等于排后面。此时数组由标准数据化为两个区块，分别对其进行递归操作，当high &lt;= low时结束。<br>即数据头尾分别设一个指针，<strong>先后指针往前遍历</strong>，遇到第一个小于前指针所指数据时，则前后<strong>指针的数据</strong>交换，指针不变；然后<strong>前指针往后遍历</strong>，遇到第一个大于后指针所指数据时交换，反复遍历直至<strong>后指针 &lt;= 前指针</strong>。</p><img src="/2020/05/01/Datasource2/Quick_Sort.jpg"><h4 id="各种排序方法的优缺点的性能比较。（理解）"><a href="#各种排序方法的优缺点的性能比较。（理解）" class="headerlink" title="各种排序方法的优缺点的性能比较。（理解）"></a>各种排序方法的优缺点的性能比较。（理解）</h4><img src="/2020/05/01/Datasource2/sort_compare.jpg"><h3 id="第十一章-查找"><a href="#第十一章-查找" class="headerlink" title="第十一章 查找"></a>第十一章 查找</h3><h4 id="查找的基本概念、分类、平均查找长度。（识记）"><a href="#查找的基本概念、分类、平均查找长度。（识记）" class="headerlink" title="查找的基本概念、分类、平均查找长度。（识记）"></a>查找的基本概念、分类、平均查找长度。（识记）</h4><p><strong>查找</strong>是在元素集合中查找是否存在<strong>关键字等于某个给定关键字数据元素</strong>的过程。<br><strong>主次关键字</strong>概念同上。<br>查找分为<strong>静态查找</strong>和<strong>动态查找</strong>，静态指<strong>只在</strong>集合中查找是否存在关键字相等的数据元素；动态指除静态要求相等外，还包括<strong>查找过程中同时插入的数据集合中不存在</strong>的数据。<br><strong>平均查找长度（ASL）</strong>指查找过程中关键字<strong>比较次数的平均值</strong>。为查找数据的出现概率<em>查找此数据的比较次数。<br>二叉树的*</em>中序遍历**可得到结点值从小到大的排序序列。</p><h4 id="在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）"><a href="#在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）" class="headerlink" title="在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）"></a>在顺序表中查找的基本思想、有序顺序表中的两种查找方法。（理解）</h4><p>从顺序表的一端开始，用给定的关键字逐个进行比较，若查找成功返回其位置，否则返回-1。<br>有序顺序表的<strong>顺序查找</strong>：因为表原有序，所以当存在一个指大于查找值时直接结束算法，不必遍历全表。<br>有序顺序表的<strong>折半查找</strong>：确定表的中心位置，将查找值与中心比较，并移至前半或后半递归，直至上界小于下界时结束。</p><h4 id="哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）"><a href="#哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）" class="headerlink" title="哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）"></a>哈希表的基本概念、构造方法和哈希冲突解决方法。（应用）</h4><p>有n个数据要存储，先设置长度为m的连续内存单元<br>将每个数据的关键字通过hash(key)函数可得到某个地址，并将其关键字的数据存入该地址<br>实际上可看作关键字是对地址的映射，因此hash(key)也称散列地址，哈希表也称散列表。<br>有时存在两个不同关键字映射到同一个地址的现象，称为<strong>哈希冲突</strong>，也称<strong>同义词冲突</strong>。<br>哈希函数的形式为hash(key) = key mod m，m的取值范围是数据个数n的<strong>1.1n-1.7n倍</strong>之间的<strong>素数</strong>。<br>平均查找承担与结点个数n无关的查找方法是<strong>哈希查找</strong>。</p><p>哈希表的构造方法主要有：<strong>除留余数法</strong>、<strong>直接定址法</strong>和<strong>数字分析法</strong>。<br>除留余数法：是指用关键字除以哈希表长度m所得余数作为地址的方法。<br>直接定址法：直接用关键字或关键字加个常数C作为地址的方法。<br>数字分析法：取关键字中某些取值较均匀的数字位作为地址的方法。</p><p>哈希冲突的解决方法主要由<strong>开放定址法</strong>和<strong>链表法</strong>。<br>开放定址法：在产生哈希冲突后再采用若干个<strong>哈希冲突函数</strong>得到一个新的空闲地址的方法，此类哈希冲突函数通常是一组。开放定址法有<strong>线性探查法</strong>、<strong>平方探查法</strong>和<strong>伪随机数法</strong>三种。<br>链表法：如果没有产生哈希冲突则直接存储，若产生则将元素<strong>放入某个单链表中</strong>。方法一是为发生冲突的不同同义词<strong>建立不同的单链表</strong>，二是所有的同义词<strong>建立一个单链表</strong>。</p><img src="/2020/05/01/Datasource2/Hash_Sheet.jpg">]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构考纲识记理解内容（上）</title>
      <link href="/2020/05/01/Datasource1/"/>
      <url>/2020/05/01/Datasource1/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="数据、数据元素、数据项的基本概念（识记）"><a href="#数据、数据元素、数据项的基本概念（识记）" class="headerlink" title="数据、数据元素、数据项的基本概念（识记）"></a>数据、数据元素、数据项的基本概念（识记）</h4><p><strong>数据</strong>是人们利用文字符号、数字符号以及其他规定的<strong>符号</strong>对现实世界的事物及其活动所做的<strong>抽象描述</strong>。<br>表示一个事物的一组数据称作一个<strong>数据元素</strong>。构成数据元素的数据称作该数据的<strong>数据项</strong>。</p><h4 id="数据结构的三种逻辑结构和两种存储结构表示方法（理解）"><a href="#数据结构的三种逻辑结构和两种存储结构表示方法（理解）" class="headerlink" title="数据结构的三种逻辑结构和两种存储结构表示方法（理解）"></a>数据结构的三种逻辑结构和两种存储结构表示方法（理解）</h4><p>数据元素之间的相互联系方式称为<strong>数据的逻辑结构</strong><br>数据的逻辑结构主要可分为<strong>线性结构</strong>、<strong>树状结构</strong>和<strong>图形结构</strong>三种。<br>线性结构：除第一和最后一个数据元素外，每个数据元素只有一个<strong>唯一的前驱</strong>数据和一个<strong>唯一的后后继</strong>数据。<br>树状结构：除根节点外，每个数据元素只有一个<strong>唯一的前驱</strong>数据和<strong>零个或若干个后继</strong>数据元素。<br>图形结构：每个数据元素可有<strong>零个或若干个前驱</strong>数据元素和<strong>零个或若干个后继</strong>数据元素。</p><p>数据元素在计算机中的存储方式称为<strong>数据的存储结构</strong><br>数据的存储结构的基本形式有两种：一种是<strong>顺序存储结构</strong>，一种是<strong>链式存储结构</strong>。<br>顺序存储结构是指把数据元素存储在一块<strong>连续地址空间</strong>的内存中。<br>链式存储结构使用<strong>指针</strong>把相互直接关联的点链接起来，逻辑上相邻的数据元素在物理上不一定相邻。</p><p>数据结构被形式的定义为(D,R)，其中D是<strong>数据</strong>的有限集合，R是D上的<strong>关系</strong>的有限集合。</p><h4 id="数据结构和抽象数据类型的概念（理解）"><a href="#数据结构和抽象数据类型的概念（理解）" class="headerlink" title="数据结构和抽象数据类型的概念（理解）"></a>数据结构和抽象数据类型的概念（理解）</h4><p>数据结构主要讨论<em>表、堆栈、队列、串、数组、树、二叉树和图</em>等典型的常用数据结构，在讨论这些数据结构时，主要从它们的<strong>逻辑结构</strong>、<strong>存储结构</strong>和<strong>数据操作</strong>三个方面进行分析讨论。</p><p><strong>类型</strong>是一组值的集合，<strong>数据类型</strong>是指一个<strong>类型和定义</strong>在这个<strong>类型上的操作集合</strong>。通常在已有数据类型基础上设计新的数据类型的过程称为<strong>数据结构设计</strong>。<br><strong>抽象数据类型(Abstract Data Type(ADT))</strong>是指一个<strong>逻辑概念</strong>上的<strong>类型</strong>和这个<strong>类型上的操作集合</strong>。<br>数据类型和抽象数据类型的不同之处在于：数据类型指高级程序设计语言本身支持的基本数据类型，而抽象指在基本数据类型支持下的用户新设计的数据类型。</p><h4 id="算法的概念、性质和目标（识记）"><a href="#算法的概念、性质和目标（识记）" class="headerlink" title="算法的概念、性质和目标（识记）"></a>算法的概念、性质和目标（识记）</h4><p><strong>算法</strong>是描述求解问题方法的<strong>操作步骤集合</strong>。<br>任何算法设计都应满足以下<strong>性质</strong>：<br>    1、输入性：有零个或若干个输入量。<br>    2、输出性：至少产生一个输出量或执行一个有意义的操作。<br>    3、有限性：执行语句的序列是有限的。<br>    4、确定性：每条语句的含义明确，无二义性。<br>    5、可执行性：每条语句都应在有限的时间内完成。<br>算法设计应满足以下<strong>目标</strong>：<br>    1、正确性：应确切满足具体问题的需求，<strong>基本目标</strong>。<br>    2、可读性：有利于人对算法的理解。<br>    3、健壮性：当输入非法数据时，算法要能做出适当的处理。<br>    4、高时间效率：算法的时间效率是指运行算法需要<strong>花费时间的多少</strong>。<br>    5、高空间效率：算法的空间效率是指运行算法需要<strong>占用的额外内存空间的多少</strong>。</p><h3 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h3><h4 id="线性表的定义和抽象数据类型（识记）"><a href="#线性表的定义和抽象数据类型（识记）" class="headerlink" title="线性表的定义和抽象数据类型（识记）"></a>线性表的定义和抽象数据类型（识记）</h4><p><strong>线性表</strong>是一种可以在任意位置进行插入和删除数据元素操作的、由n(n &gt;= 0)个相同类型数据元素组成的线性结构。<br>线性表的抽象数据类型包括<strong>数据集合</strong>和<strong>该数据集合上的操作集合</strong>。<br>数据集合可以表示为a0、a1、a2…an-1，每个数据元素的类型都是抽象数据的类型DataType。<br>操作集合：<br>    1、<strong>初始化ListInitiate(L)</strong>：初始化线性表。<br>    2、<strong>求当前数据元素个数ListLenght(L)</strong>，返回表L的元素个数。<br>    3、<strong>插入数据元素ListInsert(L,i,x)</strong>，i为位置，x为元素值，插入成功返回1，否则返回0，针对最后一位存在i = ListLenght(L)-1时，为最后一位前插入数据，i = ListLenght(L)时为在最后一位后插入数据。<br>    4、<strong>删除数据元素ListDelete(L,i,x)</strong>，x为元素值存储位，删除成功返回1，否则返回0，存在i = 0时，删取第一位，i = ListLenght(L)-1时，删取最后一位。<br>    5、<strong>取数据元素ListGet(L,i,x)</strong>，于删除类同，仅取数据。</p><h4 id="线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）"><a href="#线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）" class="headerlink" title="线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）"></a>线性表的顺序表示和实现。顺序表的定义和存储结构，顺序表上的插入、删除等操作及其平均时间性能分析。（理解）</h4><p>—实现见应用代码块—<br>顺序存储结构的线性表就是<strong>顺序表</strong>。<br>实现<strong>顺序存储结构</strong>的方法是使用<strong>数组</strong>。数组把线性表的数据结构存储在一块连续地址空间的内存单元中，所以线性表逻辑相连的数据元素物理上也相邻。<br>顺序表中<strong>插入和删除</strong>的平均时间复杂度为<strong>O(n)</strong>，其余操作的时间复杂度均为O(1)。</p><h4 id="线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）"><a href="#线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）" class="headerlink" title="线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）"></a>线性表的链式表示和实现。单链表、循环单链表、双向链表的存储结构和操作实现。（理解）</h4><p>—实现见应用代码块—<br>存储结构：<br>    <strong>单链表</strong>：构成链表的节点<strong>只有一个</strong>指向<strong>直接后继节点</strong>的指针域。<br>    <strong>循环单链表</strong>：是单链表的另一种形式，结构特点是链表中<strong>最后一个节点的指针域不再是NULL而是指向第一个节点</strong>，形成一个环。<br>    <strong>双向链表</strong>：每个节点除了后继指针域外<strong>还有一个前驱指针域</strong>，带头节点的双向链表更为常用。</p><h4 id="单链表上实现的建表、查找、插入和删除等基本算法。（理解）"><a href="#单链表上实现的建表、查找、插入和删除等基本算法。（理解）" class="headerlink" title="单链表上实现的建表、查找、插入和删除等基本算法。（理解）"></a>单链表上实现的建表、查找、插入和删除等基本算法。（理解）</h4><p>见第二章第三节。</p><h4 id="顺序表和链表的比较，各自的优缺点。（理解）"><a href="#顺序表和链表的比较，各自的优缺点。（理解）" class="headerlink" title="顺序表和链表的比较，各自的优缺点。（理解）"></a>顺序表和链表的比较，各自的优缺点。（理解）</h4><p>链表中<strong>插入、删除、求元素个数和撤销单链表</strong>的平均时间复杂度为<strong>O(n)</strong>，其余操作的时间复杂度均为O(1)。<br>优点：不需要预先确定数据元素的最大个数。<br>缺点：每个节点都包含了指针域，空间利用率不高，且算法较为复杂。<br>顺序表的优缺点于链表相异即可。</p><h3 id="第三章-堆栈和队列"><a href="#第三章-堆栈和队列" class="headerlink" title="第三章 堆栈和队列"></a>第三章 堆栈和队列</h3><h4 id="堆栈的定义和特点。栈顶和栈底相关术语。（识记）"><a href="#堆栈的定义和特点。栈顶和栈底相关术语。（识记）" class="headerlink" title="堆栈的定义和特点。栈顶和栈底相关术语。（识记）"></a>堆栈的定义和特点。栈顶和栈底相关术语。（识记）</h4><p><strong>堆栈</strong>是一种特殊的线性表，堆栈的数据元素及数据元素之间的逻辑关系和线性表完全相同，差别在于堆栈<strong>只允许在固定一端</strong>进行插入和删除数据的操作。堆栈中允许进行插入和删除数据元素操作的一段称为<strong>栈顶</strong>。另一端称为<strong>栈底</strong>。栈顶的位置是动态的，拥有标记栈顶位置的变量称为<strong>栈顶指示器（栈顶指针）</strong>。堆栈的插入操作通常称为<strong>进栈或入栈</strong>，删除操作称为<strong>出栈或退栈</strong>。是个<strong>先进后出表</strong>。</p><h4 id="顺序-链式堆栈的存储结构和操作实现。（理解）"><a href="#顺序-链式堆栈的存储结构和操作实现。（理解）" class="headerlink" title="顺序/链式堆栈的存储结构和操作实现。（理解）"></a>顺序/链式堆栈的存储结构和操作实现。（理解）</h4><p>—实现见应用代码块—<br>存储结构：顺序堆栈和顺序表的差别是只对栈顶进行操作，将数组a[]抽象成堆栈，且a0为栈底，ai为栈顶，存在变量top表示栈顶位置。<br>同时，链式堆栈和单链表的差别同上，将靠近头指针的节点定为栈顶，另一端为栈底。</p><h4 id="队列的概念和特点。队首和队尾相关术语。（识记）"><a href="#队列的概念和特点。队首和队尾相关术语。（识记）" class="headerlink" title="队列的概念和特点。队首和队尾相关术语。（识记）"></a>队列的概念和特点。队首和队尾相关术语。（识记）</h4><p><strong>队列</strong>也是一种特殊的线性表，于线性表完全相同，差别在于队列<strong>只允许在其一端</strong>进行插入操作，在<strong>其另一端</strong>进行删除操作。<br>队列中插入操作的一端称为<strong>队尾</strong>，进行删除操作的一端称为<strong>队头</strong>。与堆栈相同同样存在<strong>队头指示器（队头指针）</strong>和<strong>队尾指示器（队尾指针）</strong>。队列的插入操作通常称为<strong>入队列</strong>，删除操作称为<strong>出队列</strong>。是个<strong>先进先出表</strong>。</p><h4 id="顺序-链式队列的存储结构、顺序循环队列的表示和实现。（理解）"><a href="#顺序-链式队列的存储结构、顺序循环队列的表示和实现。（理解）" class="headerlink" title="顺序/链式队列的存储结构、顺序循环队列的表示和实现。（理解）"></a>顺序/链式队列的存储结构、顺序循环队列的表示和实现。（理解）</h4><p>—实现见应用代码块—<br>顺序队列存储结构与堆栈类似，使用顺序循环队列的原因是因为<strong>尾指针会超出队列定义的最大存储空间</strong>，造成<strong>假溢出</strong>的现象。<br>故采用循环队列，当为指针超出最大时重置为0，作环状。<br>判断队空满的三种方法：<br>    1、少用一个存储空间-队满(rear + 1) % MaxQueueSize == front  队空rear == front<br>    2、设置一个标志位-队满rear == front &amp;&amp; tag == 0 队空rear == front &amp;&amp; tag == 1<br>    3、设置一个计数器-队满count == 0    队空count &gt; 0 &amp;&amp; rear == front</p><h4 id="堆栈和队列的应用。（应用）"><a href="#堆栈和队列的应用。（应用）" class="headerlink" title="堆栈和队列的应用。（应用）"></a>堆栈和队列的应用。（应用）</h4><p>堆栈应用：括号匹配问题/算数表达式问题<br>队列应用：打印任务管理器</p><h3 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h3><h4 id="串的定义、空串、空格串、子串、主串、串相等。（识记）"><a href="#串的定义、空串、空格串、子串、主串、串相等。（识记）" class="headerlink" title="串的定义、空串、空格串、子串、主串、串相等。（识记）"></a>串的定义、空串、空格串、子串、主串、串相等。（识记）</h4><p><strong>串（也称字符串）</strong>是由n(n &gt;= 0)个字符组成的有限序列。<br><strong>空串</strong>为字符数为0的串，<strong>空格串</strong>表示只含空格字符的串。<br>一个<strong>串中</strong>任意个连续字符组成的<strong>子序列</strong>称为该串的<strong>子串</strong>，包含子串的串称为该子串的<strong>主串</strong>。<br><strong>串相</strong>？</p><h4 id="串的基本操作（理解）"><a href="#串的基本操作（理解）" class="headerlink" title="串的基本操作（理解）"></a>串的基本操作（理解）</h4><p>—实现见应用代码块—</p><h3 id="第五章-数组"><a href="#第五章-数组" class="headerlink" title="第五章 数组"></a>第五章 数组</h3><h4 id="数组的定义（识记）"><a href="#数组的定义（识记）" class="headerlink" title="数组的定义（识记）"></a>数组的定义（识记）</h4><p><strong>数组</strong>是n(n &gt; 1)个相同数据类型的数据元素a0、a1、a2…an-1构成的占用一块地址连续的内存单元的有限序列。</p><h4 id="数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）"><a href="#数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）" class="headerlink" title="数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）"></a>数组的实现机制。一维数组、二维数组的按行存储及按列存储和计算数组元素的地址计算公式。（应用）</h4><p>对一个有n个数据元素的<strong>一维数组</strong>，ao是下标为0的数组元素，loc(a0)是a0的内存单元地址，k是每个数据元素所需的字节个数，则数组中任一数据元素ai的内存单元地址loc(ai)可由下面公式求出：<br><strong>loc(ai) = loc(a0) + i * k (0 &lt;= i &lt;= n)</strong></p><p><strong>二维数组</strong>为m行n列的矩阵，因为计算机的存储原理所以存在二维数组向一位数组映射的问题。映射有两种方法，分别称为<strong>行主序</strong>和<strong>列主序</strong>方法，C语言采用行主序方法。则数组中任一数据元素aij的内存单元地址loc(aij)可由下面公式求出：<br><strong>loc(aij) = loc(a00) + (i * n + j) * k (0 &lt;= i &lt; m, 0 &lt;= i &lt; n)</strong></p><p>用高级语言定义数组时，数组的首地址由系统分配并保存。通常用数组名保存数组的首地址，编译器可快速算出任一元素的地址。<br>应为计算元素地址的速度相同，所以存取时间也相同，通常称具有这种特性的存储结构为随机存储结构。<strong>数组是一种随机存储结构</strong>。</p><h4 id="特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）"><a href="#特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）" class="headerlink" title="特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）"></a>特殊矩阵和稀疏矩阵的概念及其压缩存储。（理解）</h4><p>存在许多值相同或许多零元素，且分布有一定规律的矩阵称为<strong>特殊矩阵</strong>。<br>对于一个m * n = s的矩阵，设t为矩阵中非零元素的总和，满足t &lt;&lt; s(即t * 10^2 &lt; s)的矩阵称为<strong>稀疏矩阵</strong>。</p><p>若存在一个n * n的矩阵，且内部数据沿主对角线对称，则将其称为<strong>n阶对称矩阵</strong>。<br>当对称矩阵由一维数组映射时，则有：<br><strong>k = i(i + 1)/2 + j - 1 当i &gt;= j时，即上半区含中线</strong><br><strong>n(n + 1)/2 当i &lt; j时，即下半区</strong></p><p>稀疏矩阵的压缩存储结构主要有<strong>三元组顺序表</strong>和<strong>三元组链表</strong>。<br>三元组顺序表形式：{1,3,11},{1,5,17},{2,2,25},{4,1,19}，其中三元素第一位为行号，第二位为列号，第三位为元素值。<br>三元组链表形式：形如数组，每个元素表示行号，数组的值为指针，每个行号作为头指针衍生出单链表，存储列号和元素值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构概念习题综合</title>
      <link href="/2020/04/16/datatype/"/>
      <url>/2020/04/16/datatype/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树部分"><a href="#二叉树部分" class="headerlink" title="二叉树部分"></a>二叉树部分</h3><h4 id="树的概念及性质等"><a href="#树的概念及性质等" class="headerlink" title="树的概念及性质等"></a>树的概念及性质等</h4><h4 id="二叉树操作集合及习题函数"><a href="#二叉树操作集合及习题函数" class="headerlink" title="二叉树操作集合及习题函数"></a>二叉树操作集合及习题函数</h4><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define DataType inttypedef struct Node{DataType data;struct Node *LChild, *RChild;&#x2F;&#x2F;struct Node *Parent;}BiTree;void CreateBitree(BiTree **T)&#x2F;&#x2F;静态生成二叉树{*T = (BiTree *)malloc(sizeof(BiTree));(*T)-&gt;data = 1;(*T)-&gt;LChild = (BiTree *)malloc(sizeof(BiTree));(*T)-&gt;RChild = (BiTree *)malloc(sizeof(BiTree));(*T)-&gt;LChild-&gt;data = 2;(*T)-&gt;LChild-&gt;LChild = (BiTree *)malloc(sizeof(BiTree));(*T)-&gt;LChild-&gt;LChild-&gt;data = 4;(*T)-&gt;LChild-&gt;RChild = (*T)-&gt;LChild-&gt;LChild-&gt;LChild = (*T)-&gt;LChild-&gt;LChild-&gt;RChild = NULL;(*T)-&gt;RChild-&gt;data = 3;(*T)-&gt;RChild-&gt;LChild = (BiTree *)malloc(sizeof(BiTree));(*T)-&gt;RChild-&gt;LChild-&gt;data = 5;(*T)-&gt;RChild-&gt;LChild-&gt;LChild = (*T)-&gt;RChild-&gt;LChild-&gt;RChild = NULL;(*T)-&gt;RChild-&gt;RChild = (BiTree *)malloc(sizeof(BiTree));(*T)-&gt;RChild-&gt;RChild-&gt;data = 6;(*T)-&gt;RChild-&gt;RChild-&gt;LChild = (*T)-&gt;RChild-&gt;RChild-&gt;RChild = NULL;}BiTree *InsterBitreeLeftNode(BiTree *T, DataType x)&#x2F;&#x2F;插入新左子树{if(T == NULL)return NULL;BiTree *orileft = T-&gt;LChild;&#x2F;&#x2F;先保存原有子树BiTree *newleft = (BiTree *)malloc(sizeof(BiTree));newleft-&gt;data = x;newleft-&gt;LChild = orileft;newleft-&gt;RChild = NULL;&#x2F;&#x2F;创建新子树并赋值T-&gt;LChild = newleft;&#x2F;&#x2F;接回原有二叉树return T-&gt;LChild; }BiTree *InsterBitreeRightNode(BiTree *T, DataType x)&#x2F;&#x2F;插入新右子树{if(T == NULL)return NULL;BiTree *oriright = T-&gt;RChild;&#x2F;&#x2F;先保存原有子树BiTree *newright = (BiTree *)malloc(sizeof(BiTree));newright-&gt;data = x;newright-&gt;RChild = oriright;newright-&gt;LChild = NULL;&#x2F;&#x2F;创建新子树并赋值T-&gt;RChild = newright;&#x2F;&#x2F;接回原有二叉树return T-&gt;RChild; }void PreOrderTraverse(BiTree *T)&#x2F;&#x2F;先序遍历{if(T){printf(&quot;%d\t&quot;,T-&gt;data);PreOrderTraverse(T-&gt;LChild);PreOrderTraverse(T-&gt;RChild);}return ;}void InOrderTraverse(BiTree *T)&#x2F;&#x2F;中序遍历{if(T){InOrderTraverse(T-&gt;LChild);printf(&quot;%d\t&quot;,T-&gt;data);InOrderTraverse(T-&gt;RChild);}return ;}void PostOrderTraverse(BiTree *T)&#x2F;&#x2F;后序遍历{if(T){PostOrderTraverse(T-&gt;LChild);PostOrderTraverse(T-&gt;RChild);printf(&quot;%d\t&quot;,T-&gt;data);}return ;}void PrintBiTree(BiTree *T,int inden){if(T==NULL)return ;PrintBiTree(T-&gt;RChild,inden+1);for(int i = 0;i&lt;inden;i++)printf(&quot;\t&quot;);if(inden &gt; 0)printf(&quot;---&quot;);printf(&quot;%d\n&quot;,T-&gt;data);PrintBiTree(T-&gt;LChild,inden+1);}static int Leafnum = 0;int LeafNodeSearch(BiTree *T)&#x2F;&#x2F;寻找叶子节点的数量，递归形式要配合静态变量{if(T){if(T-&gt;LChild == NULL &amp;&amp; T-&gt;RChild == NULL)Leafnum++;LeafNodeSearch(T-&gt;LChild);LeafNodeSearch(T-&gt;RChild);}elsereturn 0;return Leafnum;}static int Comnum = 1;int ComTreeDetection(BiTree *T)&#x2F;&#x2F;检测是否为完全二叉树，未实现{if(T){if(T-&gt;LChild == NULL &amp;&amp; T-&gt;RChild != NULL)Comnum = 0;LeafNodeSearch(T-&gt;LChild);LeafNodeSearch(T-&gt;RChild);}elsereturn 0;return Comnum;}void Destroy(BiTree **T)&#x2F;&#x2F;释放二叉树{if((*T) != NULL &amp;&amp; (*T)-&gt;LChild != NULL)Destroy(&amp;(*T)-&gt;LChild);if((*T) != NULL &amp;&amp; (*T)-&gt;RChild != NULL)Destroy(&amp;(*T)-&gt;RChild);free(*T);}void *DestroyLeftNode(BiTree *T)&#x2F;&#x2F;删除左子树，因为是递归删除，所以该节点下所有点都会被删除{if(T==NULL || T-&gt;LChild==NULL)return NULL;Destroy(&amp;T-&gt;LChild);return T;}void *DestroyRightNode(BiTree *T)&#x2F;&#x2F;删除右子树，因为是递归删除，所以该节点下所有点都会被删除{if(T==NULL || T-&gt;RChild==NULL)return NULL;Destroy(&amp;T-&gt;RChild);return T;}int main(){BiTree *Tree;CreateBitree(&amp;Tree);&#x2F;&#x2F;printf(&quot;%d\n&quot;,Tree-&gt;data);&#x2F;&#x2F;PreOrderTraverse(Tree);&#x2F;&#x2F;InOrderTraverse(Tree);&#x2F;&#x2F;PostOrderTraverse(Tree);PrintBiTree(Tree,0);printf(&quot;%d\n&quot;,LeafNodeSearch(Tree));Destroy(&amp;Tree);return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS题目解析</title>
      <link href="/2019/10/15/osC/"/>
      <url>/2019/10/15/osC/</url>
      
        <content type="html"><![CDATA[<h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>周转时间：作业完成时刻-作业到达时刻<br>平均周转时间：作业周转总时间/作业个数<br>带权周转时间：周转时间/服务时间<br>平均带权周转时间：带权周转总时间/作业个数<br>等待时间：周转时间-服务时间<br>平均等待时间：等待总时间/作业个数<br>响应比：作业周转时间/作业执行时间 = （等待时间+要求服务时间）/要求服务时间</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>先来先服务算法：如名字所说，先进入就绪队列的进程先运行</p><p>非抢占式优先级算法：执行完一个进程后在队列中挑选一个优先级最高的进程运行</p><p>银行家算法：银行家算法是死锁<strong>预防</strong>策略<br>    四个规则：<br>    1.当一个进程的最大需求不超过现有资源时可允许<br>    2.进程可以分期获取资源，但不能超过最大资源数<br>    3.不能满足进程的需求时可推迟，但总能在有限时间内分配资源<br>    4.当进程获取完全部所需资源时一定在有限的时间内归还<br>死锁的解除分为：剥夺资源和撤销进程</p><p>在<strong>交互式用户环境</strong>中采用抢占式调度算法</p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>操作系统结构研究<strong>不包括</strong>规则统一化<br><strong>不属于</strong>特权指令的是管访命令<br>中断屏蔽标志位是<strong>IF</strong><br><strong>不属于临时性资源</strong>的是共享程序代码<br>把逻辑地址转绝对地址的工作称为<strong>地址重定位</strong><br>Unix接口有内存与硬件、内核与shell两个接口<br>整理内存碎片的技术叫<strong>紧缩</strong><br>SPOOLing系统主要三部分：输入程序模块、输出程序模块、作业调度<br>分时操作系统不具有实时性<br>消息缓冲区是由消息长度、消息正文、发送者、消息队列指针四项组成</p><h3 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h3><p>P操作对资源S进行预测，其内部动作为：<br>    1.S-1<br>    2.判断若S-1后大于或等于0，则进程继续执行<br>    3.若小于0，就阻塞并放入S的等待队列中<br>V操作释放信号量，内部动作为：<br>    1.S+1<br>    2.若大于0，继续执行<br>    3.若小于等于0，则从S等待队列中释放一个等待进程<br>信号量：是整数，互斥信号量一般是1<br>信号量值的物理意义：若为正数，意味着S还有若干个资源可使用；若为负数，意味着有若干个进程在队列中等待，为0时表示有进程正在占用最后这个S资源<br>PV操作的缺点是：<br>    1.程序可读性差<br>    2.不利于修改和维护<br>    3.正确性难以保证<br>例题：将整型电压值从传感器中取出存入缓冲区，然后取出转换成温度值后再次存入，最后再次取出显示。用PV操作来实现三个过程共享缓冲区的同步问题。</p><h3 id="资源分配图及化简方法"><a href="#资源分配图及化简方法" class="headerlink" title="资源分配图及化简方法"></a>资源分配图及化简方法</h3><p>1.查看是否有满足需求的资源，将它的所有边去掉，变成一个孤立的点<br>2.重复上述过程<br>3.若所有点都能孤立就能避免死锁，否则就是死锁状态<br>死锁：</p><h3 id="磁盘调度的几种方法"><a href="#磁盘调度的几种方法" class="headerlink" title="磁盘调度的几种方法"></a>磁盘调度的几种方法</h3><p>先来先服务(FCFS)：先进入队列的申请先调度，不过有相邻申请磁道却相隔很远的不利情况<br>最短寻找时间有限算法(SSTF)：选择离当前磁道最近的申请进行调度，不过可能产生饥饿<br>扫描算法（SCAN/LOOK）：无申请时不动，有申请时磁头沿该方向扫描，若这个方向还有申请就继续前进，若没有申请或走到尽头则调头，对两头区域不利<br>循环扫描算法(C-SCAN/C-LOOK)：规定磁头单向移动，扫描至尽头后直接折返至起点，折返间不接受任何申请</p><p>用于储存数据物理、线性和有效地址的寄存器是地址寄存器<br>实现存储保护，对属于自己区域的信息<strong>可读可写</strong><br>存储系统的设计<strong>不考虑时间</strong>问题<br>流式文件没有结构</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程由程序、数据、进程控制块组成<br>进程的特性不包括随机性；含有并发、动态、交往、异步、结构、独立性<br>在Unix系统中，创建子进程使用fork()函数，exec()函数要配合vfork()函数使用，功能是加载一个可执行文件，wait()函数用于等待并回收子进程，而waitpid()函数是等待并回收一个<strong>指定</strong>的子进程<br>资源拥有的<strong>基本单位是进程</strong>不是线程<br>当一个管程无法继续执行时也是用wait操作</p><h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>将程序划分为若干个长度相等的页，然后各自放入内存，并记录下该页所存放的内存地址并和页码(页式虚拟地址)一一对应形成<strong>页表</strong>；页表存放在内存中一块固定的存储区，每个进程至少有一个页表<br>缺页中断：有时某一页还未加载进内存，程序试图访问这一页时CPU的内存管理单元会发出中断<br>页面置换算法：<br>    LRU(Least Recently Used)把<strong>最近最少使用置换</strong>的页面淘汰<br>    LFU(Least Frequently Used)<strong>最少使用置换</strong>每个页面都设置一个移位寄存器，用来记录移位的频率，频率最低的页面被淘汰<br>    OPT(不可实现)<strong>最佳置换算法</strong>因为OS不知道各页面什么时候会被访问<br>    FIFO(First Input First Output)<strong>先进先出置换</strong>，最先进入内存的页面最先被淘汰</p><h3 id="通道技术"><a href="#通道技术" class="headerlink" title="通道技术"></a>通道技术</h3><p>独立于CPU，在内存和I/O设备间交换数据，启动时由CPU执行相应指令启动，结束时向CPU发送中断信号<br>DMA(直接存储器访问)：将数据成块的传递给CPU，例如使用键盘输入的时候，CPU不用一直等待，可以去处理其他任务</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>一级文件称为主文件目录，二级称为用户文件目录<br>二级目录的优缺点-优：解决了文件的重名问题，查找时间减少，实现不同用户间的文件共享；缺：增加了系统开销<br>索引文件结构既适合顺序存储，也适合随机存储<br>逻辑文件可以采用的逻辑方式是记录式文件和流式文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）同步与互斥</title>
      <link href="/2019/10/14/os4/"/>
      <url>/2019/10/14/os4/</url>
      
        <content type="html"><![CDATA[<h3 id="进程间相互作用"><a href="#进程间相互作用" class="headerlink" title="进程间相互作用"></a>进程间相互作用</h3><h4 id="相关进程和无关进程"><a href="#相关进程和无关进程" class="headerlink" title="相关进程和无关进程"></a>相关进程和无关进程</h4><p>有逻辑相关的即相关进程，无关进程同理，并发的进程间不一定有逻辑关系</p><h4 id="与时间有关的错误"><a href="#与时间有关的错误" class="headerlink" title="与时间有关的错误"></a>与时间有关的错误</h4><p>例如两个不同的程序运行，它们都共同使用的一个名为”n”的变量，因为两个程序是在交替运行的，使用同一个变量很容易发成错误，这类错误统称与时间有关的错误。</p><h3 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h3><h4 id="同步关系"><a href="#同步关系" class="headerlink" title="同步关系"></a>同步关系</h4><p>为了完成某种工作，进程间经常需要合作。例如一批数据记录需要加工处理，为此创建两个进程，还设置了容量为一个记录单位的缓冲器。进程A在硬盘上读取记录，每读出一个记录就存入缓冲区，进程B从缓冲区内取出数据加工，直到所有记录都处理完毕<br>当然它们是在并发运行，而且在同时使用缓冲区，如果不对它们进行制约就会发生冲突，运行速度也是关键，若A的速度比B快，则有可能丢失数据等错误发生，所以协调它们的节奏非常重要</p><h4 id="互斥关系"><a href="#互斥关系" class="headerlink" title="互斥关系"></a>互斥关系</h4><p>与前文相同，试图调用如打印机等单一访问的设备时应该要产生互斥</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>系统中的某些资源一次只允许一个进程访问，则这类资源称为<strong>临界资源或共享变量</strong>而在进程中访问临界资源的程序称为<strong>临界区</strong><br>系统对临界区的调度使用原则归纳如下：<br>1.临界区为空时，有一个进程要求访问应立即允许其进入<strong>有空让进</strong><br>2.有一个进程处于临界区时，其他请求进入的进程必须等待<strong>无空等待</strong><br>3.临界区空闲，而多个进程请求访问时只允许其中一个进入，其他的必须等待<strong>多种择一</strong><br>4.任一进程进入临界区的要求应在有限的时间内完成<strong>有限等待</strong><br>5.处于等待状态下的进程应主动放弃CPU<strong>让权等待</strong><br>1表示要有效利用临界资源；2反映了互斥的含义，资源具有排他性；3是1和2的一个特殊情况；4、5是为了避免进程间发生忙等待或死锁</p><h3 id="信号量与P、V操作"><a href="#信号量与P、V操作" class="headerlink" title="信号量与P、V操作"></a>信号量与P、V操作</h3><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是种特殊的变量，它的表面形式是<strong>一个整形变量加一个队列</strong>，并且只能被P、V操作使用，P、V操作都是原语（P是荷兰语”等待”的首字母，而V是”发信号”的首字母）。</p><h4 id="P、V操作"><a href="#P、V操作" class="headerlink" title="P、V操作"></a>P、V操作</h4><p>定义如下<br>P(S)<br>{<br>    S = S-1;<br>}<br>若S&lt;0，将该进程状态置为等待，然后再PCB中插入响应的S信号量等待队列末尾，直到其他进程再S上执行V操作<br>V(S)<br>{<br>    S = S+1;<br>}<br>若S≤0，释放再S信号量队列中等待的一个进程，将其状态改变为就绪态，并将其插入就绪队列；然后执行本操作的进程继续执行；<br>S即表示某类可用的临界资源，当S&gt;0时表示该类资源可以分配，S&lt;0时表示没有可分配的资源数量，其<strong>S的绝对值表示排在S信号量的等待队列中进程的数目</strong><br>每执行一次P操作，意味请求的进程分配到一个资源，每执行一次V操作，意味该进程释放了一个资源</p><h4 id="用P、V操作实现进程间的互斥"><a href="#用P、V操作实现进程间的互斥" class="headerlink" title="用P、V操作实现进程间的互斥"></a>用P、V操作实现进程间的互斥</h4><p>S = 1<br>进程A、B都执行：<br>P(S);<br>    operation;<br>V(S);</p><h4 id="用P、V操作实现进程间的同步"><a href="#用P、V操作实现进程间的同步" class="headerlink" title="用P、V操作实现进程间的同步"></a>用P、V操作实现进程间的同步</h4><p>例如存在两个信号量S1与S2<br>赋值为 S1 = S2 = 0    //S1表示在一个缓冲区内是否装满信息，S2表示该区中的信息是否取走<br>程序A<br>while(true){<br>    msginput;<br>    V(S1);<br>    P(S2);<br>};</p><p>程序B<br>while(true){<br>    P(S1);<br>    msgoutput;<br>    V(S2);<br>};<br>因为程序的交替执行，可以看出A先将信息放入缓冲区然后释放它，随后切换到B请求并取出，然后再检查缓冲区，如此循环<br>三进程或以上的情况见P118附图</p><h4 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h4><p>一、简单消费者问题<br>二、多个消费者问题<br>三、读写机制问题<br>四、综合应用-路口单双号交通管制<br>五、物流系统物品分拣问题</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>单纯使用PV操作有诸多问题，于是引入管程的概念；<br>管程的四个部分为管程名称、共享数据说明、对数据操作的一组过程和对共享数据赋初值的语句；类似面对对象程序语音中的类，定义了其中的初始属性和方法(函数)<br>管程主要有三个特性：<br>1.模块化，管程时一个基本程序单位，可单独编译<br>2.抽象数据类型，管程是一种特殊的数据类型，不仅有数据，而且有对数据进行操作的代码<br>3.信息隐蔽，管程是半透明的，他能实现某种功能，但具体的实现方式外部并不知道也没有必要知道</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）进程与线程</title>
      <link href="/2019/09/01/os3/"/>
      <url>/2019/09/01/os3/</url>
      
        <content type="html"><![CDATA[<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><h4 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h4><p>程序是指在一个时间上按严格次序前后相继的<strong>操作序列</strong>，程序的顺序执行有如下特点<br>顺序性-程序所规定的动作再机器上严格地按顺序执行。每个动作的执行都以前一个动作的结束为前提<br>封闭性-程序运行后的计算结果只和程序自己有关，不受外界影响<br>执行结果的确定性-程序执行的结果和执行时间无关，中断不会影响结果<br>执行结果的可再现性-只要输入的初始条件相同，不论运行多少次结果都是一样的</p><h4 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h4><p>资源的共享和竞争存在于多道程序的并发中，从而制约了各道程序的执行速度；并发程序会出现“执行-暂停-执行”的活动现象<br>程序与计算不再一一对应，一个编译程序可为几个用户提供编译服务<br>执行结果不可重现-并发执行的结果会因为多道程序之间的相互制约关系导致不确定<br>程序的并发和并行执行与第一章的说法相同，并发为宏观，并行为微观</p><h4 id="多道程序设计-1"><a href="#多道程序设计-1" class="headerlink" title="多道程序设计"></a>多道程序设计</h4><p>与先前提到的一样，是为了减少设备的空转提高利用率采用多道程序设计，举一个例子<br>程序A的执行顺序为：CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)，共40s<br>程序B的执行顺序为：设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)，共40s</p><p>若是<strong>顺序执行</strong>则肯定要么先执行A后执行B，要么先B后A<br>所以执行情况为【CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)】→【设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)】，共80s<br>CPU、设备1和设备2的利用率分别为50%、18.75%和31.25%<br><strong>并发执行</strong>时为<br> CPU(10s)   →设备1(5s)        →CPU(5s)   →      设备2(10s)   →CPU(10s)<br>设备2(10s)  →     CPU(10s)    →设备1(5s) →CPU(5s)            →设备2(10s)<br>共45s，CPU、设备1和设备2的利用率分别为89%、33%和56%</p><p>特点：目的是提高整个系统的效率，提高系统吞吐量（指单位时间内系统处理的进程的道数）<br>拥有<strong>独立性</strong>、<strong>随机性</strong>和<strong>资源共享性</strong>等特征；缺点是在某些情况下延长了程序的执行时间，如上面的例子，程序A本可以40s内执行完，应用在多道技术后延长至45s，在特定的程序内这5s是非常致命的</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>进程是具有<strong>一定独立功能的程序</strong>在某个数据集合上的一次<strong>运行活动</strong>，是系统进行资源分配和调度的一个<strong>独立单位</strong><br>进程由<strong>程序</strong>、<strong>数据</strong>和<strong>进程控制块（PCB）</strong>三部分组成；程序是静态的、线程是动态的；线程为了程序而存在；进程也可以创建进程，被创建的叫子进程，创建者叫父进程<br>一个能被多个用户同时调用的程序称作<strong>可再入的程序</strong>，此程序在执行过程中不会修改自身的代码；现代的操作系统和编译程序都属于可再入程序<br>进程的几个特性<br>并发性-进程的第一个动作可以在上一个进程最后一个动作之前开始<br>动态性-进程有生命周期，状态不断在发生变化<br>独立性-进程是一个相对完整的资源分配单位<br>交往性-一个进程在运行过程中可能和其他进程发生直接或间接的相互作用<br>异步性-每个程序按照各自独立的、不可预知的速度往前推进<br>结构性-由程序、数据和进程控制块组成</p><h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><p><strong>三状态模型</strong><br>此模型下的进程可以有以下三种状态之一，在任何时刻，任何进程都处于且仅处于三种状态之一<br>运行-进程已经获得处理器，并在处理器上执行的状态；在分时操作系统中，正在运行的程序的时间片使用完后会发出中断请求并将进程转为就绪或等待状态<br>就绪-已经具备运行条件，但还没有空闲的处理器分配给他，当处理器空闲时会根据调度算法把处理器分配给其中一个就绪的进程<br>等待-进程因为等待某个时间而暂时不能运行的状态，当事件结束时转为就绪状态等待分配处理器<br><strong>五状态模型</strong><br>运行-进程占用完CPU的资源，道数≤CPU数量；通常没有其他进程执行时（如所有进程都在阻塞状态），会自动执行空闲进程<br>就绪-与上述一致，I/O设备会排入高级优先队列<br>阻塞-进程等待I/O操作或进程同步等条件而暂停运行，条件满足前即使分配了处理器也无法运行，排成一个阻塞队列<br>创建-在此状态的工作有分配和建立进程控制块表项、建立资源表格并分配资源，加载程序并建立地址空间等；<em>创建至就绪称为提交</em><br>结束-进程结束后回收<strong>除进程控制块</strong>之外的其他资源，并让其他进程从进程控制块中收集有关信息；<em>运行至结束称为释放</em><br><strong>七状态模型</strong><br>七状态模型区分内外存<br>就绪、阻塞、创建、退出（结束）-一致<br>阻塞挂起-进程在外存并等待时间出现；<em>阻塞至阻塞挂起：没有就绪进程或就绪进程需要更多内存资源</em><br>就绪挂起-进程在外存，但只要进入内存即可运行；<em>就绪至就绪挂起：高优先级阻塞进入低优先级就绪时会就绪挂起；运行到就绪挂起：与前面一致，不过对象时在运行的进程</em><br>挂起-把进程从内存转到外存<br>激活-把进程从外存转入内存</p><h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>PCB是进程重要的组成部分，它包含<strong>调度信息</strong>和<strong>现场信息</strong>两部分<br>调度信息中包括了进程号和进程名-作用是标识一个进程，每个进程号都是唯一的<br>地址信息空间-记录了系统为每个进程分配的一个地址空间<br>优先级-确定的优先级信息<br>当前状态-表明是现在是就绪、等待还是运行状态<br>资源清单-包含了进程执行所需的资源<br>“家族”关系-包含了其父进程和子进程关系<br>消息队列指针-表明进程所属的消息队列所在的地址，消息队列的作用是与其他进程进行通讯<br>进程队列指针-指出现在进程所在队列的位置<br>当前打开文件-记录进程使用文件的情况<br>PCB大致有三种组织方式<br>线性-将所有PCB组织在一个连续表上，简单不需要额外开销，缺点是找一个PCB时需要遍历整个表<br>索引-对具有相同状态的线程，分别设置PCB表，表目是每个PCB的地址，就构成了索引表和被索引表<br>链接-对相同状态线程-利用PCB中的链接字构成队列，链接字指出PCB在表中的编号，与索引类似<br>进程的队列根据状态分为就绪队列、等待队列和运行队列<br>队列的具体组成和链表类似，都是利用单向或双向指针来进行索引，当然在表头有一个头指针；线程的出/入队操作都和链表的操作集合一样</p><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>进程状态的切换具体是由<strong>原语</strong>进行实现的，原语是系统的核心功能，运作在管态，常驻于内存；原语和系统调用都可被进程调用，不过原语有<strong>不可中断</strong>的特性<br>用于进程控制的原语有：<br>创建原语-可以创建一个进程并构造父子关系；其主要任务是申请一块空闲的PCB区域，然后将信息填入PCB，置该进程于就绪状态插入队列<br>撤销原语-进程完成后释放资源并撤销PCB；具体过程是找到该PCB的位置后移出队列，撤销它的所有子孙队列，释放全部资源，最后撤销PCB<br>阻塞原语-执行I/O操作，将运行换至阻塞；过程是中断处理器的执行，保存PCB的现场信息，将进程状态切换并置入等待队列<br>唤醒原语-等待事件的进程用唤醒原语转换至就绪状态；在队列中找到PCB，切换状态，然后从等待队列出队置入就绪队列</p><h4 id="实例：Unix操作系统的进程创建操作fork"><a href="#实例：Unix操作系统的进程创建操作fork" class="headerlink" title="实例：Unix操作系统的进程创建操作fork"></a>实例：Unix操作系统的进程创建操作fork</h4><p>待补充</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>为了减少程序并发执行所付出的时间和空间的开销，人们引入了线程的概念。线程是进程中的一个实体，是处理器调度和分派的<strong>基本单位</strong>，线程基本不拥有资源，只占有必须的少量资源，但他可以使用所处进程下的所有资源。<br>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程可以并发执行，同样有就绪、等待和运行三种状态。<br>线程有以下属性：<br>1.每个线程为一个唯一的标识符和一张线程描述表，记录了线程执行的寄存器以及栈等现场状态<br>2.不同的线程可以执行相同的程序，也就是同一个服务被不同用户调用时创建两个不同的线程<br>3.同进程中的各个线程共享进程的内存空间<br>4.线程是CPU的基本调度单位，可以并发执行；单核可交替占用处理器，多核多线程可占用不同的处理器，若多个核心为一个进程运算，那么会减少计算时间<br>5.线程在创建后拥有一个生命周期，周期内会经历就绪、等待和运行多种状态的切换，直至周期终止<br>引入线程的好处：<br>1.创建新线程所需要的时间少，而且不必重新分配资源<br>2.线程相互切换所需的时间少<br>3.因同进程内的线程共享内存空间，所以线程之间交换数据不必调用内核，效率更高<br>4.线程能独立运行，能充分发挥处理器和io设备的并行工作能力</p><h4 id="线程的实现机制"><a href="#线程的实现机制" class="headerlink" title="线程的实现机制"></a>线程的实现机制</h4><p>用户级线程：<br>只存在于用户态中，对其的创建、撤销和切换都<strong>不会</strong>通过系统调用来实现。优点是有些操作系统不支持线程，但因为这种线程存在于目态，也可以用函数库实现线程<br><strong>线程表</strong>：用来跟踪该进程中的线程，和PCB类似，不过仅仅记录各个线程的属性，如程序计数器、堆栈指针、寄存器和状态等。当一个线程转换到就绪或者阻塞时，就在表中存放重新启动该线程时所需要的信息。<br>内核级线程:<br>内核级和用户级的区别基本上在于进程中的线程表分别存放在核心态和用户态，内核级线程的切换效率会稍低些<br>混合实现方式：<br>一些系统混合使用了用户级和内核级线程，实例P99</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>实际情况下，进程的数量是多于处理器数量的，如何做好调度是关键</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>根据一定的调度算法，在就绪队列中选出一个进程将PCB中相关信息放入寄存器中，并分配处理器运行。<br>调度的时机一般有：<br>正在执行的进程运行完毕<br>正在执行的进程因某种错误终止<br>时间片用完，进程从运行转为就绪状态<br>正在执行的进程用阻塞原语将自己阻塞起来<br>创建了新进程进入了就绪队列<br>正在执行的进程用唤醒原语激活了等待队列的进程使其归入就绪队列</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>进程行为</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）运行环境</title>
      <link href="/2019/08/31/os2/"/>
      <url>/2019/08/31/os2/</url>
      
        <content type="html"><![CDATA[<h3 id="处理器（CPU）"><a href="#处理器（CPU）" class="headerlink" title="处理器（CPU）"></a>处理器（CPU）</h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>一般由运算器、控制器一系列的寄存器以及高速缓存构成<br>其中<strong>运算器</strong>能实现指令中的算术和逻辑运算；<strong>控制器</strong>负责程序运行的流程，包括取指令、维护处理器状态、处理器和内存的交互等；<strong>寄存器</strong>是一种暂时存储的器件，用于存储运行指令过程中暂存数据、地址以及指令信息<br>寄存器的运行速度比内存快上许多，寄存器通常分为两种：<br>用户可见寄存器-编译器可以调用这些寄存器，减少使用内存的次数以提高程序运行的效率<br>控制和状态寄存器-包括数据寄存器、地址寄存器和条件码寄存器，数据寄存器存储算术逻辑指令和访存指令；地址寄存器储存数据和指令的物理地址、线性地址或者有效地址；条件码存储器保存运算后的各种标记，如溢出、符号等</p><h4 id="指令执行的基本过程"><a href="#指令执行的基本过程" class="headerlink" title="指令执行的基本过程"></a>指令执行的基本过程</h4><p>首先处理器每次从存储器中读取一条指令，并根据指令类别将程序计数器的指改为下一条指令的地址（通常情况下指令在内存中都是连续的，所以大多是自增1）；其次指令被存储到指令寄存器中，然后处理器解释并执行，这就被成为一个指令周期<br>程序的执行就是不断地取指令→存指令→执行指令组成的，只有机器关机、发生未知错误或遇到停止指令时机器才会停止<br>指令大概分为五类（与特权非特权不同）<br>访问存储器指令-负责存储器和处理器间的数据传送<br>I/O指令-负责处理器和I/O模块间的数据和命令发送<br>算术逻辑指令-执行数据的算术和逻辑操作<br>控制转移指令-可以指定一个<strong>新的</strong>指令的<strong>执行地点</strong><br>处理器控制指令-用于修改处理器状态，改变其工作方式（即目态和管态的切换）</p><h4 id="特权与非特权指令"><a href="#特权与非特权指令" class="headerlink" title="特权与非特权指令"></a>特权与非特权指令</h4><p>用户不允许随意使用特权指令，以免造成系统的混乱；特权指令一般包括：<em>设置程序状态字、启动某种设备、设置中断屏蔽、设置时钟指令、清理内存和建立存储保护指令等</em>，用户只能间接的使用这些指令，每次使用时就需要将CPU的状态从目态切换至管态，这一过程被称为陷入（Trap）<br>操作系统运行的过程中目态和管态是在动态切换的，<strong>目态至管态</strong>的切换只能通过<strong>中断</strong>来进行，中断响应时交换中断向量，新的中断向量中的PSW（程序状态字）状态位标为管态；<strong>管态至目态</strong>直接修改PSW即可，不必经历中断<br>系统启动时，CPU的<strong>初始状态为管态</strong>，后装入操作系统后，让用户在目态执行</p><h4 id="程序状态字PSW"><a href="#程序状态字PSW" class="headerlink" title="程序状态字PSW"></a>程序状态字PSW</h4><p>有一个专门的寄存器来寄存处理器的状态；如程序计数器就来指示下一条要执行的指令<br>通常包括以下几个状态代码：<br>CPU的工作状态代码-指明是目态还是管态<br>条件码-反应指令执行后的结果特征<br>中断屏蔽码-指出是否运行中断</p><h3 id="硬件部件"><a href="#硬件部件" class="headerlink" title="硬件部件"></a>硬件部件</h3><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><p>基本上可以划分为两类：读写型的存储器和只读型的存储器<br>读写型的可以将数据存入任一地址单元并任意去取出或重新载入，即随机访问存储器（RAM）<br>只读型不能随意写入数据，称为只读存储器（ROM），还有PROM和EPROM等变种，PROM可用特殊的写入器写入，EPROM可用特殊的紫外线“擦去”信息位，再用写入器写入<br>存储的最小单位是1位（bit）只能存储1或0，<strong>一个字节包含8位</strong>，两个字节称为一个字，四个字节称为双字，1024个字节则为1KB，类推出MB、GB等<br>存储系统的设计要考虑三个问题：<strong>容量、速度和成本</strong><br>一般情况下，速度越快价格越高容量越小；速度越慢价格越低容量越大，合理分配计算机存储硬件等级也是值得考虑的，一般情况下<strong>寄存器&gt;高速缓存&gt;内存&gt;硬盘&gt;磁带、光驱</strong>比较合理<br>内存的保护<br>利用界地址寄存器来存储作业在内存中的上限和下限地址，当处理器访问内存时对比现请求的内存和已经在使用的内存是否越界，若越界则产生程序中断</p><h4 id="I-O部件"><a href="#I-O部件" class="headerlink" title="I/O部件"></a>I/O部件</h4><p>早期计算机是用CPU轮流询问硬件是否有处理请求后再处理，这种方式效率过低被淘汰<br>如今则采用<strong>通道</strong>的方式，通道是独立于CPU的，各种外部设备的设备控制器通过通道连接到系统的公共系统总线上；通道代替CPU处理I/O操作，使得外部设备和处理器可以<em>并行</em>工作；通道又被称为<strong>I/O处理器</strong><br>当CPU处理到“启动外设”的命令时就启动外设并将控制权交给通道，外设和内存的数据交换直接由通道控制，不经过CPU；外设工作结束后，形成一个“输入输出操作结束”的I/O中断事件，由CPU处理结束<br>这样大大提高了运行效率，不让设备和CPU空转运行；还会使用<strong>直接存储器访问（DMA）</strong>技术，DMA是一个总线中的一个独立的控制单元，自动控制成块的数据在内存和I/O单元间传送。处理器需要读取设备数据时给DMA发一条命令后可以处理其他事情，当DMA整理好数据发送过来时会触发中断来接收数据，这条命令通常包括设备的编址、开始读写的内存编制，需要传送的数据长度、是否请求读写等信息<br>当DMA和CPU在总线上冲突时，CPU会稍微等待一下<br>因为CPU的处理速度远远超过数据的输入输出速度，不可能在键盘敲下一个键就执行一次指令，这样大大浪费了CPU的速度，所以采用<strong>设立缓冲区</strong>的方法输入一定量的数据后再一次性传送给CPU</p><h4 id="时钟部件"><a href="#时钟部件" class="headerlink" title="时钟部件"></a>时钟部件</h4><p>计算机系统中时间部件是必要的，可以为系统发现一个死循环的程序，实现分时和实时系统、定时唤醒事先给定的外部事件、记录用户使用设备的时间和事件发生间隔以及记录绝对时间年月日等<br>时间部件一般分为硬件时钟和软件时钟，硬件则是利用电路中的晶体震荡器，每隔一段时间激发出一个频率的脉冲，时钟寄存器就不停对这个电路执行+1的操作，当计算机关机时，利用纽扣电池仍然在不停计时；软件则是利用程序来进行计时，系统需要同步硬件和软件时钟，绝对时间是执行+1操作，而相对时间执行-1操作（即倒计时）</p><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><h4 id="中断与异常的概念"><a href="#中断与异常的概念" class="headerlink" title="中断与异常的概念"></a>中断与异常的概念</h4><p><strong>中断</strong><br>CPU对系统内外发生的异步事件的响应即中断，异步事件指无一定顺序关系随机发生的事件；中断时实际意义是发生了异步事件后CPU中断当前程序转而处理异步事件，处理完后再回来执行先前的程序；几种名词的解释：<br>中断事件/中断源-引起中断的事件<br>中断请求-中断源向CPU发出的请求信号<br>中断处理程序-处理中断事件的程序<br>中断断点-原先程序的暂停点<br>中断响应-CPU暂停原先程序去处理中断的<em>过程</em><br>中断返回-处理结束后恢复原先程序的执行<br>中断字-计算机系统提供的中断源的有序集合，存在逻辑结构，不同处理器有不同的实现方式，Intel的x86处理器能处理256种中断<br>中断向量表-表中的每一项称为一个中断向量，主要有PSW和指令计数器PC组成，不同性质的中断源有不同的PSW和PC，通过此表找到相应的中断处理程序<br>中断技术的应用使得CPU运行效率提高，不用到处询问是否有事件发生，只要等待中断并且处理<br><strong>异常</strong><br>中断和异常的差别主要在中断是由外部事件引发的，而异常指由正在执行的指令引发的<br>中断的分类<br>时钟中断-按一定函数中断事件寄存器<br>输入输出（I/O）中断-硬件完成使用或期间引发的错误<br>控制台中断-操作员通过控制台发出命令<br>硬件故障中断-如断电存储器校验错误等<br>异常的分类<br>程序性中断-如溢出，除零，目态试图使用特权指令，访问不存在的目录等<br>访管指令异常-要求操作系统提供系统服务等</p><h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p>中断系统分为两个部分<br>硬件中断装置-负责捕获中断源发出的中断请求，以一定方式响应中断源，然后将处理器的权限转接给软件中断程序<br>软件中断程序-根据中断事件的性质执行相应的操作<br>请求的接收基本原理是通过中断逻辑线路接受并寄存到硬件触发器中，中断寄存器中包含了多种中断位，每一个中断位对应一种中断源<br>相应的具体过程是处理器接收中断信号→保护现场，将中断断点的PSW和PC存入系统堆栈→分析接收的中断向量，取得中断处理程序的地址→将CPU的PC设为此地址→调用中断处理程序→处理完后恢复现场原有程序继续运行<br>几种典型的中断处理<br>I/O中断-设备的唤醒和结束都会引发一次中断，多次引发会判断为设备故障通知管理员<br>时钟中断-控制定时任务和进程的处理器时间配额、处理器调度、维护软件时钟和实时处理<br>硬件故障中断-硬件问题引发的中断<br>程序性中断-指令出错、越权或越界而引发的系统保护；程序性中断可由系统完成也可以由程序自己完成<br>系统服务请求（自愿性中断）</p><h4 id="中断优先级、中断屏蔽和中断嵌套"><a href="#中断优先级、中断屏蔽和中断嵌套" class="headerlink" title="中断优先级、中断屏蔽和中断嵌套"></a>中断优先级、中断屏蔽和中断嵌套</h4><p>优先级-连接在不同的<strong>中断请求线</strong>上的中断信号，表示它们有不同的中断级别，硬件就决定了各个中断的优先级；例如电池即将没电，这类中断的优先级高于大多数中断；若同级中断有两种优先方法：一是硬件固定的优先数；二是轮转法<br>屏蔽-有些情况下一个中断在执行的时候，处于它级别低或者不会发生的中断都会被屏蔽；还有一类不可屏蔽的中断信号，屏蔽由卸载PSW中的中断屏蔽位中<br>嵌套-处理器在处理一个中断程序时又接收到一个中断信号时会有两种响应方式：<br>一是上述的中断屏蔽-新来的中断级别低于或相等于现在处理的中断等级<br>二就是中断嵌套；新来的中断级别高度现处理的中断，会类似递归一般在上个中断中再进行一次中断处理，处理过程和一般情况无异</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用时系统提供给用户访问特权指令的<strong>唯一接口</strong>，通过调用把CPU从目态切换至管态</p><h4 id="系统调用和函数调用的区别"><a href="#系统调用和函数调用的区别" class="headerlink" title="系统调用和函数调用的区别"></a>系统调用和函数调用的区别</h4><p>函数调用下-调用程序和被调用程序都运行在目态；系统调用下-调用程序在目态，而被调用程序在管态<br>因为不同调用运行在不同的状态，所以系统调用下的调用程序不能<strong>被</strong>调用，需要通过中断切换状态<br>系统调用也可以嵌套调用，不过嵌套的深度各有区别</p><h4 id="系统调用的分类"><a href="#系统调用的分类" class="headerlink" title="系统调用的分类"></a>系统调用的分类</h4><p>进程控制类-创建和终止<strong>进程的系统调用、获得和设置进程属性</strong>的系统调用<br>文件操作类-创建、打开、关闭和读写文件；创建目录以及移动文件的读写指针、改变文件的属性等<br>进程通信类-用于进程间传递信息和信号<br>设备管理类-用于请求和释放有关设备，以及启动设备操作等<br>信息维护类-用于获得当前时间和日期、设置文件访问和修改时间、了解当前用户数、系统版本号、空闲的内存磁盘等信息</p><h4 id="与库函数、API、内核函数的关系"><a href="#与库函数、API、内核函数的关系" class="headerlink" title="与库函数、API、内核函数的关系"></a>与库函数、API、内核函数的关系</h4><p>以库函数、API和内核函数为接口使用户能够调用特权指令</p><h4 id="系统调用的处理过程"><a href="#系统调用的处理过程" class="headerlink" title="系统调用的处理过程"></a>系统调用的处理过程</h4><p>与中断类似，不过这个过程称为陷入<br>当处理器执行到陷入指令时，首先调用中断，通过中断向量表把控制权交给系统调用总入口程序，该程序会进行现场保护和数据存入堆栈等操作，然后再查看<strong>系统调用表</strong>把控制权移交给相应的系统调用畜栏里例程或内核函数，执行完后恢复现场并返回用户程序</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）概论</title>
      <link href="/2019/08/27/os1/"/>
      <url>/2019/08/27/os1/</url>
      
        <content type="html"><![CDATA[<h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统是集中了<em>资源管理功能</em>和<em>控制程序执行功能</em>的一种<strong>软件</strong><br>意为能有效的组织和管理计算机系统的硬件和软件资源，合理地组织计算机工作流程，控制程序地执行，并向用户提供各种服务功能，使得用户能够灵活、方便、有效地使用计算机，并使整个计算机系统能高效地运行。</p><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><h4 id="1-并发性"><a href="#1-并发性" class="headerlink" title="1.并发性"></a>1.并发性</h4><p>指在系统中<em>同时</em>存在若干个运行着的程序，从<strong>宏观</strong>上看，这些程序在同时向前推进。<br>（并行性-指两个或两个以上的事件在同一时刻发生，是具有<strong>微观</strong>意义的同时，并发只是多个程序交替进行，是一种<em>假象</em>的同时）</p><h4 id="2-共享性"><a href="#2-共享性" class="headerlink" title="2.共享性"></a>2.共享性</h4><p>指操作系统和多个用户共用系统中的各种资源<br>    a.互斥共享-如打印机、扫描仪等，在一段时间内只能由某一个用户程序使用<br>    b.同时共享-如音响等，可以在一段时间内被多个程序同时访问。</p><h4 id="3-虚拟性"><a href="#3-虚拟性" class="headerlink" title="3.虚拟性"></a>3.虚拟性</h4><p>指把物理上的实体变为若干个逻辑上的对应物。前者是实际存在的，而后者是用户感受到的，譬如一个计算机的实际物理内存只有4GB，而同时运行的软件的需要内存早已超过了4GB，采用虚拟存储器技术（空分/时分复用技术）将空间和时间微分并交替进行造成运行内存超过物理内存的假象，与并发性类似。</p><h4 id="4-随机性"><a href="#4-随机性" class="headerlink" title="4.随机性"></a>4.随机性</h4><p>操作系统的运行是建立在随机发生事件的情况下的，操纵系统不能对所运行的程序的行为以及硬件设备的情况做出任何实现的假定。</p><h3 id="研究操作系统的观点"><a href="#研究操作系统的观点" class="headerlink" title="研究操作系统的观点"></a>研究操作系统的观点</h3><h4 id="1-软件的观点"><a href="#1-软件的观点" class="headerlink" title="1.软件的观点"></a>1.软件的观点</h4><p>操作系统是一种软件，是最接近硬件的软件</p><h4 id="2-资源管理的观点"><a href="#2-资源管理的观点" class="headerlink" title="2.资源管理的观点"></a>2.资源管理的观点</h4><p>操作系统负责登记谁在使用什么样的资源，系统中还有哪些资源空闲，当前响应了谁对资源的要求，以及回收了哪些不再使用的资源等。</p><h4 id="3-进程的观点"><a href="#3-进程的观点" class="headerlink" title="3.进程的观点"></a>3.进程的观点</h4><p>把操作系统看成由<em>多个同时独立运行的程序</em>和<em>一个对这些程序进行协调的*</em>核心***所组成。</p><h4 id="4-虚机器的观点（非虚拟机）"><a href="#4-虚机器的观点（非虚拟机）" class="headerlink" title="4.虚机器的观点（非虚拟机）"></a>4.虚机器的观点（非虚拟机）</h4><p>用户通过操作系统来控制硬件，看作一个虚拟的机器</p><h4 id="5-服务提供者的观点"><a href="#5-服务提供者的观点" class="headerlink" title="5.服务提供者的观点"></a>5.服务提供者的观点</h4><p>为用户提供服务的提供者</p><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><h4 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1.进程管理"></a>1.进程管理</h4><p>进程管理的实质是<strong>对中央处理器进行管理</strong>，为了描述多道程序的并发执行，就要引入进程的概念。<br>    a.进程控制-即进程创建时要分配其资源，进程结束时回收其资源<br>    b.进程同步-多个进程是并发的，并且以<em>异步</em>的方式运行，所以执行速度是不能确定的。为了宏观上同步就要对进程进行协调。主要有<em>互斥</em>和<em>同步</em>两种方式，在遇到硬件是否冲突的时候协调他们的运行顺序。其中一个方法是调用<em>原语</em>中的资源加锁语句。<br>    c.进程间通信-操作系统提供进程间相互交换数据的手段<br>    d.调度-即从进程（线程）的就绪队列中按照一定算法调出一个并分配资源让他执行</p><h4 id="2-存储管理"><a href="#2-存储管理" class="headerlink" title="2.存储管理"></a>2.存储管理</h4><p>任务是管理计算机中的内存<br>    a.内存的分配和回收<br>    b.存储保护-已经使用的内存不会被再次调用<br>    c.内存扩充-即空分复用技术</p><h4 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3.文件管理"></a>3.文件管理</h4><p>对硬盘的管理<br>    a.文件存储空间的管理（常采用离散分配的方式，以512B或几KB为单位进行分配）<br>    b.目录管理<br>    c.文件系统的安全性</p><h4 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4.设备管理"></a>4.设备管理</h4><h4 id="5-用户接口"><a href="#5-用户接口" class="headerlink" title="5.用户接口"></a>5.用户接口</h4><h3 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows<img src="/2019/08/27/os1/win.JPG"></h4><p>1.内核-提供线程调度、陷入处理和异常调度、中断处理和调度、多处理器同步、供执行体使用的基本内核对象<br>2.硬件抽象层-将硬件的接口封装成一个可加载的核心态模块，隐藏细节，作为黑箱一般，只要调用即可<br>3.执行体-处于内核上层，可调用函数执行<br>4.系统进程和线程</p><h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix<img src="/2019/08/27/os1/unix.JPG"></h4><p>1.内核层-常驻于内存，下接硬件接口，上接shell接口。本身分为两大部分，一部分为进程控制子系统，一部分为文件子系统<br>2.系统调用层-可进行文件管理，终端状态和进程管理等<br>3.应用层-即应用通过shell再通过系统调用层访问硬件，所有应用都基于shell运行</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux<img src="/2019/08/27/os1/linux.JPG"></h4><p>1.内核-负责管理系统的进程、内存、设备驱动、文件和网络系统<br>2.shell-是一个命令解释器，将用户输入的指令直接解释给内核执行<br>3.文件系统-即文件在硬盘等存储设备上的组织方法<br>4.应用程序-最上层的应用程序一般都有图形界面，包括有文本编辑器、办公套件等软件</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android<img src="/2019/08/27/os1/and.jpg"></h4><p>1.应用程序-由Java编写的如电话、短信等自带程序<br>2.应用框架-为开发者提供可以访问各类API的框架，只要程序遵循这个框架就能安全的通过API访问核心功能<br>3.C/C++本地库和运行环境-程序在安装时实际上是一个由Java编译至机器码的过程，通过框架得知所需的功能后再从库中查找功能<br>4.Linux内核-包括系统层的安全机制、内存管理、进程管理、网络堆栈及一系列其他模块</p><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><h4 id="1-手工发展"><a href="#1-手工发展" class="headerlink" title="1.手工发展"></a>1.手工发展</h4><p>打孔二进制放入机器运行，这种形式运行一个程序时占用整个计算机的全部资源</p><h4 id="2-监控程序"><a href="#2-监控程序" class="headerlink" title="2.监控程序"></a>2.监控程序</h4><p>程序可以监督一个作业是否完成，可将多个作业打包排队运行，不必一个一个存入取出，即早期的批处理</p><h4 id="3-多道批处理"><a href="#3-多道批处理" class="headerlink" title="3.多道批处理"></a>3.多道批处理</h4><p>输入输出和处理器操作可以并行处理，只要一个硬件空余就执行下个可执行的作业（类似工程中的流水节拍）</p><h4 id="4-分时与实时系统"><a href="#4-分时与实时系统" class="headerlink" title="4.分时与实时系统"></a>4.分时与实时系统</h4><p>当遇到多个用户同时使用一个计算时就需要将时间微分交替为每个用户服务；实时系统用在对时间要求严格的场景中</p><h4 id="5-Unix操作系统"><a href="#5-Unix操作系统" class="headerlink" title="5.Unix操作系统"></a>5.Unix操作系统</h4><p>Unix是使用C语言编写的，可移植性很强；是一个良好的、通用的、多用户、多任务、分时操作系统，同时有shell解释命令和编写程序</p><h4 id="6-个人计算机操作系统"><a href="#6-个人计算机操作系统" class="headerlink" title="6.个人计算机操作系统"></a>6.个人计算机操作系统</h4><p>如Linux和Windows都是如今流行的个人操作系统</p><h4 id="7-Android系统"><a href="#7-Android系统" class="headerlink" title="7.Android系统"></a>7.Android系统</h4><p>基于Linux发展的移动平台操作系统</p><h3 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h3><h4 id="1-批处理操作"><a href="#1-批处理操作" class="headerlink" title="1.批处理操作"></a>1.批处理操作</h4><p>即早期的批处理系统，将作业成堆的输入计算机执行后输出；在整个程序的头部有一份作业控制说明书，其中写明了各个作业的执行顺序，类似于以下形式：<br>    STEP1    ASM        A<br>    STEP2    FTN     B<br>    STEP3    LINK    A, B, C<br>    STEP4    RUN        C<br>    意为A由汇编语言编译，B由Fortran编译，将A和B连成C，最后运行C<br>一般指令和特权指令<br>    中央处理器（CPU）有两个运行状态，用户态（目态）和核心态（管态），特权指令只能在核心态时执行，一般指令在两个状态都能执行；特权指令包括输入/输出指令、停机指令等，应用程序只能间接调用这些功能，当需要调用这些功能时，监控程序移动到这个部分，再将目态切换至管态，执行后监控程序复原，管态切至目态<br>SPOOLing技术<br>    自动根据作业控制说明书完成计算机的输入输出部分，不具有并发功能，没有根本上解决输入输出缓慢的问题，只能看作一个高级的I/O接口；当然它为多道批处理的发展提供了基础，表明了能利用空闲的硬件提高效率</p><h4 id="2-分时操作系统"><a href="#2-分时操作系统" class="headerlink" title="2.分时操作系统"></a>2.分时操作系统</h4><p>将时间微分，即具有并发的特性，宏观上实时反馈多个信息；具有多路性、交互性、“独占性”与及时性，用户可以干预每一步的进行</p><h4 id="3-实时操作系统"><a href="#3-实时操作系统" class="headerlink" title="3.实时操作系统"></a>3.实时操作系统</h4><p>同上，具有并行的特性，微观上同时进行，运用在时钟管理、过载保护等地</p><h4 id="4-嵌入式操作系统"><a href="#4-嵌入式操作系统" class="headerlink" title="4.嵌入式操作系统"></a>4.嵌入式操作系统</h4><p>高定制性的操作系统，可根据每个应用场景的不同改变其中的原语、调度算法和内存管理等分配策略，在工业上广泛应用，同时是具有高度统一协调、调度、指挥和控制的系统</p><h4 id="5-个人计算机系统"><a href="#5-个人计算机系统" class="headerlink" title="5.个人计算机系统"></a>5.个人计算机系统</h4><h4 id="6-网络操作系统"><a href="#6-网络操作系统" class="headerlink" title="6.网络操作系统"></a>6.网络操作系统</h4><p>为计算机网络所配置的操作系统，包括网络管理、通信、安全、资源共享等功能</p><h4 id="7-分布式操作系统"><a href="#7-分布式操作系统" class="headerlink" title="7.分布式操作系统"></a>7.分布式操作系统</h4><p>将大量运行同一个操作系统的计算机通过网络连接，再通过调度它们的资源执行任务造成一台计算能力非常强大的计算机的假象，任何一台计算机下线都不影响整个系统的运行</p><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><h4 id="1-整体式结构"><a href="#1-整体式结构" class="headerlink" title="1.整体式结构"></a>1.整体式结构</h4><p>类似将所有功能封装成各个模块，然后整个模块又封装成一个整体，优点是结构紧密，运行效率高，但是这种情况下一个变量进入后没有哪个模块可调用哪个模块不可调用的约定，会造成循环调用，引发错误；整体式结构的特点就在于接口简单直接，但无运行顺序</p><h4 id="2-层次式结构"><a href="#2-层次式结构" class="headerlink" title="2.层次式结构"></a>2.层次式结构</h4><p>为了解决整体式的问题，需要对接口的输入输出做出规范；将模块们分层，本层只能和上层或者下层单向的交换数据，同层间的模块或许能交换数据（不能则是全序），这样子每个层次的功能都可以修改，只要接口的约定不变就不会影响整个系统</p><h4 id="3-微内核结构"><a href="#3-微内核结构" class="headerlink" title="3.微内核结构"></a>3.微内核结构</h4><p>内核功能较少，不像整体式或层次式那样将所有模块封装在一起，而是只封装最核心的部分，这样能对内核的修改非常简便且维护简单，缺点是频繁被调用核心功能，多次在目态和管态间切换，效率低</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的一些前置工作</title>
      <link href="/2019/07/26/Java-config/"/>
      <url>/2019/07/26/Java-config/</url>
      
        <content type="html"><![CDATA[<h3 id="必备下载"><a href="#必备下载" class="headerlink" title="必备下载"></a>必备下载</h3><p>首先是<strong>JDK</strong>，它是Java开发的软件工具包，是必要的文件，请先下载这个：<br>Java SE Downloads: (<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a>)<br>点击网页中央下方有”Java Platform (JDK) 12”描述的的方块图形，然后在下方的这个区域点击涂黄的部分，然后下载<br><strong>“Windows 158.63 MB jdk-12.0.2_windows-x64_bin.exe”</strong><br>或者<br><strong>“Windows 179.57 MB jdk-12.0.2_windows-x64_bin.zip”</strong>中的其中一个,随后安装即可。</p><img src="/2019/07/26/Java-config/JDK1.jpg"><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>按操作依次打开窗口；<br>控制面板中的系统，然后点击左侧涂色的<em>高级系统设置</em></p><img src="/2019/07/26/Java-config/CON1.jpg"><p>随后在弹出的”高级”选项卡中的最下方点击涂色的<em>环境变量</em></p><img src="/2019/07/26/Java-config/CON2.jpg"><p>然后打开的窗口分为用户变量和系统变量上下两个部分，首先对系统变量部分进行操作；首先查看变量中是否有名为<strong>“JAVA_HOME”</strong>的变量，如果没有就点击新建按钮，若有请点击编辑按钮。变量名填写为<strong>“JAVA_HOME”</strong>，变量值填写为你安装JDK<strong>文件夹</strong>的位置，点击确定。</p><img src="/2019/07/26/Java-config/CON3.jpg"><p>之后对用户变量进行操作，选择<strong>Path变量</strong>后点击编辑，新建两个变量值<br><strong>%JAVA_HOME%\bin</strong><br><strong>%JAVA_HOME%\jre\bin</strong><br>点击确定。</p><img src="/2019/07/26/Java-config/CON4.jpg"><p>变量设置完成后，启动CMD直接输入<strong>java -version</strong>或者<strong>java</strong>应该都有反应，<br>不是<strong>“‘java’ 不是内部或外部命令，也不是可运行的程序”</strong>即可。<br>正确配置后的反应为</p><img src="/2019/07/26/Java-config/CMD1.jpg"><img src="/2019/07/26/Java-config/CMD2.jpg"><p>到此为止，必备的操作都已经完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_Note</title>
      <link href="/2019/07/23/Python-Note/"/>
      <url>/2019/07/23/Python-Note/</url>
      
        <content type="html"><![CDATA[<h3 id="与C语言的一些区别"><a href="#与C语言的一些区别" class="headerlink" title="与C语言的一些区别"></a>与C语言的一些区别</h3><p>代码<strong>行首</strong>不要随意插入空格，空格在python中具有缩进含义<br>    缩进在python中表示的是程序的分割<br>    C中是用大括号{}来分割程序,如:<br>    <pre><code>for(int i=0;i&lt;=10;i++){   printf(&quot;Hello World!\n&quot;);   printf(&quot;%d\n&quot;,1+2);}</code></pre><br>    而python中仅仅用缩进表示,如:<br>    <pre><code>for i in range(10)    print(&quot;Hello World!\n&quot;) print(i)#若代码为,如:for i in range(10)    print(&quot;Hello World!\n&quot;) print(i) </code></pre><br>则此时print(i)就不属于for循环中的代码<br>以及一行命令结束后不必用分号声明结束<br>同样是中文字符会报错</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>-#为行注释<br>-‘’’此为<br>段注释<br>以三个分号来声明<br>‘’’</p><h3 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h3><p>变量在声明和定义时不用有类似于int char等数据类型声明，直接将对象的地址赋值给变量如a = 1<br>python中可以删除变量，进行<br>    del a<br>的操作后将a从栈中删除，变量是存储在栈中的，而对象”1”则是存储在堆中的，将a删除后对象”1”仍然存在，但没人使用后会被垃圾回收器删除(删除的实际时间待补充)<br>和c相同可以采用链式赋值法<br>    如 a=b=22<br>这样a和b的值都是22<br>注意，声明变量时，值为[-5，256]区间内的值会被python解释器缓存起来，这样不论时什么变量指向这个对象，都是同一个对象，并不是生成一个新的对象。可用is()  is not()函数验证，这两个函数分别判断两个标识符是否为一个对象和是否不是为一个对象<br>也可采用解包赋值，形如<br>    a,b = b,a<br>意味着a和b的变量互换了，不必在代码中加一个中间变量temp参与互换<br>同时注意，<strong>Python不支持常量</strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>+、-、<em>和c语言相同<br>但由于Python不声明数据类型，所以在除法上有区别<br>如a = 2/3采用浮点计算，就是会将得出的结果保留小数，和float数据类型一样，此时a=0.66..67<br>若采用a = 2//3就是采用整型计算，意味着不保留小数，此时a=0<br>%同样为取模(余数)，但注意+、-、</em>的两者分别是整型和浮点型时默认为浮点型数据计算<br>双星号为幂</p><pre><code>a = 2**3 #**</code></pre><p>就是2的三次方，此时a=8<br>关于科学计数法如3.14就表示为”314E-2”，意为314×10^(-2)<br>注意双斜杠’//‘在C语言中表示注释，在Python中表示整型除法计算</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>python中没有单个字符的概念，只有字符串或者是单个字符的字符串<br>在声明字符串的时候既可以用单引号，也可用双引号<br>形如a = “abc”  a = ‘abc’  都是合法的，这样子可以对一个字符串中同时出现单引号和双引号的情况作临时的解决，并且字符串中支持换行，只要连续三个单引号或双引号就可以在中间换行。<br>例如a = ‘’’abc<br>def<br>“ghi”’’’<br>合法，中间有双引号时也不会冲突，如果还有冲突，就使用转移字符/‘和/“来解决<br>对于字符串也可以使用+、-、<em>来操作，但要注意，+、-时两者必须同为字符串</em><br>在使用print()函数时可采用加一个end来改变要增加的字符(默认为\n)<br>例如 print(“abc”,end=”\t”)<br>在python中使用input()函数来输入</p><pre><code>&gt;&gt;&gt; name=input(&quot;please input your name:&quot;)please input your name:soya&gt;&gt;&gt; print(&quot;Hello，&quot;+name)Hello，soya</code></pre><p>同样可以利用str()函数把数字、布尔值等转为字符串<br>类似于数组的下标，字符串也有索引，和下标相同，正向时是从0开始，但Python还可以使用反向搜索</p><pre><code>&gt;&gt;&gt; c = &quot;asdfbd&quot;&gt;&gt;&gt; c[0]&#39;a&#39;&gt;&gt;&gt; c[-1]   #从-1开始倒数就是从最后一个字符到第一个字符，注意不是0开始&#39;d&#39;字符串替换&gt;&gt;&gt; c.replace(&quot;a&quot;,&quot;5&quot;)&#39;5sdfbd&#39;&gt;&gt;&gt; c&#39;asdfbd&#39;    #这里意为着是创建了一个新的对象，但如果没有指向一个变量那就不会被引用&gt;&gt;&gt; c=c.replace(&quot;a&quot;,&quot;5&quot;)    #此为利用原来的变量重新指向新创建的字符串&gt;&gt;&gt; c&#39;5sdfbd&#39;提取字符串中的部分字符&gt;&gt;&gt; c[1:5]    #意为着从下标1&#39;s&#39;开始提取到下标5&#39;d&#39;之间的字符，注意不包含第五个(超出)&#39;sdfb&#39;&gt;&gt;&gt; c[:]    #提取全部字符&#39;5sdfbd&#39;&gt;&gt;&gt; c[0:5:2]    #第三个参数表示步长，2表示隔一个提取一个(每两个提取一个)&#39;5db&#39;&gt;&gt;&gt; c[::-1]    #表示每隔-1个提取一个(可以理解为每隔一个提取一个，但是是倒序提取)&#39;dbfds5&#39;</code></pre><h3 id="列表、元组、字典"><a href="#列表、元组、字典" class="headerlink" title="列表、元组、字典"></a>列表、元组、字典</h3><p>三者的创建有一些区别</p><pre><code>&gt;&gt;&gt; a = [ 10, 20, 30]  #列表方括号，或以list()创建&gt;&gt;&gt; b = ( 10, 20, 30)  #元组小括号，或以tuple()创建&gt;&gt;&gt; c = { &quot;one&quot;:10, &quot;two&quot;:20, &quot;three&quot;:30}  #字典花括号，或以dict()创建</code></pre><p>三者的操作集合在需要使用的时候再查询，不必背诵<br>变量段落中的解包赋值对它们同样有效<br>三者都可以通过推导式来生成，即在声明的时候加入循环，运算和筛选，例</p><pre><code>y = [x*2 for x in range(1,5) if x%2==0]   #意为生成一个1-4的列表，随后筛选出能被2整除的数，最后乘2得出最后的列表&gt;&gt;&gt; [4,8]#*</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>while()和for()循环都和C类似，有几个新特性值得记下来。<br>python中循环也可以加else判断，条件是循环没有被break中断的就执行else语句(即正常结束循环就执行)<br>for循环中可以使用zip()函数达到几个列表并列循环的效果<br>例如</p><pre><code>a = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]b = [1,2,3]c = [&quot;!&quot;,&quot;@&quot;]for a1,b1,c1 in zip(a,b,c):    #前面的名字和列表名字不能相同，与变量i同理    print(&quot;{0},{1},{2}&quot;.format(a1,b1,c1))&gt;&gt;&gt; A,1,!B,2,@</code></pre><p>需要理解的是for在python中不仅仅是循环，而是更接近于“遍历”，所以不必局限于循环次数，而是根据列表来进行遍历，这里意味着同时对a，b，c进行遍历。要注意，当次数不相同时按最短列表遍历次数，如例子中a，和b的长度都是3，c是2，就循环两次</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与C相同，函数的返回值只能返回一个。但不同的是，python可以返回一个对象，这意味着能把多个值放在列表中返回，以达到返回多个值的效果(但本质还是只返回一个对象)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言100题相关解题思路(部分)</title>
      <link href="/2019/07/22/Frist-Artical/"/>
      <url>/2019/07/22/Frist-Artical/</url>
      
        <content type="html"><![CDATA[<h3 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h3><p><strong>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</strong><br>该题的关键在于兔子的数量符合<strong>斐波那契数列</strong>-即第n位数等于n-1位和n-2位数相加。同样是通过相互赋值的方法改变相加数的位置。<br>例如1+1=2视为x+y=z，下一次计算应该为1+2=3，则相当于把y值当成新的x，把z看成新的y<br>即x+y=z<br>    x+y=z<br>相关代码</p><pre><code>printf(&quot;%d\n&quot;,y*2); &#x2F;&#x2F;打印出第一位数，乘二是因为一对兔子为两只for(i=0;i&lt;30;i++){    z=x+y;    printf(&quot;%d\n&quot;,z*2); &#x2F;&#x2F;注意先打印后赋值    x=y;    y=z;}</code></pre><h3 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h3><p><strong>判断101-200之间有多少个素数，并输出所有素数。</strong><br><strong>素数</strong>-指除了自身和1外，不能被其他数整除的数。主要是用两个for循环嵌套，首先循环查找的范围，然后循环查找的条件，查找条件比较简单，把被判断数从2除到201，每被整除就标记一次，不能被整除的就continue结束。除完之后查看标记的次数，根据素数的特性，凡是标记次数小于2的就输出概述，并另标记打印的次数(即说明找到了一个素数)。<br>相关代码</p><pre><code>int a=101,b,c,e=0;for(;a&lt;201;a++){    c=0; &#x2F;&#x2F;初始化整除标记为0；    for(b=2;b &lt; a+1 ;b++) &#x2F;&#x2F;不检验被1整除，从2到a+1即可，若到a则测不到被自身整除    {        if(a%b==0) &#x2F;&#x2F;查找整除            c++; &#x2F;&#x2F;每整除一次就标记+1        else            continue; &#x2F;&#x2F;不能被整除就结束循环    }    if(c&lt;2) &#x2F;&#x2F;当数只整除一次时进入    {        e++; &#x2F;&#x2F;素数标记+1        printf(&quot;%d\n&quot;,a);    }}printf(&quot;e=%d\n&quot;,e); &#x2F;&#x2F;素数标记打印要放在所有循环外面</code></pre><h3 id="题目二十六"><a href="#题目二十六" class="headerlink" title="题目二十六"></a>题目二十六</h3><p><strong>利用递归方法求5!</strong><br>利用函数嵌套的递归算法，主要理清楚递归次数和值的关系，阶乘的关系如下<br>   函数递归的最终返回值<br>                 ↑ 值120返回<br>         【f(4) ×5】<br>             ↑ 值24返回<br>     【f(3) ×4】<br>         ↑ 值6返回<br>  【f(2)×3】<br>      ↑ 值2返回<br>【f(1)×2】<br>f(0)时返回1给f(1)；然后依次返回<br>相关代码</p><pre><code>int fact(int x);&#x2F;&#x2F;使用函数前需要提前声明int main(){    int a,b;    scanf(&quot;%d&quot;,&amp;a);&#x2F;&#x2F;将程序升级成阶乘计算器，输入数a，并计算a的阶乘    b=fact(a);    printf(&quot;%d\n&quot;,b);    return 0;}int fact(int x)&#x2F;&#x2F;函数定义{    int y;    if(x&gt;0)    {        x--;&#x2F;&#x2F;需要在递归前先进行条件变换，不然会造成递归死循环        y=fact(x)*(x+1);&#x2F;&#x2F;阶乘递归的关键，过程见上        return y;&#x2F;&#x2F;最后返回的y值    }    return 1;&#x2F;&#x2F;x==0时返回1值}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="题目四十一"><a href="#题目四十一" class="headerlink" title="题目四十一"></a>题目四十一</h3><p><strong>学习static定义静态变量的用法</strong><br>静态变量和普通的变量（即auto自动变量）的区别只有是否会自动释放内存。auto变量在函数调用结束的时候会自动释放，而static变量则不会释放，而是会一直存放在静态储存区，方便下次调用，适合类似求阶乘的算法，但这样的代价是内存得不到释放，同时降低了代码的可读性。<br>相关代码</p><pre><code>int main(){    int i;    for(i=0;i&lt;3;i++)        varer();}void varer(){    int var=0;    static int static_var=0;    printf(&quot;var=%d\n&quot;,var);    printf(&quot;static_var=%d\n&quot;,static_var);    var++;    static_var++;}</code></pre><p>程序执行后得到的值是<br>0 1<br>0 2<br>0 3<br>即auto变量var使用后释放，并再次赋值为0，而static_var不释放，一直自加到循环结束</p><h3 id="题目四十三"><a href="#题目四十三" class="headerlink" title="题目四十三"></a>题目四十三</h3><p><strong>学习使用static的另一用法。</strong><br>static变量和普通变量的另一区别就是储存的位置不同，内存供用户使用可分为三个部分<br>程序区、静态存储区和动态存储区。auto变量放在动态存储区，static变量放在静态存储区。<br>还有声明变量时不要放在同一层级即同一个花括号内<br>相关代码</p><pre><code>int i;for(i=0;i&lt;3;i++){    int num=2; &#x2F;&#x2F;auto变量在循环内外都可运行，在内每次都为2，在外则是递增    printf(&quot;auto num=%d\n&quot;,num);    num++;    &#x2F;&#x2F;若取消花括号会因为变量名相同而报错    {        static int num=1;        printf(&quot;static num=%d\n\n&quot;,num);        num++;    }    &#x2F;&#x2F;从static变量声明起至花括号结束，所有相关语句均只与static变量有关}</code></pre><p>相关代码2</p><pre><code>int var=0;{    var++; &#x2F;&#x2F;此时auto变量为1    static int var=10;    var++; &#x2F;&#x2F;static变量为11    var++; &#x2F;&#x2F;static变量为12    printf(&quot;-%d\n&quot;,var); &#x2F;&#x2F;打印static变量的var    var++; &#x2F;&#x2F;static变量为13，但不会打印出来}&#x2F;&#x2F;花括号结束，此时为auto变量var++; &#x2F;&#x2F;auto变量为2printf(&quot;%d\n&quot;,var);&#x2F;&#x2F;打印auto变量的var</code></pre><h3 id="题目六十六"><a href="#题目六十六" class="headerlink" title="题目六十六"></a>题目六十六</h3><p><strong>输入3个数a,b,c，按大小顺序输出，利用指针方法。</strong><br>运用指针分别指向a，b，c，然后像直接交换变量值一样交换指针地址就可以。<br>相关代码</p><pre><code>int main(){    int n1,n2,n3;    scanf(&quot;%d,%d,%d&quot;,&amp;n1,&amp;n2,&amp;n3);    int *p1,*p2,*p3;    p1=&amp;n1; &#x2F;&#x2F;依次把变量地址赋值给指针，注意给指针赋值时变量要带地址符&amp;，指针不用带*号    p2=&amp;n2;    p3=&amp;n3;    if(n1&gt;n2)        trans(p1,p2);&#x2F;&#x2F;为了方便创建一个函数，此处的排序是由小到大    if(n2&gt;n3)        trans(p2,p3);    if(n1&gt;n3)        trans(p1,p3);    printf(&quot;%d,%d,%d\n&quot;,n1,n2,n3);    return 0;}void trans(int *p1,int *p2){    int s;    s=*p1; &#x2F;&#x2F;除声明的时侯，*p1指的都是该指针指向变量的值，例如此时\*p1指向n1，相当于s=n1    *p1=*p2;    *p2=s;         &#x2F;&#x2F;若不加*号，即    &#x2F;&#x2F;s=p1;     &#x2F;&#x2F;p1=p2;     &#x2F;&#x2F;p2=s;    &#x2F;&#x2F;意味只交换了指针变量的值，即让p1指向n2，p2指向n1，这样子在打印n1、2、3时还是输入时的值}</code></pre><h3 id="题目六十七"><a href="#题目六十七" class="headerlink" title="题目六十七"></a>题目六十七</h3><p><strong>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</strong><br>题目意为创建一个数组，由用户自己输入，输入完成后查看数组中的值，其中最大的值与第一个元素交换，最小的值与最后一个元素交换，其他元素保持不变。<br>要求利用指针来完成。输入与输出函数没有什么好说的。关键是交换元素的时机与方法。<br>首先要定义储存最大和最小的元素的指针，以及一个检查指针。<br>第一步就是循环检查，用数组的第一个元素检查到最后一个元素，元素指针先指向第一个元素，检查指针可跳过第一个，因为max=min=p没有检查的必要。检查完成后就是交换元素，此时找到了max元素、min元素，以及p指针指向最后一个元素。此时就和先前的方法一致声明一个临时变量count来交换数值。不要直接用指针p来临时存储变量。这里要注意的是，当max指针和p指针同时指向最后一个元素时(即最后一个值最大)，改变p的值的同时也改变了max原本的变量。所以还是另外声明比较保险。<br>相关代码</p><pre><code>void max_min(int array[])&#x2F;&#x2F;貌似函数返回值默认为int值时可不用声明(待检验){    int *max,*min,*p;    int count;    max=min=array;    for(p=array+1;p&lt;=array+5;p++)&#x2F;&#x2F;单独数组名代表该数组的首地址，+5则代表数组下标为5的元素    {        if(*p&gt;*max)            max=p;        else if(*p&lt;*min)            min=p;    }    count=array[5];    array[5]=*min;    *min=count;    if(max!=array+5&amp;&amp;min!=array)    &#x2F;&#x2F;若数组是顺序的话，只交换头尾即可，所以检查max和min是否位于第一和最后一位    {        count=array[0];        array[0]=*max;        *max=count;    }}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="题目六十八"><a href="#题目六十八" class="headerlink" title="题目六十八"></a>题目六十八</h3><p><strong>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</strong><br>例如1，2，3，4，5；m=2，结果就是4，5，1，2，3；<br>主要思路还是和上题类似，要注意指针地址的变换。函数内只能用指针交换位置，具体见注释<br>相关代码</p><pre><code>int main(){    int a[5]={1,2,3,4,5};&#x2F;&#x2F;初始化数列    Move(a,2);&#x2F;&#x2F;用函数来完成，设定移动两位，可更改    for(int i=0;i&lt;5;i++)        printf(&quot;%d\t&quot;,a[i]);    printf(&quot;\n&quot;);    return 0;}void Move(int a[],int m){    int *R,*S,count;&#x2F;&#x2F;声明后指针和前指针以及临时变量    for(int i=0;i &lt; m;i++)    {        R=a+4;&#x2F;&#x2F;将后指针放在数组的最后一项        count=*R;&#x2F;&#x2F;同时将值赋给临时变量        for(int j=4;j&gt;0;j--)&#x2F;&#x2F;每次移动数组内部必定移动四次，要从后往前循环        {            S=a+(j-1);&#x2F;&#x2F;前指针依次向前移动            *R=*S;&#x2F;&#x2F;将前值赋给后值            R=S;&#x2F;&#x2F;后指针往前移，此时与前指针指向同一值        }        *S=count;&#x2F;&#x2F;数组内交换完后把临时变量(即原最后值)赋给前指针，此时前指针指向第一值    }}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="题目七十六"><a href="#题目七十六" class="headerlink" title="题目七十六"></a>题目七十六</h3><p><strong>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函1/1+1/3+…+1/n(利用函数指针)</strong><br>这题的主要关键是练习利用函数指针，与指针函数不同，指针函数是指一个返回值为指针的函数，而函数指针意为一个指向函数的指针，相当于深层次点的函数嵌套。首先是检测输入数的奇偶性，然后不论该数是奇数还是偶数都执行一个参数是指针的函数，不过要注意的是与数学不同，C语言中先执行的是外部的函数。<br>相关代码</p><pre><code>int main(){    float peven(),podd(),dcall();    float sum;    int n;    scanf(&quot;%d&quot;,&amp;n);    if(n%2==0)    {        printf(&quot;even=&quot;);        sum=dcall(peven,n);        &#x2F;&#x2F;函数声明在下面，这里先执行的是dcall函数，然后再执行参数中指向Peven函数的指针，下同    }    else    {        printf(&quot;odd=&quot;);        sum=dcall(podd,n);    }    printf(&quot;%f&quot;,sum);}float peven(int n){    float s;    int i;    s=1;    for(i=2;i&lt;=n;i+=2)        s+=1&#x2F;(float)i;    return(s);}float podd(int n){    float s;    int i;    s=0;    for(i=1;i&lt;=n;i+=2)        s+=1&#x2F;(float)i;    return(s);}float dcall(float (*fp)(),int n){    float s;    s=(*fp)(n);&#x2F;&#x2F;将指针指向的函数执行完后的返回值返回    return(s);}</code></pre><h3 id="题目一百"><a href="#题目一百" class="headerlink" title="题目一百"></a>题目一百</h3><p><strong>有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，况原有的数据和计算出的平均分数存放在磁盘文件”stud”中。</strong><br>难度不大，注意输入数据存储到结构体中的时候，即使是用指针指向的数据(即P-&gt;num)的形式，也要加地址符&amp;，因为这里的num依然是变量，而不是地址。<br>例如数组名本身代表数组的首地址，形如声明为</p><pre><code>char a[10];scanf(&quot;%c&quot;,a);&#x2F;&#x2F;合法scanf(&quot;%c&quot;,&amp;a[0]);&#x2F;&#x2F;合法scanf(&quot;%c&quot;,a[0]);&#x2F;&#x2F;不合法</code></pre><p>这里需要注意。<br>相关代码</p><pre><code>typedef struct S{    int num;    char name[10];    float scoreA;    float scoreB;    float scoreC;    float scoreADV;    struct S *NEXT;}SUT;&#x2F;&#x2F;此结构体前的typedef意为SUT等价于struct S*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突int main(){    SUT *HEAD,a,b,c,d,e,*P;    P=HEAD=&amp;a;    a.NEXT=&amp;b;    b.NEXT=NULL;    &#x2F;&#x2F;c.NEXT=&amp;d;  题目的要求为五个学生，但为了测试方便，故修改为两个    &#x2F;&#x2F;d.NEXT=&amp;e;    &#x2F;&#x2F;e.NEXT=NULL;    while(P!=NULL)    {        printf(&quot;please input number and name of the student:\n&quot;);        scanf(&quot;%d,%s&quot;,&amp;P-&gt;num,&amp;P-&gt;name);        &#x2F;&#x2F;注意地址符，详细见上，此处还要注意%s要写在最后，这样避免把‘，’算成字符造成错误，下同        printf(&quot;please input three score:\n&quot;);        scanf(&quot;%f,%f,%f&quot;,&amp;P-&gt;scoreA,&amp;P-&gt;scoreB,&amp;P-&gt;scoreC);        P-&gt;scoreADV=(P-&gt;scoreA+P-&gt;scoreB+P-&gt;scoreC)&#x2F;3;&#x2F;&#x2F;直接计算并存储平均成绩        P=P-&gt;NEXT;    }    P=HEAD;    FILE *F;    F=fopen(&quot;student&quot;,&quot;w&quot;);    while(P!=NULL)    {        fprintf(F,&quot;%d-%s\n&quot;,P-&gt;num,P-&gt;name);        fprintf(F,&quot;A=%.2f,B=%.2f,C=%.2f,ADV=%.2f\n&quot;,P-&gt;scoreA,P-&gt;scoreB,P-&gt;scoreC,P-&gt;scoreADV);        P=P-&gt;NEXT;    }    fclose(F);    return 0;}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><h3 id="关于函数的实参和形参，以及指针作为参数时的情况"><a href="#关于函数的实参和形参，以及指针作为参数时的情况" class="headerlink" title="关于函数的实参和形参，以及指针作为参数时的情况"></a>关于函数的实参和形参，以及指针作为参数时的情况</h3><p>在声明一个函数时<br>例如：</p><pre><code>int Function(int a, int b);</code></pre><p>此时function函数中的a和b为形参</p><p>在主函数中</p><pre><code>int main(){    int Ra,Rb;    Ra=1;    Rb=2;    Function(Ra,Rb);    return 0;}</code></pre><p>此时主函数中的Ra和Rb为实参<br>需要注意的是形参在函数中的运算不会影响实参的值</p><p>而指针作为参数的时候有点特殊，如果直接写成</p><pre><code>int Function(int *a, int b);</code></pre><p>主函数中</p><pre><code>int main(){    int *Ra;    int Rb;    Rb=2;    Function(Ra,Rb);    return 0;}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre><p>此时指针Ra同样不会因为函数中的指针a变化而变化。</p><blockquote><p>在初始化操作前，头指针参数head没有具体的地址值，在初始化操作前，头指针参数head才得到了具体的地址值，而这个地址值要返回给调用函数，所以，此时头指针参数head要设计成指针的指针类型。如果此时头指针参数head设计成指针类型，那么调用函数将无法得到在初始化函数中被赋值的头指针参数head的数值。</p><footer><strong>朱战立 数据结构—使用C语言</strong></footer></blockquote><p>总结就是作为参数形参不能影响实参，但是只要将指针的地址作为参数直接修改地址就可以影响主函数中指针参数的所指向的地址。</p><p>参考文档：<a href="https://www.jianshu.com/p/56d99a3049a5" target="_blank" rel="noopener">https://www.jianshu.com/p/56d99a3049a5</a><br>Sina博客原稿：<a href="http://blog.sina.com.cn/u/2292464751" target="_blank" rel="noopener">http://blog.sina.com.cn/u/2292464751</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阅读笔记</title>
      <link href="/2018/10/19/ReadNote/"/>
      <url>/2018/10/19/ReadNote/</url>
      
        <content type="html"><![CDATA[<h3 id="《上帝掷骰子吗》-2019-07-10"><a href="#《上帝掷骰子吗》-2019-07-10" class="headerlink" title="《上帝掷骰子吗》-2019-07-10"></a>《上帝掷骰子吗》-2019-07-10</h3><p>但是，统一以后呢？是不是一切都大功告成了？物理学是不是又走到了它的尽头，再没有更多的发现可以作出了？我们的后代是不是将再一次陷入无事可做的境地，除了修正几个常数在小数点后若干位的值而已？或者，在未来的某一天，地平线上又会出现小小的乌云，带来又一场迅猛的狂风暴雨，把我们的知识体系再一次砸烂，并引发新的革命？历史是不是这样一种永无止境的轮回，大自然是不是永远也不肯向我们展现它最终的秘密，而我们的探索，是不是永远也没有终点？</p><p>这一切都没有答案，我们只能义无反顾地沿着这条道路继续前进。或许历史终究是一场轮回，但在每一次的轮回中，我们毕竟都获得了更为伟大的发现。科学在不停的检讨自己，但这种谦卑的审视和自我否定不但没有削弱它的光荣，反而使它获得了永恒的力量，也不断地增强着我们对于它地信心。人类居住在太阳系中的一颗小小行星上，他们的文明不过万年的历史，现代科学创立不过300年，但他们的智慧贯穿整个时空，从最小的量子到最大的宇宙尺度，从大爆炸的那一刻到时间的终点，从最近的白矮星到最远的宇宙视界，没有什么可以阻挡我们的探寻的步伐。这一切，都来自我们对于成功的信念，对于科学的依赖，以及对于神奇的自然那永无休止的好奇。</p><h3 id="《家庭、私有制和国家的起源》-2019-06-27"><a href="#《家庭、私有制和国家的起源》-2019-06-27" class="headerlink" title="《家庭、私有制和国家的起源》-2019-06-27"></a>《家庭、私有制和国家的起源》-2019-06-27</h3><p>Familia这个词，起初并不表示现代庸人的那种由脉脉温情同家庭龃龉组合的理想；在罗马人眼里，它起初甚至不是指夫妻及其子女，而只是奴隶。<br>Famulus的意思是一个家庭奴隶，而Familia则是指属于一个人的全体奴隶。还在盖尤斯时代，Familia ，id est patrimonium（即遗产），就是通过遗嘱遗留的。这一用语是罗马人所发明，用以表示一种新的社会机体，这种机体的首长，以罗马的父权支配着妻子、子女和一定数量的奴隶，并且对他们握有生杀之权。</p><h3 id="《文明的冲突与世界秩序的重建》-2019-06-09"><a href="#《文明的冲突与世界秩序的重建》-2019-06-09" class="headerlink" title="《文明的冲突与世界秩序的重建》-2019-06-09"></a>《文明的冲突与世界秩序的重建》-2019-06-09</h3><p>思想的战争已经终结。<br>马克思列宁主义的信仰者可能将仍然存在于“像马那瓜、平壤和马萨诸塞的坎布里奇这样一些地方”，但是自由民主制已经获得全面胜利。未来人们将不再致力于令人振奋的思想斗争，而是致力于解决世间的经济问题和技术问题。<br>他相当惋惜的总结道，这将是十分令人厌倦的。</p><h3 id="《朝花夕拾》-2019-04-03"><a href="#《朝花夕拾》-2019-04-03" class="headerlink" title="《朝花夕拾》-2019-04-03"></a>《朝花夕拾》-2019-04-03</h3><p>他已经平静下去的脸，忽然紧张了，将眼微微一睁，仿佛有一些苦痛。<br>“叫呀！快叫呀！”她催促说。<br>“父亲！”<br>“什么呢？……。不要嚷……。不……。”他低低地说，又较急地喘了着气，好一会儿，这才复了原状，平静下去了。<br>“父亲！”我还叫他，一直到他咽了气。<br>我现在还听到那时的自己的声音，每听到时，就觉得这却是我对于父亲的最大的错处。</p><h3 id="《平凡的世界》2019-03-28"><a href="#《平凡的世界》2019-03-28" class="headerlink" title="《平凡的世界》2019-03-28"></a>《平凡的世界》2019-03-28</h3><p>我们出身于贫困的农民家庭————永远不要鄙薄我们的出身，它给我们带来的好处将一生受用不尽；但我们一定又要从我们出身的局限性中解脱出来，从意识上彻底背叛农民的狭隘性，追求更高的生活意义。<br>要知道，对于我们这样出身农民家庭的人来说，要做到这一点是多么不容易啊！<br>首先要自强自立，勇敢的面对我们不熟悉的世界。不要怕苦难！如果能深刻理解苦难，苦难就会给人带来崇高感。亲爱的妹妹，我多么希望你的一生充满欢乐。可是，如果生活需要你忍受痛苦，你一定要咬紧牙关坚持下去。有位了不起的人说过：痛苦难道是白忍受的吗？它应该使我们伟大！</p><h3 id="《断舍离》-2019-01-28"><a href="#《断舍离》-2019-01-28" class="headerlink" title="《断舍离》-2019-01-28"></a>《断舍离》-2019-01-28</h3><p>无论是居住空间和整个生活都被数量庞大的、多到塞不下的物品压垮，整个人生都在为没法收拾屋子而烦恼的状态，还是因为物资严重短缺而令生活难以维持下去的状态，都是当今世界不该出现的。既然如此，生活在物质充裕的环境下的我们，有没有什么可以做的呢？就是这种想法，促使我联想到了断舍离的基础——与物品的相处方式。</p><h3 id="《铁道之旅》-2018-11-09"><a href="#《铁道之旅》-2018-11-09" class="headerlink" title="《铁道之旅》-2018-11-09"></a>《铁道之旅》-2018-11-09</h3><p>此时此刻需要记住，机器(machine)的原初意义，也就是其前工业化的意义，并不是一种精巧的技术装置，而是就像阴谋诡计(machination)这个词或者天外救星(deus ex machina)这个短语所显示的那样，它只不过是被戏弄或者被欺骗的结果。</p><p>…</p><p>无论新技术是非物质的还是物质的，无论它是电影脚本、印刷机、金钱、机械钟表、火器、蒸汽机或者计算机，都不重要。</p><p>认识到这一点，就很容易看出19世纪的铁道和当下的计算机有何种相似之处了。两者都试图按照它们自己的图景来对这个世界进行再创造、再生产。它们都通过它们的阴谋诡计成功了。无论它们的产物是以蒸汽动力的工业生产与运输的全球网络，还是信息的数字化虚拟世界，这些都是它们的世界机器。</p><p>让他们出轨吧，爆炸吧，碰撞吧，或者就是停下来，两个世界机器就都立刻停止了。</p><h3 id="《发现东亚》-2018-11-01"><a href="#《发现东亚》-2018-11-01" class="headerlink" title="《发现东亚》-2018-11-01"></a>《发现东亚》-2018-11-01</h3><p>倒是纽约的华人移民，抛开加诸林则徐身上纠结不清的意识形态标签，回到历史本来的脉络中，给他一个最为朴素的评价：“禁毒战争先驱”。既不是悲剧，也不是说教；没有民族主义的流露，不必担心被污为“义和团”。有时候，真的，毒品就是毒品，战争就是战争罢了。</p><h3 id="《月亮与六便士》-2018-10-19"><a href="#《月亮与六便士》-2018-10-19" class="headerlink" title="《月亮与六便士》-2018-10-19"></a>《月亮与六便士》-2018-10-19</h3><p>我很怀疑，亚伯拉罕是否真的糟蹋了自己。做自己最想做的事，生活在自己喜爱的环境里，淡泊名利，与世无争，这难道是糟蹋自己吗？与此相反，做一个著名的外科医生，年薪一万镑，娶一位美丽的妻子，就是成功吗？我想，这一切取决于一个人如何看待生活的意义，取决于他认为对社会应尽什么义务，对自己有什么要求。但是我还是什么都没有说；我有什么资格同一位爵士争辩呢？</p><h3 id="《梵高传》-2018-10-19"><a href="#《梵高传》-2018-10-19" class="headerlink" title="《梵高传》-2018-10-19"></a>《梵高传》-2018-10-19</h3><p>一旦想象世界中有了所有这些元素—丝柏树、城镇风景、山峦、地平线，文森特的画笔就开始伸向天空。不受素描和眼前素材的约束，没有透视框的限制，也不被艺术热情左右，他的目光可以无拘无束地聚焦在光线上面—一直以来在夜空看到的深不可测却又安抚人心的星光。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
