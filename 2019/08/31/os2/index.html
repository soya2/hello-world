<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="联系唯一邮箱：soya-kelaos@outlook.com"><meta name="baidu-site-verification"><title>操作系统（二）运行环境 | 恰恰书库</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="alternate" href="/atom.xml" title="恰恰书库" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">恰恰书库</a></h1></div><p class="m-desc">收录一些杂七杂八的东西</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">訂閱</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">操作系统（二）运行环境</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2019/08/31/os2/">2019-08-31</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h3 id="处理器（CPU）"><a href="#处理器（CPU）" class="headerlink" title="处理器（CPU）"></a>处理器（CPU）</h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>一般由运算器、控制器一系列的寄存器以及高速缓存构成<br>其中<strong>运算器</strong>能实现指令中的算术和逻辑运算；<strong>控制器</strong>负责程序运行的流程，包括取指令、维护处理器状态、处理器和内存的交互等；<strong>寄存器</strong>是一种暂时存储的器件，用于存储运行指令过程中暂存数据、地址以及指令信息<br>寄存器的运行速度比内存快上许多，寄存器通常分为两种：<br>用户可见寄存器-编译器可以调用这些寄存器，减少使用内存的次数以提高程序运行的效率<br>控制和状态寄存器-包括数据寄存器、地址寄存器和条件码寄存器，数据寄存器存储算术逻辑指令和访存指令；地址寄存器储存数据和指令的物理地址、线性地址或者有效地址；条件码存储器保存运算后的各种标记，如溢出、符号等</p>
<h4 id="指令执行的基本过程"><a href="#指令执行的基本过程" class="headerlink" title="指令执行的基本过程"></a>指令执行的基本过程</h4><p>首先处理器每次从存储器中读取一条指令，并根据指令类别将程序计数器的指改为下一条指令的地址（通常情况下指令在内存中都是连续的，所以大多是自增1）；其次指令被存储到指令寄存器中，然后处理器解释并执行，这就被成为一个指令周期<br>程序的执行就是不断地取指令→存指令→执行指令组成的，只有机器关机、发生未知错误或遇到停止指令时机器才会停止<br>指令大概分为五类（与特权非特权不同）<br>访问存储器指令-负责存储器和处理器间的数据传送<br>I/O指令-负责处理器和I/O模块间的数据和命令发送<br>算术逻辑指令-执行数据的算术和逻辑操作<br>控制转移指令-可以指定一个<strong>新的</strong>指令的<strong>执行地点</strong><br>处理器控制指令-用于修改处理器状态，改变其工作方式（即目态和管态的切换）</p>
<h4 id="特权与非特权指令"><a href="#特权与非特权指令" class="headerlink" title="特权与非特权指令"></a>特权与非特权指令</h4><p>用户不允许随意使用特权指令，以免造成系统的混乱；特权指令一般包括：<em>设置程序状态字、启动某种设备、设置中断屏蔽、设置时钟指令、清理内存和建立存储保护指令等</em>，用户只能间接的使用这些指令，每次使用时就需要将CPU的状态从目态切换至管态，这一过程被称为陷入（Trap）<br>操作系统运行的过程中目态和管态是在动态切换的，<strong>目态至管态</strong>的切换只能通过<strong>中断</strong>来进行，中断响应时交换中断向量，新的中断向量中的PSW（程序状态字）状态位标为管态；<strong>管态至目态</strong>直接修改PSW即可，不必经历中断<br>系统启动时，CPU的<strong>初始状态为管态</strong>，后装入操作系统后，让用户在目态执行</p>
<h4 id="程序状态字PSW"><a href="#程序状态字PSW" class="headerlink" title="程序状态字PSW"></a>程序状态字PSW</h4><p>有一个专门的寄存器来寄存处理器的状态；如程序计数器就来指示下一条要执行的指令<br>通常包括以下几个状态代码：<br>CPU的工作状态代码-指明是目态还是管态<br>条件码-反应指令执行后的结果特征<br>中断屏蔽码-指出是否运行中断</p>
<h3 id="硬件部件"><a href="#硬件部件" class="headerlink" title="硬件部件"></a>硬件部件</h3><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><p>基本上可以划分为两类：读写型的存储器和只读型的存储器<br>读写型的可以将数据存入任一地址单元并任意去取出或重新载入，即随机访问存储器（RAM）<br>只读型不能随意写入数据，称为只读存储器（ROM），还有PROM和EPROM等变种，PROM可用特殊的写入器写入，EPROM可用特殊的紫外线“擦去”信息位，再用写入器写入<br>存储的最小单位是1位（bit）只能存储1或0，<strong>一个字节包含8位</strong>，两个字节称为一个字，四个字节称为双字，1024个字节则为1KB，类推出MB、GB等<br>存储系统的设计要考虑三个问题：<strong>容量、速度和成本</strong><br>一般情况下，速度越快价格越高容量越小；速度越慢价格越低容量越大，合理分配计算机存储硬件等级也是值得考虑的，一般情况下<strong>寄存器&gt;高速缓存&gt;内存&gt;硬盘&gt;磁带、光驱</strong>比较合理<br>内存的保护<br>利用界地址寄存器来存储作业在内存中的上限和下限地址，当处理器访问内存时对比现请求的内存和已经在使用的内存是否越界，若越界则产生程序中断</p>
<h4 id="I-O部件"><a href="#I-O部件" class="headerlink" title="I/O部件"></a>I/O部件</h4><p>早期计算机是用CPU轮流询问硬件是否有处理请求后再处理，这种方式效率过低被淘汰<br>如今则采用<strong>通道</strong>的方式，通道是独立于CPU的，各种外部设备的设备控制器通过通道连接到系统的公共系统总线上；通道代替CPU处理I/O操作，使得外部设备和处理器可以<em>并行</em>工作；通道又被称为<strong>I/O处理器</strong><br>当CPU处理到“启动外设”的命令时就启动外设并将控制权交给通道，外设和内存的数据交换直接由通道控制，不经过CPU；外设工作结束后，形成一个“输入输出操作结束”的I/O中断事件，由CPU处理结束<br>这样大大提高了运行效率，不让设备和CPU空转运行；还会使用<strong>直接存储器访问（DMA）</strong>技术，DMA是一个总线中的一个独立的控制单元，自动控制成块的数据在内存和I/O单元间传送。处理器需要读取设备数据时给DMA发一条命令后可以处理其他事情，当DMA整理好数据发送过来时会触发中断来接收数据，这条命令通常包括设备的编址、开始读写的内存编制，需要传送的数据长度、是否请求读写等信息<br>当DMA和CPU在总线上冲突时，CPU会稍微等待一下<br>因为CPU的处理速度远远超过数据的输入输出速度，不可能在键盘敲下一个键就执行一次指令，这样大大浪费了CPU的速度，所以采用<strong>设立缓冲区</strong>的方法输入一定量的数据后再一次性传送给CPU</p>
<h4 id="时钟部件"><a href="#时钟部件" class="headerlink" title="时钟部件"></a>时钟部件</h4><p>计算机系统中时间部件是必要的，可以为系统发现一个死循环的程序，实现分时和实时系统、定时唤醒事先给定的外部事件、记录用户使用设备的时间和事件发生间隔以及记录绝对时间年月日等<br>时间部件一般分为硬件时钟和软件时钟，硬件则是利用电路中的晶体震荡器，每隔一段时间激发出一个频率的脉冲，时钟寄存器就不停对这个电路执行+1的操作，当计算机关机时，利用纽扣电池仍然在不停计时；软件则是利用程序来进行计时，系统需要同步硬件和软件时钟，绝对时间是执行+1操作，而相对时间执行-1操作（即倒计时）</p>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><h4 id="中断与异常的概念"><a href="#中断与异常的概念" class="headerlink" title="中断与异常的概念"></a>中断与异常的概念</h4><p><strong>中断</strong><br>CPU对系统内外发生的异步事件的响应即中断，异步事件指无一定顺序关系随机发生的事件；中断时实际意义是发生了异步事件后CPU中断当前程序转而处理异步事件，处理完后再回来执行先前的程序；几种名词的解释：<br>中断事件/中断源-引起中断的事件<br>中断请求-中断源向CPU发出的请求信号<br>中断处理程序-处理中断事件的程序<br>中断断点-原先程序的暂停点<br>中断响应-CPU暂停原先程序去处理中断的<em>过程</em><br>中断返回-处理结束后恢复原先程序的执行<br>中断字-计算机系统提供的中断源的有序集合，存在逻辑结构，不同处理器有不同的实现方式，Intel的x86处理器能处理256种中断<br>中断向量表-表中的每一项称为一个中断向量，主要有PSW和指令计数器PC组成，不同性质的中断源有不同的PSW和PC，通过此表找到相应的中断处理程序<br>中断技术的应用使得CPU运行效率提高，不用到处询问是否有事件发生，只要等待中断并且处理<br><strong>异常</strong><br>中断和异常的差别主要在中断是由外部事件引发的，而异常指由正在执行的指令引发的<br>中断的分类<br>时钟中断-按一定函数中断事件寄存器<br>输入输出（I/O）中断-硬件完成使用或期间引发的错误<br>控制台中断-操作员通过控制台发出命令<br>硬件故障中断-如断电存储器校验错误等<br>异常的分类<br>程序性中断-如溢出，除零，目态试图使用特权指令，访问不存在的目录等<br>访管指令异常-要求操作系统提供系统服务等</p>
<h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p>中断系统分为两个部分<br>硬件中断装置-负责捕获中断源发出的中断请求，以一定方式响应中断源，然后将处理器的权限转接给软件中断程序<br>软件中断程序-根据中断事件的性质执行相应的操作<br>请求的接收基本原理是通过中断逻辑线路接受并寄存到硬件触发器中，中断寄存器中包含了多种中断位，每一个中断位对应一种中断源<br>相应的具体过程是处理器接收中断信号→保护现场，将中断断点的PSW和PC存入系统堆栈→分析接收的中断向量，取得中断处理程序的地址→将CPU的PC设为此地址→调用中断处理程序→处理完后恢复现场原有程序继续运行<br>几种典型的中断处理<br>I/O中断-设备的唤醒和结束都会引发一次中断，多次引发会判断为设备故障通知管理员<br>时钟中断-控制定时任务和进程的处理器时间配额、处理器调度、维护软件时钟和实时处理<br>硬件故障中断-硬件问题引发的中断<br>程序性中断-指令出错、越权或越界而引发的系统保护；程序性中断可由系统完成也可以由程序自己完成<br>系统服务请求（自愿性中断）</p>
<h4 id="中断优先级、中断屏蔽和中断嵌套"><a href="#中断优先级、中断屏蔽和中断嵌套" class="headerlink" title="中断优先级、中断屏蔽和中断嵌套"></a>中断优先级、中断屏蔽和中断嵌套</h4><p>优先级-连接在不同的<strong>中断请求线</strong>上的中断信号，表示它们有不同的中断级别，硬件就决定了各个中断的优先级；例如电池即将没电，这类中断的优先级高于大多数中断；若同级中断有两种优先方法：一是硬件固定的优先数；二是轮转法<br>屏蔽-有些情况下一个中断在执行的时候，处于它级别低或者不会发生的中断都会被屏蔽；还有一类不可屏蔽的中断信号，屏蔽由卸载PSW中的中断屏蔽位中<br>嵌套-处理器在处理一个中断程序时又接收到一个中断信号时会有两种响应方式：<br>一是上述的中断屏蔽-新来的中断级别低于或相等于现在处理的中断等级<br>二就是中断嵌套；新来的中断级别高度现处理的中断，会类似递归一般在上个中断中再进行一次中断处理，处理过程和一般情况无异</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用时系统提供给用户访问特权指令的<strong>唯一接口</strong>，通过调用把CPU从目态切换至管态</p>
<h4 id="系统调用和函数调用的区别"><a href="#系统调用和函数调用的区别" class="headerlink" title="系统调用和函数调用的区别"></a>系统调用和函数调用的区别</h4><p>函数调用下-调用程序和被调用程序都运行在目态；系统调用下-调用程序在目态，而被调用程序在管态<br>因为不同调用运行在不同的状态，所以系统调用下的调用程序不能<strong>被</strong>调用，需要通过中断切换状态<br>系统调用也可以嵌套调用，不过嵌套的深度各有区别</p>
<h4 id="系统调用的分类"><a href="#系统调用的分类" class="headerlink" title="系统调用的分类"></a>系统调用的分类</h4><p>进程控制类-创建和终止<strong>进程的系统调用、获得和设置进程属性</strong>的系统调用<br>文件操作类-创建、打开、关闭和读写文件；创建目录以及移动文件的读写指针、改变文件的属性等<br>进程通信类-用于进程间传递信息和信号<br>设备管理类-用于请求和释放有关设备，以及启动设备操作等<br>信息维护类-用于获得当前时间和日期、设置文件访问和修改时间、了解当前用户数、系统版本号、空闲的内存磁盘等信息</p>
<h4 id="与库函数、API、内核函数的关系"><a href="#与库函数、API、内核函数的关系" class="headerlink" title="与库函数、API、内核函数的关系"></a>与库函数、API、内核函数的关系</h4><p>以库函数、API和内核函数为接口使用户能够调用特权指令</p>
<h4 id="系统调用的处理过程"><a href="#系统调用的处理过程" class="headerlink" title="系统调用的处理过程"></a>系统调用的处理过程</h4><p>与中断类似，不过这个过程称为陷入<br>当处理器执行到陷入指令时，首先调用中断，通过中断向量表把控制权交给系统调用总入口程序，该程序会进行现场保护和数据存入堆栈等操作，然后再查看<strong>系统调用表</strong>把控制权移交给相应的系统调用畜栏里例程或内核函数，执行完后恢复现场并返回用户程序</p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">Soya</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2019/08/31/os2/">soya2.github.io/2019/08/31/os2/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="soya2.github.io">Soya的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/操作系统/">操作系统</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#处理器（CPU）"><span class="toc-number">1.</span> <span class="toc-text">处理器（CPU）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构成"><span class="toc-number">1.1.</span> <span class="toc-text">构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指令执行的基本过程"><span class="toc-number">1.2.</span> <span class="toc-text">指令执行的基本过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特权与非特权指令"><span class="toc-number">1.3.</span> <span class="toc-text">特权与非特权指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#程序状态字PSW"><span class="toc-number">1.4.</span> <span class="toc-text">程序状态字PSW</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件部件"><span class="toc-number">2.</span> <span class="toc-text">硬件部件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#存储系统"><span class="toc-number">2.1.</span> <span class="toc-text">存储系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O部件"><span class="toc-number">2.2.</span> <span class="toc-text">I/O部件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时钟部件"><span class="toc-number">2.3.</span> <span class="toc-text">时钟部件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断机制"><span class="toc-number">3.</span> <span class="toc-text">中断机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中断与异常的概念"><span class="toc-number">3.1.</span> <span class="toc-text">中断与异常的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断系统"><span class="toc-number">3.2.</span> <span class="toc-text">中断系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断优先级、中断屏蔽和中断嵌套"><span class="toc-number">3.3.</span> <span class="toc-text">中断优先级、中断屏蔽和中断嵌套</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用"><span class="toc-number">4.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#系统调用和函数调用的区别"><span class="toc-number">4.1.</span> <span class="toc-text">系统调用和函数调用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统调用的分类"><span class="toc-number">4.2.</span> <span class="toc-text">系统调用的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与库函数、API、内核函数的关系"><span class="toc-number">4.3.</span> <span class="toc-text">与库函数、API、内核函数的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统调用的处理过程"><span class="toc-number">4.4.</span> <span class="toc-text">系统调用的处理过程</span></a></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2019/09/01/os3/">&lt; 操作系统（三）进程与线程</a><a class="next" href="/2019/08/27/os1/">操作系统（一）概论 &gt;</a></div><div id="valine-comment"><style type="text/css">.v * { color: #CECECE; }
.v a { color: #0F9FB4; }
.v a:hover { color: #216C73; }
.v li { list-style: inherit; }
.v .vwrap { border: 1px solid #223441; border-radius: 0; }
.v .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.v .vbtn { border-radius: 0; color: #cecece; background: none; }
.v .vlist .vcard .vh { border-bottom-color: #293D4E; }
.v .vwrap .vheader .vinput { border-bottom-color: #223441; }
.v .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.v code, .v pre,.v .vlist .vcard .vhead .vsys { background: #203240; }
.v code, .v pre { color: #F0F0F0; font-size: 95%; }
.v .vlist .vcard .vcontent.expand:before { background: linear-gradient(180deg,hsla(206,33%,19%,0),hsla(206,33%,19%,.9)); }
.v .vlist .vcard .vcontent.expand:after { background: hsla(206,33%,19%,.9); }</style><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2020 <a href="/." rel="nofollow">恰恰书库</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>