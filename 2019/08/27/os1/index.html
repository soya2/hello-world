<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"soya2.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述及公式计算公式周转时间：作业完成时刻-作业到达时刻平均周转时间：作业周转总时间&#x2F;作业个数带权周转时间：周转时间&#x2F;服务时间平均带权周转时间：带权周转总时间&#x2F;作业个数等待时间：周转时间-服务时间平均等待时间：等待总时间&#x2F;作业个数响应比：作业周转时间&#x2F;作业执行时间 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间 算法先来先服务算法：如名字所说，先进入就绪队列的进程先运行 非抢占式优先级算法：执行完一个">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统（一）概论">
<meta property="og:url" content="soya2.github.io/2019/08/27/os1/index.html">
<meta property="og:site_name" content="恰恰书库">
<meta property="og:description" content="概述及公式计算公式周转时间：作业完成时刻-作业到达时刻平均周转时间：作业周转总时间&#x2F;作业个数带权周转时间：周转时间&#x2F;服务时间平均带权周转时间：带权周转总时间&#x2F;作业个数等待时间：周转时间-服务时间平均等待时间：等待总时间&#x2F;作业个数响应比：作业周转时间&#x2F;作业执行时间 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间 算法先来先服务算法：如名字所说，先进入就绪队列的进程先运行 非抢占式优先级算法：执行完一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="/2019/08/27/os1/win.JPG">
<meta property="og:image" content="/2019/08/27/os1/unix.JPG">
<meta property="og:image" content="/2019/08/27/os1/linux.JPG">
<meta property="og:image" content="/2019/08/27/os1/and.jpg">
<meta property="article:published_time" content="2019-08-27T13:24:57.000Z">
<meta property="article:modified_time" content="2020-08-29T13:52:56.602Z">
<meta property="article:author" content="Soya">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/2019/08/27/os1/win.JPG">

<link rel="canonical" href="soya2.github.io/2019/08/27/os1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统（一）概论 | 恰恰书库</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="恰恰书库" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">恰恰书库</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">恰恰书库</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="soya2.github.io/2019/08/27/os1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Soya">
      <meta itemprop="description" content="联系唯一邮箱：soya-kelaos@outlook.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恰恰书库">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统（一）概论
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-27 21:24:57" itemprop="dateCreated datePublished" datetime="2019-08-27T21:24:57+08:00">2019-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-29 21:52:56" itemprop="dateModified" datetime="2020-08-29T21:52:56+08:00">2020-08-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述及公式"><a href="#概述及公式" class="headerlink" title="概述及公式"></a>概述及公式</h2><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>周转时间：作业完成时刻-作业到达时刻<br>平均周转时间：作业周转总时间/作业个数<br>带权周转时间：周转时间/服务时间<br>平均带权周转时间：带权周转总时间/作业个数<br>等待时间：周转时间-服务时间<br>平均等待时间：等待总时间/作业个数<br>响应比：作业周转时间/作业执行时间 = （等待时间+要求服务时间）/要求服务时间</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>先来先服务算法：如名字所说，先进入就绪队列的进程先运行</p>
<p>非抢占式优先级算法：执行完一个进程后在队列中挑选一个优先级最高的进程运行</p>
<p>银行家算法：银行家算法是死锁<strong>预防</strong>策略<br>    四个规则：<br>    1.当一个进程的最大需求不超过现有资源时可允许<br>    2.进程可以分期获取资源，但不能超过最大资源数<br>    3.不能满足进程的需求时可推迟，但总能在有限时间内分配资源<br>    4.当进程获取完全部所需资源时一定在有限的时间内归还<br>死锁的解除分为：剥夺资源和撤销进程</p>
<p>在<strong>交互式用户环境</strong>中采用抢占式调度算法</p>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>操作系统结构研究<strong>不包括</strong>规则统一化<br><strong>不属于</strong>特权指令的是管访命令<br>中断屏蔽标志位是<strong>IF</strong><br><strong>不属于临时性资源</strong>的是共享程序代码<br>把逻辑地址转绝对地址的工作称为<strong>地址重定位</strong><br>Unix接口有内存与硬件、内核与shell两个接口<br>整理内存碎片的技术叫<strong>紧缩</strong><br>SPOOLing系统主要三部分：输入程序模块、输出程序模块、作业调度<br>分时操作系统不具有实时性<br>消息缓冲区是由消息长度、消息正文、发送者、消息队列指针四项组成</p>
<h3 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h3><p>P操作对资源S进行预测，其内部动作为：<br>    1.S-1<br>    2.判断若S-1后大于或等于0，则进程继续执行<br>    3.若小于0，就阻塞并放入S的等待队列中<br>V操作释放信号量，内部动作为：<br>    1.S+1<br>    2.若大于0，继续执行<br>    3.若小于等于0，则从S等待队列中释放一个等待进程<br>信号量：是整数，互斥信号量一般是1<br>信号量值的物理意义：若为正数，意味着S还有若干个资源可使用；若为负数，意味着有若干个进程在队列中等待，为0时表示有进程正在占用最后这个S资源<br>PV操作的缺点是：<br>    1.程序可读性差<br>    2.不利于修改和维护<br>    3.正确性难以保证<br>例题：将整型电压值从传感器中取出存入缓冲区，然后取出转换成温度值后再次存入，最后再次取出显示。用PV操作来实现三个过程共享缓冲区的同步问题。</p>
<h3 id="资源分配图及化简方法"><a href="#资源分配图及化简方法" class="headerlink" title="资源分配图及化简方法"></a>资源分配图及化简方法</h3><p>1.查看是否有满足需求的资源，将它的所有边去掉，变成一个孤立的点<br>2.重复上述过程<br>3.若所有点都能孤立就能避免死锁，否则就是死锁状态<br>死锁：</p>
<h3 id="磁盘调度的几种方法"><a href="#磁盘调度的几种方法" class="headerlink" title="磁盘调度的几种方法"></a>磁盘调度的几种方法</h3><p>先来先服务(FCFS)：先进入队列的申请先调度，不过有相邻申请磁道却相隔很远的不利情况<br>最短寻找时间有限算法(SSTF)：选择离当前磁道最近的申请进行调度，不过可能产生饥饿<br>扫描算法（SCAN/LOOK）：无申请时不动，有申请时磁头沿该方向扫描，若这个方向还有申请就继续前进，若没有申请或走到尽头则调头，对两头区域不利<br>循环扫描算法(C-SCAN/C-LOOK)：规定磁头单向移动，扫描至尽头后直接折返至起点，折返间不接受任何申请</p>
<p>用于储存数据物理、线性和有效地址的寄存器是地址寄存器<br>实现存储保护，对属于自己区域的信息<strong>可读可写</strong><br>存储系统的设计<strong>不考虑时间</strong>问题<br>流式文件没有结构</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程由程序、数据、进程控制块组成<br>进程的特性不包括随机性；含有并发、动态、交往、异步、结构、独立性<br>在Unix系统中，创建子进程使用fork()函数，exec()函数要配合vfork()函数使用，功能是加载一个可执行文件，wait()函数用于等待并回收子进程，而waitpid()函数是等待并回收一个<strong>指定</strong>的子进程<br>资源拥有的<strong>基本单位是进程</strong>不是线程<br>当一个管程无法继续执行时也是用wait操作</p>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>将程序划分为若干个长度相等的页，然后各自放入内存，并记录下该页所存放的内存地址并和页码(页式虚拟地址)一一对应形成<strong>页表</strong>；页表存放在内存中一块固定的存储区，每个进程至少有一个页表<br>缺页中断：有时某一页还未加载进内存，程序试图访问这一页时CPU的内存管理单元会发出中断<br>页面置换算法：<br>    LRU(Least Recently Used)把<strong>最近最少使用置换</strong>的页面淘汰<br>    LFU(Least Frequently Used)<strong>最少使用置换</strong>每个页面都设置一个移位寄存器，用来记录移位的频率，频率最低的页面被淘汰<br>    OPT(不可实现)<strong>最佳置换算法</strong>因为OS不知道各页面什么时候会被访问<br>    FIFO(First Input First Output)<strong>先进先出置换</strong>，最先进入内存的页面最先被淘汰</p>
<h3 id="通道技术"><a href="#通道技术" class="headerlink" title="通道技术"></a>通道技术</h3><p>独立于CPU，在内存和I/O设备间交换数据，启动时由CPU执行相应指令启动，结束时向CPU发送中断信号<br>DMA(直接存储器访问)：将数据成块的传递给CPU，例如使用键盘输入的时候，CPU不用一直等待，可以去处理其他任务</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>一级文件称为主文件目录，二级称为用户文件目录<br>二级目录的优缺点-优：解决了文件的重名问题，查找时间减少，实现不同用户间的文件共享；缺：增加了系统开销<br>索引文件结构既适合顺序存储，也适合随机存储<br>逻辑文件可以采用的逻辑方式是记录式文件和流式文件</p>
<h2 id="详细内容"><a href="#详细内容" class="headerlink" title="详细内容"></a>详细内容</h2><h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统是集中了<em>资源管理功能</em>和<em>控制程序执行功能</em>的一种<strong>软件</strong><br>意为能有效的组织和管理计算机系统的硬件和软件资源，合理地组织计算机工作流程，控制程序地执行，并向用户提供各种服务功能，使得用户能够灵活、方便、有效地使用计算机，并使整个计算机系统能高效地运行。</p>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><h4 id="1-并发性"><a href="#1-并发性" class="headerlink" title="1.并发性"></a>1.并发性</h4><p>指在系统中<em>同时</em>存在若干个运行着的程序，从<strong>宏观</strong>上看，这些程序在同时向前推进。<br>（并行性-指两个或两个以上的事件在同一时刻发生，是具有<strong>微观</strong>意义的同时，并发只是多个程序交替进行，是一种<em>假象</em>的同时）</p>
<h4 id="2-共享性"><a href="#2-共享性" class="headerlink" title="2.共享性"></a>2.共享性</h4><p>指操作系统和多个用户共用系统中的各种资源<br>    a.互斥共享-如打印机、扫描仪等，在一段时间内只能由某一个用户程序使用<br>    b.同时共享-如音响等，可以在一段时间内被多个程序同时访问。</p>
<h4 id="3-虚拟性"><a href="#3-虚拟性" class="headerlink" title="3.虚拟性"></a>3.虚拟性</h4><p>指把物理上的实体变为若干个逻辑上的对应物。前者是实际存在的，而后者是用户感受到的，譬如一个计算机的实际物理内存只有4GB，而同时运行的软件的需要内存早已超过了4GB，采用虚拟存储器技术（空分/时分复用技术）将空间和时间微分并交替进行造成运行内存超过物理内存的假象，与并发性类似。</p>
<h4 id="4-随机性"><a href="#4-随机性" class="headerlink" title="4.随机性"></a>4.随机性</h4><p>操作系统的运行是建立在随机发生事件的情况下的，操纵系统不能对所运行的程序的行为以及硬件设备的情况做出任何实现的假定。</p>
<h3 id="研究操作系统的观点"><a href="#研究操作系统的观点" class="headerlink" title="研究操作系统的观点"></a>研究操作系统的观点</h3><h4 id="1-软件的观点"><a href="#1-软件的观点" class="headerlink" title="1.软件的观点"></a>1.软件的观点</h4><p>操作系统是一种软件，是最接近硬件的软件</p>
<h4 id="2-资源管理的观点"><a href="#2-资源管理的观点" class="headerlink" title="2.资源管理的观点"></a>2.资源管理的观点</h4><p>操作系统负责登记谁在使用什么样的资源，系统中还有哪些资源空闲，当前响应了谁对资源的要求，以及回收了哪些不再使用的资源等。</p>
<h4 id="3-进程的观点"><a href="#3-进程的观点" class="headerlink" title="3.进程的观点"></a>3.进程的观点</h4><p>把操作系统看成由<em>多个同时独立运行的程序</em>和<em>一个对这些程序进行协调的<strong>核心</strong></em>所组成。</p>
<h4 id="4-虚机器的观点（非虚拟机）"><a href="#4-虚机器的观点（非虚拟机）" class="headerlink" title="4.虚机器的观点（非虚拟机）"></a>4.虚机器的观点（非虚拟机）</h4><p>用户通过操作系统来控制硬件，看作一个虚拟的机器</p>
<h4 id="5-服务提供者的观点"><a href="#5-服务提供者的观点" class="headerlink" title="5.服务提供者的观点"></a>5.服务提供者的观点</h4><p>为用户提供服务的提供者</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><h4 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1.进程管理"></a>1.进程管理</h4><p>进程管理的实质是<strong>对中央处理器进行管理</strong>，为了描述多道程序的并发执行，就要引入进程的概念。<br>    a.进程控制-即进程创建时要分配其资源，进程结束时回收其资源<br>    b.进程同步-多个进程是并发的，并且以<em>异步</em>的方式运行，所以执行速度是不能确定的。为了宏观上同步就要对进程进行协调。主要有<em>互斥</em>和<em>同步</em>两种方式，在遇到硬件是否冲突的时候协调他们的运行顺序。其中一个方法是调用<em>原语</em>中的资源加锁语句。<br>    c.进程间通信-操作系统提供进程间相互交换数据的手段<br>    d.调度-即从进程（线程）的就绪队列中按照一定算法调出一个并分配资源让他执行</p>
<h4 id="2-存储管理"><a href="#2-存储管理" class="headerlink" title="2.存储管理"></a>2.存储管理</h4><p>任务是管理计算机中的内存<br>    a.内存的分配和回收<br>    b.存储保护-已经使用的内存不会被再次调用<br>    c.内存扩充-即空分复用技术</p>
<h4 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3.文件管理"></a>3.文件管理</h4><p>对硬盘的管理<br>    a.文件存储空间的管理（常采用离散分配的方式，以512B或几KB为单位进行分配）<br>    b.目录管理<br>    c.文件系统的安全性</p>
<h4 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4.设备管理"></a>4.设备管理</h4><h4 id="5-用户接口"><a href="#5-用户接口" class="headerlink" title="5.用户接口"></a>5.用户接口</h4><h3 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows<img src="/2019/08/27/os1/win.JPG" class=""></h4><p>1.内核-提供线程调度、陷入处理和异常调度、中断处理和调度、多处理器同步、供执行体使用的基本内核对象<br>2.硬件抽象层-将硬件的接口封装成一个可加载的核心态模块，隐藏细节，作为黑箱一般，只要调用即可<br>3.执行体-处于内核上层，可调用函数执行<br>4.系统进程和线程</p>
<h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix<img src="/2019/08/27/os1/unix.JPG" class=""></h4><p>1.内核层-常驻于内存，下接硬件接口，上接shell接口。本身分为两大部分，一部分为进程控制子系统，一部分为文件子系统<br>2.系统调用层-可进行文件管理，终端状态和进程管理等<br>3.应用层-即应用通过shell再通过系统调用层访问硬件，所有应用都基于shell运行</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux<img src="/2019/08/27/os1/linux.JPG" class=""></h4><p>1.内核-负责管理系统的进程、内存、设备驱动、文件和网络系统<br>2.shell-是一个命令解释器，将用户输入的指令直接解释给内核执行<br>3.文件系统-即文件在硬盘等存储设备上的组织方法<br>4.应用程序-最上层的应用程序一般都有图形界面，包括有文本编辑器、办公套件等软件</p>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android<img src="/2019/08/27/os1/and.jpg" class=""></h4><p>1.应用程序-由Java编写的如电话、短信等自带程序<br>2.应用框架-为开发者提供可以访问各类API的框架，只要程序遵循这个框架就能安全的通过API访问核心功能<br>3.C/C++本地库和运行环境-程序在安装时实际上是一个由Java编译至机器码的过程，通过框架得知所需的功能后再从库中查找功能<br>4.Linux内核-包括系统层的安全机制、内存管理、进程管理、网络堆栈及一系列其他模块</p>
<h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><h4 id="1-手工发展"><a href="#1-手工发展" class="headerlink" title="1.手工发展"></a>1.手工发展</h4><p>打孔二进制放入机器运行，这种形式运行一个程序时占用整个计算机的全部资源</p>
<h4 id="2-监控程序"><a href="#2-监控程序" class="headerlink" title="2.监控程序"></a>2.监控程序</h4><p>程序可以监督一个作业是否完成，可将多个作业打包排队运行，不必一个一个存入取出，即早期的批处理</p>
<h4 id="3-多道批处理"><a href="#3-多道批处理" class="headerlink" title="3.多道批处理"></a>3.多道批处理</h4><p>输入输出和处理器操作可以并行处理，只要一个硬件空余就执行下个可执行的作业（类似工程中的流水节拍）</p>
<h4 id="4-分时与实时系统"><a href="#4-分时与实时系统" class="headerlink" title="4.分时与实时系统"></a>4.分时与实时系统</h4><p>当遇到多个用户同时使用一个计算时就需要将时间微分交替为每个用户服务；实时系统用在对时间要求严格的场景中</p>
<h4 id="5-Unix操作系统"><a href="#5-Unix操作系统" class="headerlink" title="5.Unix操作系统"></a>5.Unix操作系统</h4><p>Unix是使用C语言编写的，可移植性很强；是一个良好的、通用的、多用户、多任务、分时操作系统，同时有shell解释命令和编写程序</p>
<h4 id="6-个人计算机操作系统"><a href="#6-个人计算机操作系统" class="headerlink" title="6.个人计算机操作系统"></a>6.个人计算机操作系统</h4><p>如Linux和Windows都是如今流行的个人操作系统</p>
<h4 id="7-Android系统"><a href="#7-Android系统" class="headerlink" title="7.Android系统"></a>7.Android系统</h4><p>基于Linux发展的移动平台操作系统</p>
<h3 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h3><h4 id="1-批处理操作"><a href="#1-批处理操作" class="headerlink" title="1.批处理操作"></a>1.批处理操作</h4><p>即早期的批处理系统，将作业成堆的输入计算机执行后输出；在整个程序的头部有一份作业控制说明书，其中写明了各个作业的执行顺序，类似于以下形式：<br>    STEP1    ASM        A<br>    STEP2    FTN     B<br>    STEP3    LINK    A, B, C<br>    STEP4    RUN        C<br>    意为A由汇编语言编译，B由Fortran编译，将A和B连成C，最后运行C<br>一般指令和特权指令<br>    中央处理器（CPU）有两个运行状态，用户态（目态）和核心态（管态），特权指令只能在核心态时执行，一般指令在两个状态都能执行；特权指令包括输入/输出指令、停机指令等，应用程序只能间接调用这些功能，当需要调用这些功能时，监控程序移动到这个部分，再将目态切换至管态，执行后监控程序复原，管态切至目态<br>SPOOLing技术<br>    自动根据作业控制说明书完成计算机的输入输出部分，不具有并发功能，没有根本上解决输入输出缓慢的问题，只能看作一个高级的I/O接口；当然它为多道批处理的发展提供了基础，表明了能利用空闲的硬件提高效率</p>
<h4 id="2-分时操作系统"><a href="#2-分时操作系统" class="headerlink" title="2.分时操作系统"></a>2.分时操作系统</h4><p>将时间微分，即具有并发的特性，宏观上实时反馈多个信息；具有多路性、交互性、“独占性”与及时性，用户可以干预每一步的进行</p>
<h4 id="3-实时操作系统"><a href="#3-实时操作系统" class="headerlink" title="3.实时操作系统"></a>3.实时操作系统</h4><p>同上，具有并行的特性，微观上同时进行，运用在时钟管理、过载保护等地</p>
<h4 id="4-嵌入式操作系统"><a href="#4-嵌入式操作系统" class="headerlink" title="4.嵌入式操作系统"></a>4.嵌入式操作系统</h4><p>高定制性的操作系统，可根据每个应用场景的不同改变其中的原语、调度算法和内存管理等分配策略，在工业上广泛应用，同时是具有高度统一协调、调度、指挥和控制的系统</p>
<h4 id="5-个人计算机系统"><a href="#5-个人计算机系统" class="headerlink" title="5.个人计算机系统"></a>5.个人计算机系统</h4><h4 id="6-网络操作系统"><a href="#6-网络操作系统" class="headerlink" title="6.网络操作系统"></a>6.网络操作系统</h4><p>为计算机网络所配置的操作系统，包括网络管理、通信、安全、资源共享等功能</p>
<h4 id="7-分布式操作系统"><a href="#7-分布式操作系统" class="headerlink" title="7.分布式操作系统"></a>7.分布式操作系统</h4><p>将大量运行同一个操作系统的计算机通过网络连接，再通过调度它们的资源执行任务造成一台计算能力非常强大的计算机的假象，任何一台计算机下线都不影响整个系统的运行</p>
<h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><h4 id="1-整体式结构"><a href="#1-整体式结构" class="headerlink" title="1.整体式结构"></a>1.整体式结构</h4><p>类似将所有功能封装成各个模块，然后整个模块又封装成一个整体，优点是结构紧密，运行效率高，但是这种情况下一个变量进入后没有哪个模块可调用哪个模块不可调用的约定，会造成循环调用，引发错误；整体式结构的特点就在于接口简单直接，但无运行顺序</p>
<h4 id="2-层次式结构"><a href="#2-层次式结构" class="headerlink" title="2.层次式结构"></a>2.层次式结构</h4><p>为了解决整体式的问题，需要对接口的输入输出做出规范；将模块们分层，本层只能和上层或者下层单向的交换数据，同层间的模块或许能交换数据（不能则是全序），这样子每个层次的功能都可以修改，只要接口的约定不变就不会影响整个系统</p>
<h4 id="3-微内核结构"><a href="#3-微内核结构" class="headerlink" title="3.微内核结构"></a>3.微内核结构</h4><p>内核功能较少，不像整体式或层次式那样将所有模块封装在一起，而是只封装最核心的部分，这样能对内核的修改非常简便且维护简单，缺点是频繁被调用核心功能，多次在目态和管态间切换，效率低</p>
<h3 id="处理器（CPU）"><a href="#处理器（CPU）" class="headerlink" title="处理器（CPU）"></a>处理器（CPU）</h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>一般由运算器、控制器一系列的寄存器以及高速缓存构成<br>其中<strong>运算器</strong>能实现指令中的算术和逻辑运算；<strong>控制器</strong>负责程序运行的流程，包括取指令、维护处理器状态、处理器和内存的交互等；<strong>寄存器</strong>是一种暂时存储的器件，用于存储运行指令过程中暂存数据、地址以及指令信息<br>寄存器的运行速度比内存快上许多，寄存器通常分为两种：<br>用户可见寄存器-编译器可以调用这些寄存器，减少使用内存的次数以提高程序运行的效率<br>控制和状态寄存器-包括数据寄存器、地址寄存器和条件码寄存器，数据寄存器存储算术逻辑指令和访存指令；地址寄存器储存数据和指令的物理地址、线性地址或者有效地址；条件码存储器保存运算后的各种标记，如溢出、符号等</p>
<h4 id="指令执行的基本过程"><a href="#指令执行的基本过程" class="headerlink" title="指令执行的基本过程"></a>指令执行的基本过程</h4><p>首先处理器每次从存储器中读取一条指令，并根据指令类别将程序计数器的指改为下一条指令的地址（通常情况下指令在内存中都是连续的，所以大多是自增1）；其次指令被存储到指令寄存器中，然后处理器解释并执行，这就被成为一个指令周期<br>程序的执行就是不断地取指令→存指令→执行指令组成的，只有机器关机、发生未知错误或遇到停止指令时机器才会停止<br>指令大概分为五类（与特权非特权不同）<br>访问存储器指令-负责存储器和处理器间的数据传送<br>I/O指令-负责处理器和I/O模块间的数据和命令发送<br>算术逻辑指令-执行数据的算术和逻辑操作<br>控制转移指令-可以指定一个<strong>新的</strong>指令的<strong>执行地点</strong><br>处理器控制指令-用于修改处理器状态，改变其工作方式（即目态和管态的切换）</p>
<h4 id="特权与非特权指令"><a href="#特权与非特权指令" class="headerlink" title="特权与非特权指令"></a>特权与非特权指令</h4><p>用户不允许随意使用特权指令，以免造成系统的混乱；特权指令一般包括：<em>设置程序状态字、启动某种设备、设置中断屏蔽、设置时钟指令、清理内存和建立存储保护指令等</em>，用户只能间接的使用这些指令，每次使用时就需要将CPU的状态从目态切换至管态，这一过程被称为陷入（Trap）<br>操作系统运行的过程中目态和管态是在动态切换的，<strong>目态至管态</strong>的切换只能通过<strong>中断</strong>来进行，中断响应时交换中断向量，新的中断向量中的PSW（程序状态字）状态位标为管态；<strong>管态至目态</strong>直接修改PSW即可，不必经历中断<br>系统启动时，CPU的<strong>初始状态为管态</strong>，后装入操作系统后，让用户在目态执行</p>
<h4 id="程序状态字PSW"><a href="#程序状态字PSW" class="headerlink" title="程序状态字PSW"></a>程序状态字PSW</h4><p>有一个专门的寄存器来寄存处理器的状态；如程序计数器就来指示下一条要执行的指令<br>通常包括以下几个状态代码：<br>CPU的工作状态代码-指明是目态还是管态<br>条件码-反应指令执行后的结果特征<br>中断屏蔽码-指出是否运行中断</p>
<h3 id="硬件部件"><a href="#硬件部件" class="headerlink" title="硬件部件"></a>硬件部件</h3><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><p>基本上可以划分为两类：读写型的存储器和只读型的存储器<br>读写型的可以将数据存入任一地址单元并任意去取出或重新载入，即随机访问存储器（RAM）<br>只读型不能随意写入数据，称为只读存储器（ROM），还有PROM和EPROM等变种，PROM可用特殊的写入器写入，EPROM可用特殊的紫外线“擦去”信息位，再用写入器写入<br>存储的最小单位是1位（bit）只能存储1或0，<strong>一个字节包含8位</strong>，两个字节称为一个字，四个字节称为双字，1024个字节则为1KB，类推出MB、GB等<br>存储系统的设计要考虑三个问题：<strong>容量、速度和成本</strong><br>一般情况下，速度越快价格越高容量越小；速度越慢价格越低容量越大，合理分配计算机存储硬件等级也是值得考虑的，一般情况下<strong>寄存器&gt;高速缓存&gt;内存&gt;硬盘&gt;磁带、光驱</strong>比较合理<br>内存的保护<br>利用界地址寄存器来存储作业在内存中的上限和下限地址，当处理器访问内存时对比现请求的内存和已经在使用的内存是否越界，若越界则产生程序中断</p>
<h4 id="I-O部件"><a href="#I-O部件" class="headerlink" title="I/O部件"></a>I/O部件</h4><p>早期计算机是用CPU轮流询问硬件是否有处理请求后再处理，这种方式效率过低被淘汰<br>如今则采用<strong>通道</strong>的方式，通道是独立于CPU的，各种外部设备的设备控制器通过通道连接到系统的公共系统总线上；通道代替CPU处理I/O操作，使得外部设备和处理器可以<em>并行</em>工作；通道又被称为<strong>I/O处理器</strong><br>当CPU处理到“启动外设”的命令时就启动外设并将控制权交给通道，外设和内存的数据交换直接由通道控制，不经过CPU；外设工作结束后，形成一个“输入输出操作结束”的I/O中断事件，由CPU处理结束<br>这样大大提高了运行效率，不让设备和CPU空转运行；还会使用<strong>直接存储器访问（DMA）</strong>技术，DMA是一个总线中的一个独立的控制单元，自动控制成块的数据在内存和I/O单元间传送。处理器需要读取设备数据时给DMA发一条命令后可以处理其他事情，当DMA整理好数据发送过来时会触发中断来接收数据，这条命令通常包括设备的编址、开始读写的内存编制，需要传送的数据长度、是否请求读写等信息<br>当DMA和CPU在总线上冲突时，CPU会稍微等待一下<br>因为CPU的处理速度远远超过数据的输入输出速度，不可能在键盘敲下一个键就执行一次指令，这样大大浪费了CPU的速度，所以采用<strong>设立缓冲区</strong>的方法输入一定量的数据后再一次性传送给CPU</p>
<h4 id="时钟部件"><a href="#时钟部件" class="headerlink" title="时钟部件"></a>时钟部件</h4><p>计算机系统中时间部件是必要的，可以为系统发现一个死循环的程序，实现分时和实时系统、定时唤醒事先给定的外部事件、记录用户使用设备的时间和事件发生间隔以及记录绝对时间年月日等<br>时间部件一般分为硬件时钟和软件时钟，硬件则是利用电路中的晶体震荡器，每隔一段时间激发出一个频率的脉冲，时钟寄存器就不停对这个电路执行+1的操作，当计算机关机时，利用纽扣电池仍然在不停计时；软件则是利用程序来进行计时，系统需要同步硬件和软件时钟，绝对时间是执行+1操作，而相对时间执行-1操作（即倒计时）</p>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><h4 id="中断与异常的概念"><a href="#中断与异常的概念" class="headerlink" title="中断与异常的概念"></a>中断与异常的概念</h4><p><strong>中断</strong><br>CPU对系统内外发生的异步事件的响应即中断，异步事件指无一定顺序关系随机发生的事件；中断时实际意义是发生了异步事件后CPU中断当前程序转而处理异步事件，处理完后再回来执行先前的程序；几种名词的解释：<br>中断事件/中断源-引起中断的事件<br>中断请求-中断源向CPU发出的请求信号<br>中断处理程序-处理中断事件的程序<br>中断断点-原先程序的暂停点<br>中断响应-CPU暂停原先程序去处理中断的<em>过程</em><br>中断返回-处理结束后恢复原先程序的执行<br>中断字-计算机系统提供的中断源的有序集合，存在逻辑结构，不同处理器有不同的实现方式，Intel的x86处理器能处理256种中断<br>中断向量表-表中的每一项称为一个中断向量，主要有PSW和指令计数器PC组成，不同性质的中断源有不同的PSW和PC，通过此表找到相应的中断处理程序<br>中断技术的应用使得CPU运行效率提高，不用到处询问是否有事件发生，只要等待中断并且处理<br><strong>异常</strong><br>中断和异常的差别主要在中断是由外部事件引发的，而异常指由正在执行的指令引发的<br>中断的分类<br>时钟中断-按一定函数中断事件寄存器<br>输入输出（I/O）中断-硬件完成使用或期间引发的错误<br>控制台中断-操作员通过控制台发出命令<br>硬件故障中断-如断电存储器校验错误等<br>异常的分类<br>程序性中断-如溢出，除零，目态试图使用特权指令，访问不存在的目录等<br>访管指令异常-要求操作系统提供系统服务等</p>
<h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p>中断系统分为两个部分<br>硬件中断装置-负责捕获中断源发出的中断请求，以一定方式响应中断源，然后将处理器的权限转接给软件中断程序<br>软件中断程序-根据中断事件的性质执行相应的操作<br>请求的接收基本原理是通过中断逻辑线路接受并寄存到硬件触发器中，中断寄存器中包含了多种中断位，每一个中断位对应一种中断源<br>相应的具体过程是处理器接收中断信号→保护现场，将中断断点的PSW和PC存入系统堆栈→分析接收的中断向量，取得中断处理程序的地址→将CPU的PC设为此地址→调用中断处理程序→处理完后恢复现场原有程序继续运行<br>几种典型的中断处理<br>I/O中断-设备的唤醒和结束都会引发一次中断，多次引发会判断为设备故障通知管理员<br>时钟中断-控制定时任务和进程的处理器时间配额、处理器调度、维护软件时钟和实时处理<br>硬件故障中断-硬件问题引发的中断<br>程序性中断-指令出错、越权或越界而引发的系统保护；程序性中断可由系统完成也可以由程序自己完成<br>系统服务请求（自愿性中断）</p>
<h4 id="中断优先级、中断屏蔽和中断嵌套"><a href="#中断优先级、中断屏蔽和中断嵌套" class="headerlink" title="中断优先级、中断屏蔽和中断嵌套"></a>中断优先级、中断屏蔽和中断嵌套</h4><p>优先级-连接在不同的<strong>中断请求线</strong>上的中断信号，表示它们有不同的中断级别，硬件就决定了各个中断的优先级；例如电池即将没电，这类中断的优先级高于大多数中断；若同级中断有两种优先方法：一是硬件固定的优先数；二是轮转法<br>屏蔽-有些情况下一个中断在执行的时候，处于它级别低或者不会发生的中断都会被屏蔽；还有一类不可屏蔽的中断信号，屏蔽由卸载PSW中的中断屏蔽位中<br>嵌套-处理器在处理一个中断程序时又接收到一个中断信号时会有两种响应方式：<br>一是上述的中断屏蔽-新来的中断级别低于或相等于现在处理的中断等级<br>二就是中断嵌套；新来的中断级别高度现处理的中断，会类似递归一般在上个中断中再进行一次中断处理，处理过程和一般情况无异</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用时系统提供给用户访问特权指令的<strong>唯一接口</strong>，通过调用把CPU从目态切换至管态</p>
<h4 id="系统调用和函数调用的区别"><a href="#系统调用和函数调用的区别" class="headerlink" title="系统调用和函数调用的区别"></a>系统调用和函数调用的区别</h4><p>函数调用下-调用程序和被调用程序都运行在目态；系统调用下-调用程序在目态，而被调用程序在管态<br>因为不同调用运行在不同的状态，所以系统调用下的调用程序不能<strong>被</strong>调用，需要通过中断切换状态<br>系统调用也可以嵌套调用，不过嵌套的深度各有区别</p>
<h4 id="系统调用的分类"><a href="#系统调用的分类" class="headerlink" title="系统调用的分类"></a>系统调用的分类</h4><p>进程控制类-创建和终止<strong>进程的系统调用、获得和设置进程属性</strong>的系统调用<br>文件操作类-创建、打开、关闭和读写文件；创建目录以及移动文件的读写指针、改变文件的属性等<br>进程通信类-用于进程间传递信息和信号<br>设备管理类-用于请求和释放有关设备，以及启动设备操作等<br>信息维护类-用于获得当前时间和日期、设置文件访问和修改时间、了解当前用户数、系统版本号、空闲的内存磁盘等信息</p>
<h4 id="与库函数、API、内核函数的关系"><a href="#与库函数、API、内核函数的关系" class="headerlink" title="与库函数、API、内核函数的关系"></a>与库函数、API、内核函数的关系</h4><p>以库函数、API和内核函数为接口使用户能够调用特权指令</p>
<h4 id="系统调用的处理过程"><a href="#系统调用的处理过程" class="headerlink" title="系统调用的处理过程"></a>系统调用的处理过程</h4><p>与中断类似，不过这个过程称为陷入<br>当处理器执行到陷入指令时，首先调用中断，通过中断向量表把控制权交给系统调用总入口程序，该程序会进行现场保护和数据存入堆栈等操作，然后再查看<strong>系统调用表</strong>把控制权移交给相应的系统调用畜栏里例程或内核函数，执行完后恢复现场并返回用户程序</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><h4 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h4><p>程序是指在一个时间上按严格次序前后相继的<strong>操作序列</strong>，程序的顺序执行有如下特点<br>顺序性-程序所规定的动作再机器上严格地按顺序执行。每个动作的执行都以前一个动作的结束为前提<br>封闭性-程序运行后的计算结果只和程序自己有关，不受外界影响<br>执行结果的确定性-程序执行的结果和执行时间无关，中断不会影响结果<br>执行结果的可再现性-只要输入的初始条件相同，不论运行多少次结果都是一样的</p>
<h4 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h4><p>资源的共享和竞争存在于多道程序的并发中，从而制约了各道程序的执行速度；并发程序会出现“执行-暂停-执行”的活动现象<br>程序与计算不再一一对应，一个编译程序可为几个用户提供编译服务<br>执行结果不可重现-并发执行的结果会因为多道程序之间的相互制约关系导致不确定<br>程序的并发和并行执行与第一章的说法相同，并发为宏观，并行为微观</p>
<h4 id="多道程序设计-1"><a href="#多道程序设计-1" class="headerlink" title="多道程序设计"></a>多道程序设计</h4><p>与先前提到的一样，是为了减少设备的空转提高利用率采用多道程序设计，举一个例子<br>程序A的执行顺序为：CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)，共40s<br>程序B的执行顺序为：设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)，共40s</p>
<p>若是<strong>顺序执行</strong>则肯定要么先执行A后执行B，要么先B后A<br>所以执行情况为【CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)】→【设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)】，共80s<br>CPU、设备1和设备2的利用率分别为50%、18.75%和31.25%<br><strong>并发执行</strong>时为<br> CPU(10s)   →设备1(5s)        →CPU(5s)   →      设备2(10s)   →CPU(10s)<br>设备2(10s)  →     CPU(10s)    →设备1(5s) →CPU(5s)            →设备2(10s)<br>共45s，CPU、设备1和设备2的利用率分别为89%、33%和56%</p>
<p>特点：目的是提高整个系统的效率，提高系统吞吐量（指单位时间内系统处理的进程的道数）<br>拥有<strong>独立性</strong>、<strong>随机性</strong>和<strong>资源共享性</strong>等特征；缺点是在某些情况下延长了程序的执行时间，如上面的例子，程序A本可以40s内执行完，应用在多道技术后延长至45s，在特定的程序内这5s是非常致命的</p>
<h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>进程是具有<strong>一定独立功能的程序</strong>在某个数据集合上的一次<strong>运行活动</strong>，是系统进行资源分配和调度的一个<strong>独立单位</strong><br>进程由<strong>程序</strong>、<strong>数据</strong>和<strong>进程控制块（PCB）</strong>三部分组成；程序是静态的、线程是动态的；线程为了程序而存在；进程也可以创建进程，被创建的叫子进程，创建者叫父进程<br>一个能被多个用户同时调用的程序称作<strong>可再入的程序</strong>，此程序在执行过程中不会修改自身的代码；现代的操作系统和编译程序都属于可再入程序<br>进程的几个特性<br>并发性-进程的第一个动作可以在上一个进程最后一个动作之前开始<br>动态性-进程有生命周期，状态不断在发生变化<br>独立性-进程是一个相对完整的资源分配单位<br>交往性-一个进程在运行过程中可能和其他进程发生直接或间接的相互作用<br>异步性-每个程序按照各自独立的、不可预知的速度往前推进<br>结构性-由程序、数据和进程控制块组成</p>
<h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><p><strong>三状态模型</strong><br>此模型下的进程可以有以下三种状态之一，在任何时刻，任何进程都处于且仅处于三种状态之一<br>运行-进程已经获得处理器，并在处理器上执行的状态；在分时操作系统中，正在运行的程序的时间片使用完后会发出中断请求并将进程转为就绪或等待状态<br>就绪-已经具备运行条件，但还没有空闲的处理器分配给他，当处理器空闲时会根据调度算法把处理器分配给其中一个就绪的进程<br>等待-进程因为等待某个时间而暂时不能运行的状态，当事件结束时转为就绪状态等待分配处理器<br><strong>五状态模型</strong><br>运行-进程占用完CPU的资源，道数≤CPU数量；通常没有其他进程执行时（如所有进程都在阻塞状态），会自动执行空闲进程<br>就绪-与上述一致，I/O设备会排入高级优先队列<br>阻塞-进程等待I/O操作或进程同步等条件而暂停运行，条件满足前即使分配了处理器也无法运行，排成一个阻塞队列<br>创建-在此状态的工作有分配和建立进程控制块表项、建立资源表格并分配资源，加载程序并建立地址空间等；<em>创建至就绪称为提交</em><br>结束-进程结束后回收<strong>除进程控制块</strong>之外的其他资源，并让其他进程从进程控制块中收集有关信息；<em>运行至结束称为释放</em><br><strong>七状态模型</strong><br>七状态模型区分内外存<br>就绪、阻塞、创建、退出（结束）-一致<br>阻塞挂起-进程在外存并等待时间出现；<em>阻塞至阻塞挂起：没有就绪进程或就绪进程需要更多内存资源</em><br>就绪挂起-进程在外存，但只要进入内存即可运行；<em>就绪至就绪挂起：高优先级阻塞进入低优先级就绪时会就绪挂起；运行到就绪挂起：与前面一致，不过对象时在运行的进程</em><br>挂起-把进程从内存转到外存<br>激活-把进程从外存转入内存</p>
<h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>PCB是进程重要的组成部分，它包含<strong>调度信息</strong>和<strong>现场信息</strong>两部分<br>调度信息中包括了进程号和进程名-作用是标识一个进程，每个进程号都是唯一的<br>地址信息空间-记录了系统为每个进程分配的一个地址空间<br>优先级-确定的优先级信息<br>当前状态-表明是现在是就绪、等待还是运行状态<br>资源清单-包含了进程执行所需的资源<br>“家族”关系-包含了其父进程和子进程关系<br>消息队列指针-表明进程所属的消息队列所在的地址，消息队列的作用是与其他进程进行通讯<br>进程队列指针-指出现在进程所在队列的位置<br>当前打开文件-记录进程使用文件的情况<br>PCB大致有三种组织方式<br>线性-将所有PCB组织在一个连续表上，简单不需要额外开销，缺点是找一个PCB时需要遍历整个表<br>索引-对具有相同状态的线程，分别设置PCB表，表目是每个PCB的地址，就构成了索引表和被索引表<br>链接-对相同状态线程-利用PCB中的链接字构成队列，链接字指出PCB在表中的编号，与索引类似<br>进程的队列根据状态分为就绪队列、等待队列和运行队列<br>队列的具体组成和链表类似，都是利用单向或双向指针来进行索引，当然在表头有一个头指针；线程的出/入队操作都和链表的操作集合一样</p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>进程状态的切换具体是由<strong>原语</strong>进行实现的，原语是系统的核心功能，运作在管态，常驻于内存；原语和系统调用都可被进程调用，不过原语有<strong>不可中断</strong>的特性<br>用于进程控制的原语有：<br>创建原语-可以创建一个进程并构造父子关系；其主要任务是申请一块空闲的PCB区域，然后将信息填入PCB，置该进程于就绪状态插入队列<br>撤销原语-进程完成后释放资源并撤销PCB；具体过程是找到该PCB的位置后移出队列，撤销它的所有子孙队列，释放全部资源，最后撤销PCB<br>阻塞原语-执行I/O操作，将运行换至阻塞；过程是中断处理器的执行，保存PCB的现场信息，将进程状态切换并置入等待队列<br>唤醒原语-等待事件的进程用唤醒原语转换至就绪状态；在队列中找到PCB，切换状态，然后从等待队列出队置入就绪队列</p>
<h4 id="实例：Unix操作系统的进程创建操作fork"><a href="#实例：Unix操作系统的进程创建操作fork" class="headerlink" title="实例：Unix操作系统的进程创建操作fork"></a>实例：Unix操作系统的进程创建操作fork</h4><p>待补充</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>为了减少程序并发执行所付出的时间和空间的开销，人们引入了线程的概念。线程是进程中的一个实体，是处理器调度和分派的<strong>基本单位</strong>，线程基本不拥有资源，只占有必须的少量资源，但他可以使用所处进程下的所有资源。<br>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程可以并发执行，同样有就绪、等待和运行三种状态。<br>线程有以下属性：<br>1.每个线程为一个唯一的标识符和一张线程描述表，记录了线程执行的寄存器以及栈等现场状态<br>2.不同的线程可以执行相同的程序，也就是同一个服务被不同用户调用时创建两个不同的线程<br>3.同进程中的各个线程共享进程的内存空间<br>4.线程是CPU的基本调度单位，可以并发执行；单核可交替占用处理器，多核多线程可占用不同的处理器，若多个核心为一个进程运算，那么会减少计算时间<br>5.线程在创建后拥有一个生命周期，周期内会经历就绪、等待和运行多种状态的切换，直至周期终止<br>引入线程的好处：<br>1.创建新线程所需要的时间少，而且不必重新分配资源<br>2.线程相互切换所需的时间少<br>3.因同进程内的线程共享内存空间，所以线程之间交换数据不必调用内核，效率更高<br>4.线程能独立运行，能充分发挥处理器和io设备的并行工作能力</p>
<h4 id="线程的实现机制"><a href="#线程的实现机制" class="headerlink" title="线程的实现机制"></a>线程的实现机制</h4><p>用户级线程：<br>只存在于用户态中，对其的创建、撤销和切换都<strong>不会</strong>通过系统调用来实现。优点是有些操作系统不支持线程，但因为这种线程存在于目态，也可以用函数库实现线程<br><strong>线程表</strong>：用来跟踪该进程中的线程，和PCB类似，不过仅仅记录各个线程的属性，如程序计数器、堆栈指针、寄存器和状态等。当一个线程转换到就绪或者阻塞时，就在表中存放重新启动该线程时所需要的信息。<br>内核级线程:<br>内核级和用户级的区别基本上在于进程中的线程表分别存放在核心态和用户态，内核级线程的切换效率会稍低些<br>混合实现方式：<br>一些系统混合使用了用户级和内核级线程，实例P99</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>实际情况下，进程的数量是多于处理器数量的，如何做好调度是关键</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>根据一定的调度算法，在就绪队列中选出一个进程将PCB中相关信息放入寄存器中，并分配处理器运行。<br>调度的时机一般有：<br>正在执行的进程运行完毕<br>正在执行的进程因某种错误终止<br>时间片用完，进程从运行转为就绪状态<br>正在执行的进程用阻塞原语将自己阻塞起来<br>创建了新进程进入了就绪队列<br>正在执行的进程用唤醒原语激活了等待队列的进程使其归入就绪队列</p>
<h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>进程行为</p>
<h3 id="进程间相互作用"><a href="#进程间相互作用" class="headerlink" title="进程间相互作用"></a>进程间相互作用</h3><h4 id="相关进程和无关进程"><a href="#相关进程和无关进程" class="headerlink" title="相关进程和无关进程"></a>相关进程和无关进程</h4><p>有逻辑相关的即相关进程，无关进程同理，并发的进程间不一定有逻辑关系</p>
<h4 id="与时间有关的错误"><a href="#与时间有关的错误" class="headerlink" title="与时间有关的错误"></a>与时间有关的错误</h4><p>例如两个不同的程序运行，它们都共同使用的一个名为”n”的变量，因为两个程序是在交替运行的，使用同一个变量很容易发成错误，这类错误统称与时间有关的错误。</p>
<h3 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h3><h4 id="同步关系"><a href="#同步关系" class="headerlink" title="同步关系"></a>同步关系</h4><p>为了完成某种工作，进程间经常需要合作。例如一批数据记录需要加工处理，为此创建两个进程，还设置了容量为一个记录单位的缓冲器。进程A在硬盘上读取记录，每读出一个记录就存入缓冲区，进程B从缓冲区内取出数据加工，直到所有记录都处理完毕<br>当然它们是在并发运行，而且在同时使用缓冲区，如果不对它们进行制约就会发生冲突，运行速度也是关键，若A的速度比B快，则有可能丢失数据等错误发生，所以协调它们的节奏非常重要</p>
<h4 id="互斥关系"><a href="#互斥关系" class="headerlink" title="互斥关系"></a>互斥关系</h4><p>与前文相同，试图调用如打印机等单一访问的设备时应该要产生互斥</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>系统中的某些资源一次只允许一个进程访问，则这类资源称为<strong>临界资源或共享变量</strong>而在进程中访问临界资源的程序称为<strong>临界区</strong><br>系统对临界区的调度使用原则归纳如下：<br>1.临界区为空时，有一个进程要求访问应立即允许其进入<strong>有空让进</strong><br>2.有一个进程处于临界区时，其他请求进入的进程必须等待<strong>无空等待</strong><br>3.临界区空闲，而多个进程请求访问时只允许其中一个进入，其他的必须等待<strong>多种择一</strong><br>4.任一进程进入临界区的要求应在有限的时间内完成<strong>有限等待</strong><br>5.处于等待状态下的进程应主动放弃CPU<strong>让权等待</strong><br>1表示要有效利用临界资源；2反映了互斥的含义，资源具有排他性；3是1和2的一个特殊情况；4、5是为了避免进程间发生忙等待或死锁</p>
<h3 id="信号量与P、V操作"><a href="#信号量与P、V操作" class="headerlink" title="信号量与P、V操作"></a>信号量与P、V操作</h3><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是种特殊的变量，它的表面形式是<strong>一个整形变量加一个队列</strong>，并且只能被P、V操作使用，P、V操作都是原语（P是荷兰语”等待”的首字母，而V是”发信号”的首字母）。</p>
<h4 id="P、V操作"><a href="#P、V操作" class="headerlink" title="P、V操作"></a>P、V操作</h4><p>定义如下<br>P(S)<br>{<br>    S = S-1;<br>}<br>若S&lt;0，将该进程状态置为等待，然后再PCB中插入响应的S信号量等待队列末尾，直到其他进程再S上执行V操作<br>V(S)<br>{<br>    S = S+1;<br>}<br>若S≤0，释放再S信号量队列中等待的一个进程，将其状态改变为就绪态，并将其插入就绪队列；然后执行本操作的进程继续执行；<br>S即表示某类可用的临界资源，当S&gt;0时表示该类资源可以分配，S&lt;0时表示没有可分配的资源数量，其<strong>S的绝对值表示排在S信号量的等待队列中进程的数目</strong><br>每执行一次P操作，意味请求的进程分配到一个资源，每执行一次V操作，意味该进程释放了一个资源</p>
<h4 id="用P、V操作实现进程间的互斥"><a href="#用P、V操作实现进程间的互斥" class="headerlink" title="用P、V操作实现进程间的互斥"></a>用P、V操作实现进程间的互斥</h4><p>S = 1<br>进程A、B都执行：<br>P(S);<br>    operation;<br>V(S);</p>
<h4 id="用P、V操作实现进程间的同步"><a href="#用P、V操作实现进程间的同步" class="headerlink" title="用P、V操作实现进程间的同步"></a>用P、V操作实现进程间的同步</h4><p>例如存在两个信号量S1与S2<br>赋值为 S1 = S2 = 0    //S1表示在一个缓冲区内是否装满信息，S2表示该区中的信息是否取走<br>程序A<br>while(true){<br>    msginput;<br>    V(S1);<br>    P(S2);<br>};</p>
<p>程序B<br>while(true){<br>    P(S1);<br>    msgoutput;<br>    V(S2);<br>};<br>因为程序的交替执行，可以看出A先将信息放入缓冲区然后释放它，随后切换到B请求并取出，然后再检查缓冲区，如此循环<br>三进程或以上的情况见P118附图</p>
<h4 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h4><p>一、简单消费者问题<br>二、多个消费者问题<br>三、读写机制问题<br>四、综合应用-路口单双号交通管制<br>五、物流系统物品分拣问题</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>单纯使用PV操作有诸多问题，于是引入管程的概念；<br>管程的四个部分为管程名称、共享数据说明、对数据操作的一组过程和对共享数据赋初值的语句；类似面对对象程序语音中的类，定义了其中的初始属性和方法(函数)<br>管程主要有三个特性：<br>1.模块化，管程时一个基本程序单位，可单独编译<br>2.抽象数据类型，管程是一种特殊的数据类型，不仅有数据，而且有对数据进行操作的代码<br>3.信息隐蔽，管程是半透明的，他能实现某种功能，但具体的实现方式外部并不知道也没有必要知道</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/23/Python-Note/" rel="prev" title="Python_Note">
      <i class="fa fa-chevron-left"></i> Python_Note
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/01/Datasource1/" rel="next" title="数据结构考纲识记理解内容（上）">
      数据结构考纲识记理解内容（上） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%AC%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">概述及公式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">计算公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PV%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.</span> <span class="nav-text">PV操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E5%8F%8A%E5%8C%96%E7%AE%80%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">资源分配图及化简方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">磁盘调度的几种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.7.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="nav-number">1.8.</span> <span class="nav-text">页式管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%8A%80%E6%9C%AF"><span class="nav-number">1.9.</span> <span class="nav-text">通道技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">1.10.</span> <span class="nav-text">文件管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9"><span class="nav-number">2.</span> <span class="nav-text">详细内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">操作系统的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">2.2.</span> <span class="nav-text">操作系统的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.并发性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%85%B1%E4%BA%AB%E6%80%A7"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.共享性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%99%9A%E6%8B%9F%E6%80%A7"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.虚拟性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%9A%8F%E6%9C%BA%E6%80%A7"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.随机性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%94%E7%A9%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">研究操作系统的观点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.软件的观点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.资源管理的观点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.进程的观点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%99%9A%E6%9C%BA%E5%99%A8%E7%9A%84%E8%A7%82%E7%82%B9%EF%BC%88%E9%9D%9E%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="nav-number">2.3.4.</span> <span class="nav-text">4.虚机器的观点（非虚拟机）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-number">2.3.5.</span> <span class="nav-text">5.服务提供者的观点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">2.4.</span> <span class="nav-text">操作系统的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.进程管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.文件管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.设备管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.5.</span> <span class="nav-text">5.用户接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.</span> <span class="nav-text">操作系统的体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows"><span class="nav-number">2.5.1.</span> <span class="nav-text">Windows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unix"><span class="nav-number">2.5.2.</span> <span class="nav-text">Unix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-number">2.5.3.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android"><span class="nav-number">2.5.4.</span> <span class="nav-text">Android</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="nav-number">2.6.</span> <span class="nav-text">操作系统的发展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%89%8B%E5%B7%A5%E5%8F%91%E5%B1%95"><span class="nav-number">2.6.1.</span> <span class="nav-text">1.手工发展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.监控程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-number">2.6.3.</span> <span class="nav-text">3.多道批处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%88%86%E6%97%B6%E4%B8%8E%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.4.</span> <span class="nav-text">4.分时与实时系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Unix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.5.</span> <span class="nav-text">5.Unix操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.6.</span> <span class="nav-text">6.个人计算机操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Android%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.7.</span> <span class="nav-text">7.Android系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB"><span class="nav-number">2.7.</span> <span class="nav-text">操作系统分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.1.</span> <span class="nav-text">1.批处理操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.分时操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.3.</span> <span class="nav-text">3.实时操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.4.</span> <span class="nav-text">4.嵌入式操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.5.</span> <span class="nav-text">5.个人计算机系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.6.</span> <span class="nav-text">6.网络操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.7.</span> <span class="nav-text">7.分布式操作系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.</span> <span class="nav-text">操作系统的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B4%E4%BD%93%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.1.</span> <span class="nav-text">1.整体式结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B1%82%E6%AC%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.层次式结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.3.</span> <span class="nav-text">3.微内核结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88CPU%EF%BC%89"><span class="nav-number">2.9.</span> <span class="nav-text">处理器（CPU）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E6%88%90"><span class="nav-number">2.9.1.</span> <span class="nav-text">构成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="nav-number">2.9.2.</span> <span class="nav-text">指令执行的基本过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%9D%83%E4%B8%8E%E9%9D%9E%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="nav-number">2.9.3.</span> <span class="nav-text">特权与非特权指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AD%97PSW"><span class="nav-number">2.9.4.</span> <span class="nav-text">程序状态字PSW</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E9%83%A8%E4%BB%B6"><span class="nav-number">2.10.</span> <span class="nav-text">硬件部件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.10.1.</span> <span class="nav-text">存储系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E9%83%A8%E4%BB%B6"><span class="nav-number">2.10.2.</span> <span class="nav-text">I&#x2F;O部件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E9%83%A8%E4%BB%B6"><span class="nav-number">2.10.3.</span> <span class="nav-text">时钟部件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">2.11.</span> <span class="nav-text">中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.11.1.</span> <span class="nav-text">中断与异常的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.11.2.</span> <span class="nav-text">中断系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97"><span class="nav-number">2.11.3.</span> <span class="nav-text">中断优先级、中断屏蔽和中断嵌套</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.12.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.12.1.</span> <span class="nav-text">系统调用和函数调用的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.12.2.</span> <span class="nav-text">系统调用的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81API%E3%80%81%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.12.3.</span> <span class="nav-text">与库函数、API、内核函数的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">2.12.4.</span> <span class="nav-text">系统调用的处理过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.13.</span> <span class="nav-text">多道程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">2.13.1.</span> <span class="nav-text">程序的顺序执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="nav-number">2.13.2.</span> <span class="nav-text">程序的并发执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1"><span class="nav-number">2.13.3.</span> <span class="nav-text">多道程序设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-1"><span class="nav-number">2.14.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.14.1.</span> <span class="nav-text">进程的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.14.2.</span> <span class="nav-text">进程的状态与转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%89"><span class="nav-number">2.14.3.</span> <span class="nav-text">进程控制块（PCB）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">2.14.4.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9AUnix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9Cfork"><span class="nav-number">2.14.5.</span> <span class="nav-text">实例：Unix操作系统的进程创建操作fork</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.15.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.15.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.15.2.</span> <span class="nav-text">线程的实现机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">2.16.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.16.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.16.2.</span> <span class="nav-text">算法设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8"><span class="nav-number">2.17.</span> <span class="nav-text">进程间相互作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%97%A0%E5%85%B3%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.17.1.</span> <span class="nav-text">相关进程和无关进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E6%97%B6%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">2.17.2.</span> <span class="nav-text">与时间有关的错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">2.18.</span> <span class="nav-text">进程的同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%85%B3%E7%B3%BB"><span class="nav-number">2.18.1.</span> <span class="nav-text">同步关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E5%85%B3%E7%B3%BB"><span class="nav-number">2.18.2.</span> <span class="nav-text">互斥关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">2.18.3.</span> <span class="nav-text">临界区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8EP%E3%80%81V%E6%93%8D%E4%BD%9C"><span class="nav-number">2.19.</span> <span class="nav-text">信号量与P、V操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.19.1.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P%E3%80%81V%E6%93%8D%E4%BD%9C"><span class="nav-number">2.19.2.</span> <span class="nav-text">P、V操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8P%E3%80%81V%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5"><span class="nav-number">2.19.3.</span> <span class="nav-text">用P、V操作实现进程间的互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8P%E3%80%81V%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">2.19.4.</span> <span class="nav-text">用P、V操作实现进程间的同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">2.19.5.</span> <span class="nav-text">进程同步问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">2.20.</span> <span class="nav-text">管程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Soya</p>
  <div class="site-description" itemprop="description">联系唯一邮箱：soya-kelaos@outlook.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/soya2" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soya2" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/soooooya2" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;soooooya2" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Soya</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
