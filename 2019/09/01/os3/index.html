<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Soya"><title>操作系统（三）进程与线程 · 恰恰书库</title><meta name="description" content="多道程序设计程序的顺序执行程序是指在一个时间上按严格次序前后相继的操作序列，程序的顺序执行有如下特点顺序性-程序所规定的动作再机器上严格地按顺序执行。每个动作的执行都以前一个动作的结束为前提封闭性-程序运行后的计算结果只和程序自己有关，不受外界影响执行结果的确定性-程序执行的结果和执行时间无关，中断"><meta name="keywords" content><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Typography</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li><a href="/about/index.html">about</a></li><li class="soc"><a href="soya2.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="soya2.github.io" rel="noopener noreferrer">Soya</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>操作系统（三）进程与线程</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2019-09-01</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/操作系统/" title="操作系统" class="a-tag">操作系统</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><h4 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h4><p>程序是指在一个时间上按严格次序前后相继的<strong>操作序列</strong>，程序的顺序执行有如下特点<br>顺序性-程序所规定的动作再机器上严格地按顺序执行。每个动作的执行都以前一个动作的结束为前提<br>封闭性-程序运行后的计算结果只和程序自己有关，不受外界影响<br>执行结果的确定性-程序执行的结果和执行时间无关，中断不会影响结果<br>执行结果的可再现性-只要输入的初始条件相同，不论运行多少次结果都是一样的</p>
<h4 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h4><p>资源的共享和竞争存在于多道程序的并发中，从而制约了各道程序的执行速度；并发程序会出现“执行-暂停-执行”的活动现象<br>程序与计算不再一一对应，一个编译程序可为几个用户提供编译服务<br>执行结果不可重现-并发执行的结果会因为多道程序之间的相互制约关系导致不确定<br>程序的并发和并行执行与第一章的说法相同，并发为宏观，并行为微观</p>
<h4 id="多道程序设计-1"><a href="#多道程序设计-1" class="headerlink" title="多道程序设计"></a>多道程序设计</h4><p>与先前提到的一样，是为了减少设备的空转提高利用率采用多道程序设计，举一个例子<br>程序A的执行顺序为：CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)，共40s<br>程序B的执行顺序为：设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)，共40s</p>
<p>若是<strong>顺序执行</strong>则肯定要么先执行A后执行B，要么先B后A<br>所以执行情况为【CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)→CPU(10s)】→【设备2(10s)→CPU(10s)→设备1(5s)→CPU(5s)→设备2(10s)】，共80s<br>CPU、设备1和设备2的利用率分别为50%、18.75%和31.25%<br><strong>并发执行</strong>时为<br> CPU(10s)   →设备1(5s)        →CPU(5s)   →      设备2(10s)   →CPU(10s)<br>设备2(10s)  →     CPU(10s)    →设备1(5s) →CPU(5s)            →设备2(10s)<br>共45s，CPU、设备1和设备2的利用率分别为89%、33%和56%</p>
<p>特点：目的是提高整个系统的效率，提高系统吞吐量（指单位时间内系统处理的进程的道数）<br>拥有<strong>独立性</strong>、<strong>随机性</strong>和<strong>资源共享性</strong>等特征；缺点是在某些情况下延长了程序的执行时间，如上面的例子，程序A本可以40s内执行完，应用在多道技术后延长至45s，在特定的程序内这5s是非常致命的</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>进程是具有<strong>一定独立功能的程序</strong>在某个数据集合上的一次<strong>运行活动</strong>，是系统进行资源分配和调度的一个<strong>独立单位</strong><br>进程由<strong>程序</strong>、<strong>数据</strong>和<strong>进程控制块（PCB）</strong>三部分组成；程序是静态的、线程是动态的；线程为了程序而存在；进程也可以创建进程，被创建的叫子进程，创建者叫父进程<br>一个能被多个用户同时调用的程序称作<strong>可再入的程序</strong>，此程序在执行过程中不会修改自身的代码；现代的操作系统和编译程序都属于可再入程序<br>进程的几个特性<br>并发性-进程的第一个动作可以在上一个进程最后一个动作之前开始<br>动态性-进程有生命周期，状态不断在发生变化<br>独立性-进程是一个相对完整的资源分配单位<br>交往性-一个进程在运行过程中可能和其他进程发生直接或间接的相互作用<br>异步性-每个程序按照各自独立的、不可预知的速度往前推进<br>结构性-由程序、数据和进程控制块组成</p>
<h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><p><strong>三状态模型</strong><br>此模型下的进程可以有以下三种状态之一，在任何时刻，任何进程都处于且仅处于三种状态之一<br>运行-进程已经获得处理器，并在处理器上执行的状态；在分时操作系统中，正在运行的程序的时间片使用完后会发出中断请求并将进程转为就绪或等待状态<br>就绪-已经具备运行条件，但还没有空闲的处理器分配给他，当处理器空闲时会根据调度算法把处理器分配给其中一个就绪的进程<br>等待-进程因为等待某个时间而暂时不能运行的状态，当事件结束时转为就绪状态等待分配处理器<br><strong>五状态模型</strong><br>运行-进程占用完CPU的资源，道数≤CPU数量；通常没有其他进程执行时（如所有进程都在阻塞状态），会自动执行空闲进程<br>就绪-与上述一致，I/O设备会排入高级优先队列<br>阻塞-进程等待I/O操作或进程同步等条件而暂停运行，条件满足前即使分配了处理器也无法运行，排成一个阻塞队列<br>创建-在此状态的工作有分配和建立进程控制块表项、建立资源表格并分配资源，加载程序并建立地址空间等；<em>创建至就绪称为提交</em><br>结束-进程结束后回收<strong>除进程控制块</strong>之外的其他资源，并让其他进程从进程控制块中收集有关信息；<em>运行至结束称为释放</em><br><strong>七状态模型</strong><br>七状态模型区分内外存<br>就绪、阻塞、创建、退出（结束）-一致<br>阻塞挂起-进程在外存并等待时间出现；<em>阻塞至阻塞挂起：没有就绪进程或就绪进程需要更多内存资源</em><br>就绪挂起-进程在外存，但只要进入内存即可运行；<em>就绪至就绪挂起：高优先级阻塞进入低优先级就绪时会就绪挂起；运行到就绪挂起：与前面一致，不过对象时在运行的进程</em><br>挂起-把进程从内存转到外存<br>激活-把进程从外存转入内存</p>
<h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>PCB是进程重要的组成部分，它包含<strong>调度信息</strong>和<strong>现场信息</strong>两部分<br>调度信息中包括了进程号和进程名-作用是标识一个进程，每个进程号都是唯一的<br>地址信息空间-记录了系统为每个进程分配的一个地址空间<br>优先级-确定的优先级信息<br>当前状态-表明是现在是就绪、等待还是运行状态<br>资源清单-包含了进程执行所需的资源<br>“家族”关系-包含了其父进程和子进程关系<br>消息队列指针-表明进程所属的消息队列所在的地址，消息队列的作用是与其他进程进行通讯<br>进程队列指针-指出现在进程所在队列的位置<br>当前打开文件-记录进程使用文件的情况<br>PCB大致有三种组织方式<br>线性-将所有PCB组织在一个连续表上，简单不需要额外开销，缺点是找一个PCB时需要遍历整个表<br>索引-对具有相同状态的线程，分别设置PCB表，表目是每个PCB的地址，就构成了索引表和被索引表<br>链接-对相同状态线程-利用PCB中的链接字构成队列，链接字指出PCB在表中的编号，与索引类似<br>进程的队列根据状态分为就绪队列、等待队列和运行队列<br>队列的具体组成和链表类似，都是利用单向或双向指针来进行索引，当然在表头有一个头指针；线程的出/入队操作都和链表的操作集合一样</p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>进程状态的切换具体是由<strong>原语</strong>进行实现的，原语是系统的核心功能，运作在管态，常驻于内存；原语和系统调用都可被进程调用，不过原语有<strong>不可中断</strong>的特性<br>用于进程控制的原语有：<br>创建原语-可以创建一个进程并构造父子关系；其主要任务是申请一块空闲的PCB区域，然后将信息填入PCB，置该进程于就绪状态插入队列<br>撤销原语-进程完成后释放资源并撤销PCB；具体过程是找到该PCB的位置后移出队列，撤销它的所有子孙队列，释放全部资源，最后撤销PCB<br>阻塞原语-执行I/O操作，将运行换至阻塞；过程是中断处理器的执行，保存PCB的现场信息，将进程状态切换并置入等待队列<br>唤醒原语-等待事件的进程用唤醒原语转换至就绪状态；在队列中找到PCB，切换状态，然后从等待队列出队置入就绪队列</p>
<h4 id="实例：Unix操作系统的进程创建操作fork"><a href="#实例：Unix操作系统的进程创建操作fork" class="headerlink" title="实例：Unix操作系统的进程创建操作fork"></a>实例：Unix操作系统的进程创建操作fork</h4><p>待补充</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>为了减少程序并发执行所付出的时间和空间的开销，人们引入了线程的概念。线程是进程中的一个实体，是处理器调度和分派的<strong>基本单位</strong>，线程基本不拥有资源，只占有必须的少量资源，但他可以使用所处进程下的所有资源。<br>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程可以并发执行，同样有就绪、等待和运行三种状态。<br>线程有以下属性：<br>1.每个线程为一个唯一的标识符和一张线程描述表，记录了线程执行的寄存器以及栈等现场状态<br>2.不同的线程可以执行相同的程序，也就是同一个服务被不同用户调用时创建两个不同的线程<br>3.同进程中的各个线程共享进程的内存空间<br>4.线程是CPU的基本调度单位，可以并发执行；单核可交替占用处理器，多核多线程可占用不同的处理器，若多个核心为一个进程运算，那么会减少计算时间<br>5.线程在创建后拥有一个生命周期，周期内会经历就绪、等待和运行多种状态的切换，直至周期终止<br>引入线程的好处：<br>1.创建新线程所需要的时间少，而且不必重新分配资源<br>2.线程相互切换所需的时间少<br>3.因同进程内的线程共享内存空间，所以线程之间交换数据不必调用内核，效率更高<br>4.线程能独立运行，能充分发挥处理器和io设备的并行工作能力</p>
<h4 id="线程的实现机制"><a href="#线程的实现机制" class="headerlink" title="线程的实现机制"></a>线程的实现机制</h4><p>用户级线程：<br>只存在于用户态中，对其的创建、撤销和切换都<strong>不会</strong>通过系统调用来实现。优点是有些操作系统不支持线程，但因为这种线程存在于目态，也可以用函数库实现线程<br><strong>线程表</strong>：用来跟踪该进程中的线程，和PCB类似，不过仅仅记录各个线程的属性，如程序计数器、堆栈指针、寄存器和状态等。当一个线程转换到就绪或者阻塞时，就在表中存放重新启动该线程时所需要的信息。<br>内核级线程:<br>内核级和用户级的区别基本上在于进程中的线程表分别存放在核心态和用户态，内核级线程的切换效率会稍低些<br>混合实现方式：<br>一些系统混合使用了用户级和内核级线程，实例P99</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>实际情况下，进程的数量是多于处理器数量的，如何做好调度是关键</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>根据一定的调度算法，在就绪队列中选出一个进程将PCB中相关信息放入寄存器中，并分配处理器运行。<br>调度的时机一般有：<br>正在执行的进程运行完毕<br>正在执行的进程因某种错误终止<br>时间片用完，进程从运行转为就绪状态<br>正在执行的进程用阻塞原语将自己阻塞起来<br>创建了新进程进入了就绪队列<br>正在执行的进程用唤醒原语激活了等待队列的进程使其归入就绪队列</p>
<h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>进程行为</p>
<p></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=soya2.github.io/2019/09/01/os3/%20恰恰书库%20操作系统（三）进程与线程" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/10/14/os4/" title="操作系统（四）同步与互斥"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 操作系统（四）同步与互斥</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/08/31/os2/" title="操作系统（二）运行环境">Next post: 操作系统（二）运行环境&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="soya2.github.io" rel="noopener noreferrer">Soya</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>